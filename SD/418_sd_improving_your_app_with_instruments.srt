

1
00:00:12.716 --> 00:00:21.846 A:middle
&gt;&gt; Howdy. I'm Daniel Delwood
and I'm excited to welcome you

2
00:00:21.846 --> 00:00:24.216 A:middle
to Session 418, "Improving
Your App With Instruments".

3
00:00:24.356 --> 00:00:25.666 A:middle
I've got a lot of fun stuff

4
00:00:25.666 --> 00:00:28.876 A:middle
to cover today, so
let's get started.

5
00:00:28.986 --> 00:00:30.906 A:middle
So there are five items
on our agenda today,

6
00:00:31.156 --> 00:00:32.676 A:middle
but really only one
goal and that's

7
00:00:32.676 --> 00:00:34.856 A:middle
to give you the tools
you need to go out

8
00:00:34.856 --> 00:00:36.926 A:middle
and proactively profile
your apps,

9
00:00:37.026 --> 00:00:40.716 A:middle
looking for memory
problems, CPU problems,

10
00:00:41.056 --> 00:00:44.316 A:middle
and overall to increase the
efficiency of your applications.

11
00:00:44.776 --> 00:00:46.416 A:middle
So I'll start by
talking about what's new

12
00:00:46.416 --> 00:00:49.256 A:middle
in Instruments this year, and
then we'll have three sections:

13
00:00:49.906 --> 00:00:51.766 A:middle
memory management,
time profiling,

14
00:00:51.826 --> 00:00:55.106 A:middle
and performance counters,
each with associated demos.

15
00:00:55.666 --> 00:00:58.846 A:middle
Hopefully, so that whether
you're a new profiler

16
00:00:59.066 --> 00:01:00.026 A:middle
on our platform

17
00:01:00.296 --> 00:01:03.806 A:middle
or an experienced Instruments
veteran you should be able

18
00:01:03.806 --> 00:01:07.276 A:middle
to take away some tips and
techniques from those demos.

19
00:01:07.876 --> 00:01:09.346 A:middle
And, finally, what
session is complete

20
00:01:09.346 --> 00:01:11.416 A:middle
without covering
DTrace, and so we'll talk

21
00:01:11.416 --> 00:01:15.316 A:middle
about some new DTrace
improvements in OS X Yosemite.

22
00:01:16.916 --> 00:01:19.866 A:middle
So to get started what is
new in Instruments this year?

23
00:01:21.126 --> 00:01:23.556 A:middle
Well, we've got two
major themes,

24
00:01:24.226 --> 00:01:28.026 A:middle
and the first theme is a new UI,

25
00:01:28.846 --> 00:01:31.726 A:middle
and so you'll notice it
looks quite a bit different

26
00:01:31.956 --> 00:01:36.336 A:middle
than before, but this is
to match the style of Xcode

27
00:01:36.336 --> 00:01:40.526 A:middle
and OS X Yosemite, and we think
that you'll really like it.

28
00:01:40.526 --> 00:01:43.796 A:middle
At the top I'd like to
point out the toolbar.

29
00:01:43.796 --> 00:01:47.966 A:middle
Of particular note is the path
control there, it allows you

30
00:01:47.966 --> 00:01:51.196 A:middle
to quickly select both
target device and process

31
00:01:51.196 --> 00:01:53.676 A:middle
in one gesture, which we
think will really speed

32
00:01:53.676 --> 00:01:54.956 A:middle
up some of your workflows.

33
00:01:55.356 --> 00:02:01.756 A:middle
And on the right we've got
a centralized place for all

34
00:02:01.756 --> 00:02:03.186 A:middle
of your configuration options,

35
00:02:03.276 --> 00:02:05.486 A:middle
so whether this is recording
options before you run,

36
00:02:06.106 --> 00:02:09.765 A:middle
viewing options, or an
extended detail, stack traces.

37
00:02:10.145 --> 00:02:12.586 A:middle
There's one place now to go and
that's called the Inspector.

38
00:02:13.726 --> 00:02:17.336 A:middle
Now the reason we did this
is mainly for your content,

39
00:02:17.796 --> 00:02:21.596 A:middle
and we all spend a lot of
time looking at statistics

40
00:02:21.596 --> 00:02:23.926 A:middle
and call trees and
having more real estate,

41
00:02:23.926 --> 00:02:26.426 A:middle
more space to clearly dive

42
00:02:26.426 --> 00:02:29.846 A:middle
into your problem is
really what we did this for.

43
00:02:31.116 --> 00:02:32.626 A:middle
So that's the first theme.

44
00:02:32.666 --> 00:02:33.456 A:middle
What's the second theme?

45
00:02:34.316 --> 00:02:35.326 A:middle
Well, as you may have noticed,

46
00:02:36.696 --> 00:02:38.466 A:middle
Swift is a pretty
big deal this year,

47
00:02:38.466 --> 00:02:41.086 A:middle
and we're really excited
about what it offers.

48
00:02:41.626 --> 00:02:44.456 A:middle
But as you go out and adopt
Swift in your application,

49
00:02:45.006 --> 00:02:48.206 A:middle
whether it's by adding
a new Swift class

50
00:02:48.206 --> 00:02:52.576 A:middle
or even converting some of your
current code to Swift we want

51
00:02:52.576 --> 00:02:54.526 A:middle
to make sure that you
have the confidence

52
00:02:55.046 --> 00:02:57.756 A:middle
because you can measure and
you can understand what's going

53
00:02:57.756 --> 00:02:59.026 A:middle
on with the technology.

54
00:02:59.366 --> 00:03:02.576 A:middle
And so Instruments has support
for Swift, and this will run

55
00:03:02.576 --> 00:03:06.086 A:middle
across all of our demos today,
so we'll be using both hybrid

56
00:03:06.136 --> 00:03:07.496 A:middle
and pure Swift apps for those.

57
00:03:08.126 --> 00:03:10.076 A:middle
Now there's a host of other
features and Instruments,

58
00:03:10.196 --> 00:03:13.116 A:middle
some of which we'll get
to today in the demos,

59
00:03:13.246 --> 00:03:16.886 A:middle
like simulators behaving as
devices and Instruments now,

60
00:03:17.256 --> 00:03:19.596 A:middle
some counters improvements
and the like,

61
00:03:19.986 --> 00:03:24.876 A:middle
but those are the two sort of
high level things that are new.

62
00:03:26.416 --> 00:03:30.496 A:middle
So let's dive in and talk
about the first problem

63
00:03:30.496 --> 00:03:32.496 A:middle
that you may face when
developing your application,

64
00:03:32.816 --> 00:03:34.176 A:middle
and that's memory usage.

65
00:03:34.706 --> 00:03:37.736 A:middle
So how can you reduce the
memory usage of your app?

66
00:03:38.016 --> 00:03:40.946 A:middle
Well, what we're talking about
here is persistent memory usage,

67
00:03:41.416 --> 00:03:44.606 A:middle
so that helps narrow it down a
little bit, but we also needed

68
00:03:44.606 --> 00:03:47.046 A:middle
to find out like what
is your app using?

69
00:03:47.616 --> 00:03:49.986 A:middle
And for doing that, we
can think of the memory

70
00:03:50.246 --> 00:03:53.096 A:middle
in your application
as sort of an iceberg,

71
00:03:53.436 --> 00:03:56.266 A:middle
you've got the heap memory
on top, which you know

72
00:03:56.266 --> 00:03:58.856 A:middle
about because these are the
objects you interact withview

73
00:03:58.856 --> 00:04:02.766 A:middle
controllers, NSImages,
managed object context,

74
00:04:03.246 --> 00:04:06.316 A:middle
these are the objects that your
code directly interact with.

75
00:04:07.016 --> 00:04:08.686 A:middle
And then under the surface
there's everything else,

76
00:04:08.836 --> 00:04:11.566 A:middle
there's the layer memory
backing those images

77
00:04:11.946 --> 00:04:15.516 A:middle
or your managed object context,

78
00:04:15.676 --> 00:04:18.486 A:middle
there's a lot of
objects, as well.

79
00:04:18.716 --> 00:04:23.376 A:middle
And so if you've managed the
memory sort of on the surface

80
00:04:23.696 --> 00:04:25.806 A:middle
and you manage it well, it turns

81
00:04:25.806 --> 00:04:28.586 A:middle
out that you actually do a
pretty good job managing the

82
00:04:28.586 --> 00:04:30.506 A:middle
whole usage of your application.

83
00:04:31.276 --> 00:04:34.576 A:middle
So how do we manage those
objects that we deal with?

84
00:04:35.386 --> 00:04:39.456 A:middle
Well, for that there's
an ownership model.

85
00:04:39.456 --> 00:04:43.516 A:middle
And Objective-C's Ownership
Model is pretty straightforward.

86
00:04:43.566 --> 00:04:46.236 A:middle
It's a reference guide model
based on retain and release,

87
00:04:46.526 --> 00:04:50.246 A:middle
and when the object drops
to zero the object is freed.

88
00:04:50.706 --> 00:04:55.336 A:middle
These rules are well-known,
the rules are documented,

89
00:04:55.786 --> 00:04:59.146 A:middle
and the key point here is
that it's deterministic,

90
00:04:59.506 --> 00:05:01.966 A:middle
simple and pretty fast.

91
00:05:01.966 --> 00:05:04.306 A:middle
So what about ARC?

92
00:05:04.706 --> 00:05:06.306 A:middle
Well, this makes
it so much easier

93
00:05:06.306 --> 00:05:08.606 A:middle
because it manages the
retain/release for us.

94
00:05:08.856 --> 00:05:11.196 A:middle
And so it transforms
that problem from dealing

95
00:05:11.196 --> 00:05:15.266 A:middle
with retains and releases to
dealing with your object graph

96
00:05:15.326 --> 00:05:19.316 A:middle
and managing relationships
at a semantic level.

97
00:05:20.446 --> 00:05:21.306 A:middle
So what about Swift?

98
00:05:21.706 --> 00:05:25.496 A:middle
Well, Swift's Object
Model, understandably,

99
00:05:25.856 --> 00:05:29.906 A:middle
is a lot like Objective-C's,
although I should point

100
00:05:29.906 --> 00:05:33.396 A:middle
out that there are a
couple of differences,

101
00:05:33.816 --> 00:05:39.136 A:middle
namely that the retains and
releases are inserted for you

102
00:05:39.666 --> 00:05:43.136 A:middle
and there's really no
need to worry about them.

103
00:05:43.366 --> 00:05:44.946 A:middle
If you're working with
Objective-C, though,

104
00:05:45.066 --> 00:05:48.106 A:middle
you do still have to manage
autoreleasepools and for

105
00:05:48.106 --> 00:05:50.036 A:middle
that there's a nice
standard library function,

106
00:05:50.356 --> 00:05:52.756 A:middle
which accepts a closure,
and it's really easy to use.

107
00:05:53.226 --> 00:05:55.006 A:middle
And so just make sure

108
00:05:55.006 --> 00:05:58.036 A:middle
that you're inserting
autoreleasepools as makes sense

109
00:05:58.256 --> 00:06:00.276 A:middle
with the objective C
code that you're using.

110
00:06:02.296 --> 00:06:05.296 A:middle
So if these are the ownership
models what tools do we have

111
00:06:05.296 --> 00:06:05.936 A:middle
available to us?

112
00:06:06.996 --> 00:06:08.486 A:middle
Well, one of the heavy lifters

113
00:06:08.486 --> 00:06:10.346 A:middle
that we have is the
Allocations Instrument,

114
00:06:10.976 --> 00:06:15.166 A:middle
and this provides back traces
and information for all

115
00:06:15.166 --> 00:06:17.796 A:middle
of your heap allocations,
so it gives you things

116
00:06:17.796 --> 00:06:20.156 A:middle
like class names,
like NSMutableArray.

117
00:06:20.476 --> 00:06:23.746 A:middle
If you're dealing with Swift
objects, it's important to note

118
00:06:23.866 --> 00:06:28.736 A:middle
that your Swift objects will
be prefixed with a module

119
00:06:29.026 --> 00:06:30.706 A:middle
that they are contained in.

120
00:06:31.136 --> 00:06:33.956 A:middle
And so for your application this
may be just your app's name.

121
00:06:35.136 --> 00:06:40.506 A:middle
But for Swift objects, the heap
only will contain your reference

122
00:06:40.616 --> 00:06:44.946 A:middle
types, and so if you're thinking
about this at a code level,

123
00:06:44.946 --> 00:06:46.396 A:middle
these are your classes,
not your structs.

124
00:06:47.176 --> 00:06:51.436 A:middle
But once you identify
these allocations,

125
00:06:51.716 --> 00:06:54.716 A:middle
the allocations will provide
you the reference histories

126
00:06:54.716 --> 00:06:56.196 A:middle
for them, so retains, releases,

127
00:06:56.196 --> 00:06:57.686 A:middle
and even allows you
to pair these.

128
00:06:58.736 --> 00:07:00.616 A:middle
It also provides a
lot of information

129
00:07:00.616 --> 00:07:03.916 A:middle
for anonymous VM usage and
so you can use a Call Tree

130
00:07:03.916 --> 00:07:06.596 A:middle
and track it back to the source.

131
00:07:07.136 --> 00:07:11.706 A:middle
So I would actually like to show
you a demo of using allocations

132
00:07:12.136 --> 00:07:14.056 A:middle
and profiling and app extension.

133
00:07:14.726 --> 00:07:17.616 A:middle
So I have here a
simulator of an iPhone 4S,

134
00:07:17.616 --> 00:07:20.356 A:middle
and I'll launch Instruments,
and you'll immediately notice

135
00:07:20.506 --> 00:07:22.526 A:middle
that we have a new
template chooser.

136
00:07:22.826 --> 00:07:25.146 A:middle
And the template chooser
allows you to select

137
00:07:25.286 --> 00:07:29.746 A:middle
at the top your device or
even manage some devices.

138
00:07:29.786 --> 00:07:33.106 A:middle
For simulators we can
go ahead and choose

139
00:07:33.106 --> 00:07:35.866 A:middle
to launch a different
simulator, and allowing you

140
00:07:35.866 --> 00:07:37.336 A:middle
to choose the target
that you want

141
00:07:37.336 --> 00:07:41.696 A:middle
to profile before even selecting
your template matches the

142
00:07:41.696 --> 00:07:44.006 A:middle
workflow from Xcode
a lot better.

143
00:07:44.416 --> 00:07:46.826 A:middle
And so if you're used to
choosing what you want

144
00:07:46.826 --> 00:07:49.376 A:middle
to profile and then the
tool you can do that

145
00:07:49.376 --> 00:07:52.716 A:middle
or you can just go ahead and
select it as always the tool

146
00:07:52.716 --> 00:07:55.286 A:middle
and configure it first.

147
00:07:55.446 --> 00:07:57.956 A:middle
So I've selected
the Leaks Template,

148
00:07:58.016 --> 00:07:59.256 A:middle
which has 2 instruments,

149
00:07:59.506 --> 00:08:00.866 A:middle
the Allocations and
Leaks Instrument.

150
00:08:01.236 --> 00:08:06.086 A:middle
And for this demo I'll pull
up the list of apps installed

151
00:08:06.086 --> 00:08:08.126 A:middle
on my simulator, and you'll
notice it behaves just

152
00:08:08.126 --> 00:08:08.546 A:middle
like a device.

153
00:08:08.546 --> 00:08:10.626 A:middle
It gives me installed
apps, and now,

154
00:08:11.006 --> 00:08:13.536 A:middle
new in iOS 8 it gives me
app extensions, as well.

155
00:08:14.466 --> 00:08:16.476 A:middle
If I select, say, a
sharing extension,

156
00:08:17.416 --> 00:08:21.136 A:middle
the popup will also let me
select what app it's hosted in.

157
00:08:21.596 --> 00:08:25.786 A:middle
And since app extensions are
accessible to multiple apps

158
00:08:25.786 --> 00:08:31.606 A:middle
in the system, even system
apps can have behavior provided

159
00:08:31.606 --> 00:08:36.326 A:middle
by your extension, you may
want to select a process other

160
00:08:36.326 --> 00:08:38.956 A:middle
than your main app executable

161
00:08:38.956 --> 00:08:41.275 A:middle
when you're profiling
your sharing extension.

162
00:08:42.336 --> 00:08:43.905 A:middle
Now for this demo
I'm actually going

163
00:08:43.905 --> 00:08:45.056 A:middle
to select a today extension,

164
00:08:46.086 --> 00:08:49.716 A:middle
and since we know what
view it's going to appear

165
00:08:49.866 --> 00:08:53.096 A:middle
in there's actually no need
to select a hosting app.

166
00:08:53.516 --> 00:08:55.896 A:middle
So I've actually launched
my app in the simulator,

167
00:08:56.296 --> 00:08:59.146 A:middle
and it's an app extension
bringing in today view.

168
00:08:59.396 --> 00:09:04.576 A:middle
And what I have is an extension
that allows me quick access

169
00:09:04.646 --> 00:09:08.596 A:middle
to my game, and so maybe I'm
playing a move very slowly,

170
00:09:08.596 --> 00:09:10.656 A:middle
I'll play a move every other
day, and I just want to pull it

171
00:09:10.656 --> 00:09:13.286 A:middle
down and make a quick
move, but it's a way

172
00:09:13.286 --> 00:09:16.346 A:middle
of me guessing what
the pattern is,

173
00:09:16.486 --> 00:09:19.486 A:middle
it tells me how many I get
right, how many I get misplaced

174
00:09:19.486 --> 00:09:21.556 A:middle
or wrong, make a couple
of random guesses.

175
00:09:21.686 --> 00:09:24.546 A:middle
You'll notice the memory
usage and Instruments is going

176
00:09:24.596 --> 00:09:28.296 A:middle
up slightly, but what I'm
really interested in is finding

177
00:09:28.296 --> 00:09:31.336 A:middle
out how I'm doing cleaning up
memory when I create a new game.

178
00:09:31.746 --> 00:09:37.446 A:middle
And so I can just create a
few games here at the end,

179
00:09:37.446 --> 00:09:41.146 A:middle
and in Instruments you'll notice
we detect quite a few leaks.

180
00:09:42.266 --> 00:09:47.236 A:middle
Let's take a look at that.

181
00:09:47.956 --> 00:09:52.156 A:middle
So, first of all, in
Allocations it's showing me all

182
00:09:52.156 --> 00:09:55.926 A:middle
of the categories that I've
recorded, things like CFString,

183
00:09:56.406 --> 00:09:59.146 A:middle
and I can type in
for my example, dot,

184
00:10:00.486 --> 00:10:01.986 A:middle
and we see four different
categories.

185
00:10:02.536 --> 00:10:05.196 A:middle
We see the colored button

186
00:10:05.516 --> 00:10:09.376 A:middle
and the DotsTodayViewController
are prefixed by my module

187
00:10:09.806 --> 00:10:10.936 A:middle
because these are Swift classes,

188
00:10:11.616 --> 00:10:14.046 A:middle
and the other two
are Objective-C,

189
00:10:14.096 --> 00:10:14.976 A:middle
so they're running
together, working fine.

190
00:10:15.656 --> 00:10:21.766 A:middle
If I select one of these
Swift classes and dive

191
00:10:21.766 --> 00:10:23.746 A:middle
in even more I can even see
the retain/release history,

192
00:10:24.746 --> 00:10:28.136 A:middle
paired or not, and if I go back

193
00:10:28.456 --> 00:10:31.786 A:middle
to the summary I'll
quickly notice

194
00:10:31.856 --> 00:10:34.216 A:middle
that the persistent number,
which is the one I want to check

195
00:10:34.216 --> 00:10:39.196 A:middle
if I'm looking for memory
growth, is, well, 100%.

196
00:10:39.936 --> 00:10:41.866 A:middle
Now this is where
your expectations

197
00:10:41.866 --> 00:10:43.116 A:middle
as a developer come into play.

198
00:10:43.466 --> 00:10:48.706 A:middle
I expected my colored buttons
to be reused, so there's a few

199
00:10:48.706 --> 00:10:50.356 A:middle
of them persistent, a
few of them transient.

200
00:10:50.956 --> 00:10:53.936 A:middle
But my games, I expected there
only to be on active at a time.

201
00:10:54.006 --> 00:10:58.276 A:middle
So this I've immediately
identified a bug and I should go

202
00:10:58.276 --> 00:11:00.416 A:middle
at this point and fix it.

203
00:11:00.686 --> 00:11:02.776 A:middle
Now there's a couple other
ways to find memory growth.

204
00:11:02.856 --> 00:11:04.636 A:middle
I'm going to show you two more.

205
00:11:05.566 --> 00:11:06.876 A:middle
First, we've got leaks,

206
00:11:07.576 --> 00:11:10.066 A:middle
and leaks will tell
me all the memory

207
00:11:10.066 --> 00:11:11.386 A:middle
that it could find
was unreferenced.

208
00:11:11.896 --> 00:11:13.596 A:middle
This is a type of
persistent memory growth,

209
00:11:13.596 --> 00:11:16.896 A:middle
and so we've got malloc
blocks, a couple of colors,

210
00:11:17.026 --> 00:11:18.666 A:middle
and those games again.

211
00:11:19.286 --> 00:11:22.546 A:middle
And when it comes to
persistent memory growth,

212
00:11:22.646 --> 00:11:23.596 A:middle
there's really three types.

213
00:11:23.596 --> 00:11:26.136 A:middle
There's leaked memory,
there's abandoned memory,

214
00:11:26.136 --> 00:11:27.206 A:middle
and there's cached memory.

215
00:11:28.086 --> 00:11:30.686 A:middle
Leaks will tell us the first
of those three, but if I want

216
00:11:30.686 --> 00:11:33.886 A:middle
to investigate all three I
can use a technique called

217
00:11:33.886 --> 00:11:35.036 A:middle
generational analysis.

218
00:11:35.926 --> 00:11:39.826 A:middle
Now normally you'd used this
Marked Generation button while

219
00:11:39.826 --> 00:11:44.436 A:middle
you're running and set down some
flags for you to then later know

220
00:11:44.436 --> 00:11:45.806 A:middle
when you were doing
certain actions,

221
00:11:46.536 --> 00:11:48.526 A:middle
but in this case I actually
know when I did them

222
00:11:48.626 --> 00:11:50.416 A:middle
and I can add them
after the fact,

223
00:11:50.736 --> 00:11:52.096 A:middle
which is a really
powerful technique.

224
00:11:53.336 --> 00:11:56.356 A:middle
So if I select Marked
Generation, it creates sort

225
00:11:56.356 --> 00:12:00.066 A:middle
of a baseline snapshot, and what
this is doing is categorizing

226
00:12:00.156 --> 00:12:02.366 A:middle
all the persistent
memory in my application

227
00:12:02.636 --> 00:12:04.486 A:middle
by where it came
from on the timeline.

228
00:12:04.886 --> 00:12:08.186 A:middle
So anything before this flag
is grouped into generation one,

229
00:12:08.746 --> 00:12:10.376 A:middle
anything between flag one

230
00:12:10.376 --> 00:12:13.866 A:middle
and flag two is generation
I guess B, as it's labeled,

231
00:12:13.926 --> 00:12:15.526 A:middle
and I can keep marking these.

232
00:12:15.976 --> 00:12:19.446 A:middle
I can even actually choose
to move them around just

233
00:12:19.446 --> 00:12:22.696 A:middle
by dragging them, and it
updates the generation

234
00:12:22.696 --> 00:12:23.786 A:middle
information immediately.

235
00:12:24.406 --> 00:12:30.426 A:middle
So if I turn down generation B
here, you'll notice that, oh,

236
00:12:30.426 --> 00:12:31.886 A:middle
well, we have those
dots games again,

237
00:12:32.586 --> 00:12:36.966 A:middle
and we also have an equal
number of NSMallocBlocks.

238
00:12:37.606 --> 00:12:38.846 A:middle
Well, that's kind
of interesting,

239
00:12:38.976 --> 00:12:40.076 A:middle
I wonder where these
are coming from.

240
00:12:40.806 --> 00:12:45.356 A:middle
Perhaps we've got a retain
cycle involving a block.

241
00:12:45.636 --> 00:12:49.966 A:middle
So on the right in the
inspector area, I take a look

242
00:12:49.966 --> 00:12:53.136 A:middle
at the stack trace,
and I'll notice

243
00:12:53.676 --> 00:12:57.876 A:middle
that here we have a Swift
frame calling new game,

244
00:12:58.356 --> 00:13:01.226 A:middle
an action on my view controller.

245
00:13:01.716 --> 00:13:02.916 A:middle
Let's take a look
at that real quick.

246
00:13:02.916 --> 00:13:08.666 A:middle
If I jump to Xcode, here's
my new game function,

247
00:13:09.536 --> 00:13:15.896 A:middle
and it's just creating a dots
game, assigning it to my library

248
00:13:16.536 --> 00:13:20.866 A:middle
and then it's registering for
state changes on that game

249
00:13:21.386 --> 00:13:23.636 A:middle
and passing in what
looks like a block.

250
00:13:23.876 --> 00:13:25.516 A:middle
Well, this is actually
a Swift closure.

251
00:13:26.136 --> 00:13:28.556 A:middle
We can take a look at the
header, and we see here

252
00:13:28.556 --> 00:13:30.656 A:middle
that registerForStateChanges
takes a dispatch block,

253
00:13:31.366 --> 00:13:36.006 A:middle
and here when we're providing
it we just give a very

254
00:13:36.006 --> 00:13:37.076 A:middle
natural syntax.

255
00:13:38.206 --> 00:13:41.826 A:middle
Well, if you're familiar
with blocks

256
00:13:41.826 --> 00:13:46.666 A:middle
and retain cycles it's very
easy to capture the game

257
00:13:47.396 --> 00:13:49.056 A:middle
in the block registered
on that game.

258
00:13:49.426 --> 00:13:51.816 A:middle
And so what we really need to
do here is actually declare

259
00:13:52.326 --> 00:13:55.726 A:middle
that we would like to
capture new game and, well,

260
00:13:55.926 --> 00:13:58.576 A:middle
it's probably safe to capture
self weakly as well here.

261
00:13:59.576 --> 00:14:04.326 A:middle
Now Swift offers a really
good technique for doing this,

262
00:14:04.326 --> 00:14:05.526 A:middle
and that's Captureless.

263
00:14:06.356 --> 00:14:08.916 A:middle
So we can just say that we
would like to capture self

264
00:14:08.916 --> 00:14:12.546 A:middle
and new game weakly
in this block.

265
00:14:14.216 --> 00:14:16.076 A:middle
Now we get a compile
error real quick,

266
00:14:16.076 --> 00:14:18.416 A:middle
and that's because when we
declare something weak it gets

267
00:14:18.516 --> 00:14:20.086 A:middle
implicitly converted
to optional.

268
00:14:20.666 --> 00:14:23.266 A:middle
Well, that's fine, if self
is nil, we really don't care

269
00:14:23.266 --> 00:14:24.876 A:middle
to call that method,
so we'll go ahead

270
00:14:24.876 --> 00:14:29.616 A:middle
and add some optional chaining,
and there we go, we're done.

271
00:14:30.926 --> 00:14:34.516 A:middle
So, as I showed you,
Instruments now supports app

272
00:14:34.516 --> 00:14:35.456 A:middle
extension profiling.

273
00:14:36.176 --> 00:14:38.476 A:middle
You can specify your host
app either in the menu,

274
00:14:38.886 --> 00:14:42.466 A:middle
in Instruments or in
your scheme, in Xcode.

275
00:14:43.536 --> 00:14:46.926 A:middle
And app extensions, while
they are transient processes,

276
00:14:47.236 --> 00:14:51.546 A:middle
memory does matter
because if they crash,

277
00:14:51.546 --> 00:14:54.826 A:middle
if they flicker it's a very
bad experience for your users

278
00:14:54.826 --> 00:14:56.726 A:middle
and you want to make sure
that when they're running

279
00:14:56.726 --> 00:14:59.146 A:middle
in other people's applications,
when we're running on a system

280
00:14:59.446 --> 00:15:01.356 A:middle
that you get the best
user experience possible.

281
00:15:02.046 --> 00:15:04.986 A:middle
Now I'd like to direct
you to two other sessions,

282
00:15:04.986 --> 00:15:06.016 A:middle
if you're interested
in learning more

283
00:15:06.016 --> 00:15:10.136 A:middle
about app extensions
on iOS and OS X.

284
00:15:10.136 --> 00:15:13.206 A:middle
So let's talk briefly about
memory management with Swift.

285
00:15:14.126 --> 00:15:17.156 A:middle
Objective-C code can still
mismatch retain/release,

286
00:15:17.626 --> 00:15:22.706 A:middle
especially if it's a code
that you've handwritten

287
00:15:22.706 --> 00:15:24.716 A:middle
and you haven't converted
to ARC.

288
00:15:25.236 --> 00:15:28.656 A:middle
So when you're using Swift
objects and passing them

289
00:15:28.656 --> 00:15:30.786 A:middle
to Objective-C code you may need

290
00:15:30.816 --> 00:15:32.396 A:middle
to do some retain/release
pairing

291
00:15:32.576 --> 00:15:33.866 A:middle
and track down those problems.

292
00:15:34.696 --> 00:15:36.426 A:middle
Also, more important, is

293
00:15:36.426 --> 00:15:38.016 A:middle
that you can still
form cycles in Swift.

294
00:15:38.916 --> 00:15:43.626 A:middle
Luckily there's two great tools,
language tools available to us

295
00:15:44.086 --> 00:15:48.866 A:middle
to manage that graph and not
have toand break these cycles.

296
00:15:48.936 --> 00:15:50.436 A:middle
So the first of them is weak,

297
00:15:50.996 --> 00:15:54.606 A:middle
and this actually
converts your type,

298
00:15:55.666 --> 00:15:57.436 A:middle
it requires that you
use an optional type

299
00:15:57.866 --> 00:16:00.796 A:middle
because what it does is it
returns the type of nil,

300
00:16:01.046 --> 00:16:02.506 A:middle
depending on whether the object

301
00:16:02.656 --> 00:16:04.636 A:middle
that it references
is still alive

302
00:16:04.736 --> 00:16:06.856 A:middle
at the time you attempt
to use the variable.

303
00:16:08.506 --> 00:16:11.576 A:middle
Now for unowned you may think
this is a lot like unsafe,

304
00:16:11.576 --> 00:16:16.816 A:middle
unretained and ARC, and it's
actually safer than that.

305
00:16:16.816 --> 00:16:19.596 A:middle
What it does is it
returns the type always,

306
00:16:19.966 --> 00:16:23.866 A:middle
but if the object doesn't
exist you don't get an unknown

307
00:16:23.866 --> 00:16:27.576 A:middle
selector bug or an
indeterminate crash later.

308
00:16:27.836 --> 00:16:29.866 A:middle
It actually validates if
the object is still there

309
00:16:29.866 --> 00:16:31.616 A:middle
and then gives you a
deterministic crash,

310
00:16:32.076 --> 00:16:36.256 A:middle
so some very powerful
tools at your disposal

311
00:16:36.256 --> 00:16:37.046 A:middle
when dealing with Swift.

312
00:16:37.606 --> 00:16:39.986 A:middle
And, as I showed in the demo,

313
00:16:40.486 --> 00:16:42.886 A:middle
with block captures this
is a really easy way

314
00:16:42.886 --> 00:16:44.296 A:middle
of creating retain cycles

315
00:16:44.386 --> 00:16:46.496 A:middle
and something you
should be aware of.

316
00:16:46.936 --> 00:16:49.096 A:middle
In Objective-C, if I
reference self, like this,

317
00:16:49.666 --> 00:16:52.796 A:middle
it's going to capture it
strongly, as well as new game,

318
00:16:52.916 --> 00:16:59.366 A:middle
and I would have to use these
weak type of declarations

319
00:16:59.796 --> 00:17:01.806 A:middle
and then use them
inside the block.

320
00:17:03.926 --> 00:17:06.376 A:middle
In Swift, like I
showed you, it's very,

321
00:17:06.376 --> 00:17:11.646 A:middle
very easy using capture lists to
quickly change the memory type

322
00:17:12.516 --> 00:17:15.185 A:middle
of your variables
within the closure,

323
00:17:15.526 --> 00:17:17.695 A:middle
and so just by declaring
the weak

324
00:17:17.695 --> 00:17:21.366 A:middle
and the capture list we can
use them and no problems.

325
00:17:21.816 --> 00:17:23.935 A:middle
And Swift is also really
powerful here in that

326
00:17:24.086 --> 00:17:28.076 A:middle
if you reference a property
it will force you to declare

327
00:17:28.076 --> 00:17:31.336 A:middle
that you really do
intend to capture self

328
00:17:31.336 --> 00:17:32.936 A:middle
by using self.property.

329
00:17:33.996 --> 00:17:36.436 A:middle
To learn more about Swift we've
got a lot of sessions this week,

330
00:17:36.986 --> 00:17:40.006 A:middle
"Swift Interoperability
In-Depth", "Advanced Swift",

331
00:17:40.136 --> 00:17:43.386 A:middle
and if you want to learn more
about the generational analysis

332
00:17:43.766 --> 00:17:45.486 A:middle
that I did during the
demo I'd refer you back

333
00:17:45.596 --> 00:17:47.856 A:middle
to last year's talk on
"Fixing Memory Issues".

334
00:17:48.936 --> 00:17:51.776 A:middle
So, with that, I'd like to
turn it over to my colleague,

335
00:17:52.066 --> 00:17:54.506 A:middle
Kris Markel, for telling
you about Time Profiling.

336
00:17:55.676 --> 00:17:59.196 A:middle
&gt;&gt; Time Profiler at a high level
is a tool within Instruments

337
00:17:59.326 --> 00:18:01.336 A:middle
that helps you make
your apps faster.

338
00:18:01.926 --> 00:18:03.636 A:middle
The real question, being faster,

339
00:18:03.636 --> 00:18:05.976 A:middle
in and of itself probably
isn't your real goal.

340
00:18:05.976 --> 00:18:08.766 A:middle
Why is it that you actually
want to use Time Profiler?

341
00:18:08.766 --> 00:18:11.936 A:middle
And the answer, I think,
in a lot of cases is

342
00:18:12.326 --> 00:18:14.526 A:middle
to provide a great
user experience.

343
00:18:14.756 --> 00:18:15.986 A:middle
And what does that mean?

344
00:18:16.246 --> 00:18:18.426 A:middle
That means you have
faster app launch times.

345
00:18:19.476 --> 00:18:22.126 A:middle
If it's important that
your frame rate stay

346
00:18:22.126 --> 00:18:24.536 A:middle
at 60 frames per second,
Time Profiler is a tool

347
00:18:24.536 --> 00:18:25.476 A:middle
that can help you do that.

348
00:18:26.456 --> 00:18:31.166 A:middle
Buttery-smooth scrolling,
Time Profiler is great

349
00:18:31.166 --> 00:18:32.856 A:middle
at finding hiccups
in your scrolling

350
00:18:32.856 --> 00:18:34.996 A:middle
and helping you get
past those problems.

351
00:18:36.256 --> 00:18:39.106 A:middle
And kind of a more
general category,

352
00:18:39.106 --> 00:18:40.996 A:middle
you want to have
a responsive UI.

353
00:18:41.276 --> 00:18:43.126 A:middle
If the user does
something in the app,

354
00:18:43.646 --> 00:18:49.126 A:middle
they need to see the app
respond as quickly as possible.

355
00:18:49.126 --> 00:18:51.766 A:middle
You don't want them to click a
button and then wait and wait

356
00:18:51.766 --> 00:18:53.006 A:middle
and wait for something
to happen.

357
00:18:53.956 --> 00:18:56.406 A:middle
So what exactly is
Time Profiler?

358
00:18:57.166 --> 00:19:00.576 A:middle
Time Profiler is an instrument
that samples stack traces

359
00:19:00.576 --> 00:19:04.836 A:middle
at pre-described intervals, and
its goal is to give you an idea

360
00:19:04.836 --> 00:19:06.826 A:middle
of how much time is
spent in each method.

361
00:19:07.816 --> 00:19:09.256 A:middle
There's an important
distinction here

362
00:19:09.256 --> 00:19:12.056 A:middle
in that Time Profiler
is not actually tracing

363
00:19:12.056 --> 00:19:14.366 A:middle
through every method and
function calling your app

364
00:19:14.366 --> 00:19:15.676 A:middle
and measuring how long it takes.

365
00:19:16.276 --> 00:19:18.586 A:middle
It is capturing stack samples

366
00:19:19.096 --> 00:19:22.876 A:middle
and recording how often frames
appear in those samples.

367
00:19:23.186 --> 00:19:25.846 A:middle
Now this can be important if
you have a function or method

368
00:19:25.846 --> 00:19:28.826 A:middle
that doesn't run enough
to show up in any samples

369
00:19:28.826 --> 00:19:30.676 A:middle
or it's too fast to
show up in any samples.

370
00:19:31.066 --> 00:19:34.096 A:middle
This isn't an issue
most of the time,

371
00:19:34.096 --> 00:19:35.266 A:middle
but it's an important
distinction to keep in mind

372
00:19:35.266 --> 00:19:35.976 A:middle
when you're using Time Profiler.

373
00:19:36.046 --> 00:19:40.086 A:middle
When should you use
Time Profiler?

374
00:19:40.456 --> 00:19:42.966 A:middle
Well, there's a couple
different situations.

375
00:19:44.036 --> 00:19:46.606 A:middle
If you have a specific
problem that you know about,

376
00:19:46.776 --> 00:19:49.886 A:middle
Time Profiler is great, you
know, if you have stuttering

377
00:19:49.886 --> 00:19:52.646 A:middle
or frame rate slowdowns,
some portion

378
00:19:52.646 --> 00:19:56.546 A:middle
of your app is taking too long,
parsing a file or something

379
00:19:56.546 --> 00:20:00.216 A:middle
of that nature, but it's also
fine to use Time Profiler

380
00:20:00.216 --> 00:20:03.686 A:middle
to identify and fix hot spots
before they become problems.

381
00:20:04.296 --> 00:20:07.176 A:middle
You don't have to wait until
you have a problem before firing

382
00:20:07.176 --> 00:20:08.686 A:middle
up Instruments and
using Time Profiler.

383
00:20:09.266 --> 00:20:11.676 A:middle
And, actually, it's a
good idea to keep an eye

384
00:20:11.676 --> 00:20:13.916 A:middle
on the CPU gauge
inside of Xcode.

385
00:20:14.316 --> 00:20:17.376 A:middle
If that's spiking in
ways you don't expect

386
00:20:17.376 --> 00:20:19.746 A:middle
or it just seems higher than
you want, that's a little clue,

387
00:20:19.746 --> 00:20:22.056 A:middle
you know, something should go
off in the back of your heads,

388
00:20:22.056 --> 00:20:23.636 A:middle
maybe I should look
at Time Profiler

389
00:20:23.636 --> 00:20:25.096 A:middle
and see exactly what's
going on here.

390
00:20:26.516 --> 00:20:28.336 A:middle
And so now I'm going
to show you a demo

391
00:20:28.336 --> 00:20:31.466 A:middle
of how you can make your app
faster with Time Profiler.

392
00:20:33.026 --> 00:20:36.266 A:middle
And what I have here
is a hybrid app

393
00:20:36.456 --> 00:20:41.666 A:middle
and it's got some Swift files

394
00:20:41.666 --> 00:20:45.026 A:middle
and it's got some Objective-C
files, and I've been working

395
00:20:45.026 --> 00:20:47.596 A:middle
on it for a while, and
I want to get an idea

396
00:20:47.596 --> 00:20:50.426 A:middle
of how well it's running
before, you know, I don't know

397
00:20:50.426 --> 00:20:52.416 A:middle
of any specific problems, but
I want to kind of take a look

398
00:20:52.416 --> 00:20:54.236 A:middle
and see if maybe there's
some hot spots in there.

399
00:20:54.706 --> 00:20:57.176 A:middle
So I'm going to go ahead
and Time Profile this app,

400
00:20:57.526 --> 00:21:01.586 A:middle
and to do that I am going
to press and click and hold

401
00:21:01.586 --> 00:21:04.696 A:middle
on the Run button in
Xcode and choose Profile.

402
00:21:04.696 --> 00:21:07.596 A:middle
And this is going to
launch Instruments

403
00:21:07.676 --> 00:21:08.766 A:middle
into the template chooser,

404
00:21:10.056 --> 00:21:13.586 A:middle
and once it's done building I'll
show you a nifty little trick.

405
00:21:14.006 --> 00:21:16.316 A:middle
And if you're familiar with
Instruments in the past,

406
00:21:16.576 --> 00:21:18.846 A:middle
what would happen here is it
would give you the template

407
00:21:18.846 --> 00:21:22.086 A:middle
chooser, what you see here, and
you would choose, you would go

408
00:21:22.086 --> 00:21:25.246 A:middle
down to the button down
here, and you would click it,

409
00:21:25.246 --> 00:21:28.896 A:middle
and Time Profiler or
whatever-actually, let me choose

410
00:21:28.896 --> 00:21:30.226 A:middle
that now while I'm
thinking about it.

411
00:21:30.226 --> 00:21:33.286 A:middle
Whatever instrument you had
chosen would automatically start

412
00:21:33.286 --> 00:21:34.906 A:middle
running and recording
for your app.

413
00:21:35.316 --> 00:21:39.166 A:middle
With the new Instruments
it gives you a chance

414
00:21:39.166 --> 00:21:41.836 A:middle
to change your configuration
before it starts running.

415
00:21:42.446 --> 00:21:44.656 A:middle
Now if you want the old
behavior it's still there,

416
00:21:44.656 --> 00:21:47.476 A:middle
if you hold down the Option key
you can see the button change

417
00:21:47.476 --> 00:21:50.016 A:middle
to Profile, and that'll
launch your app

418
00:21:50.156 --> 00:21:52.006 A:middle
and start running
it immediately.

419
00:21:52.646 --> 00:21:54.416 A:middle
In my case I don't want to do
that, I'm going to go ahead

420
00:21:54.416 --> 00:21:56.876 A:middle
and go to Choose, and
I'm actually going

421
00:21:56.876 --> 00:21:57.926 A:middle
to make a couple adjustments.

422
00:21:58.196 --> 00:22:03.086 A:middle
And, actually, I'm right here,
this is, you can't quite see all

423
00:22:03.086 --> 00:22:05.446 A:middle
of it, but the two changes I
want to make and why is going

424
00:22:05.446 --> 00:22:07.866 A:middle
to become clear soon
is I want to choose

425
00:22:07.866 --> 00:22:09.496 A:middle
to record waiting threads,

426
00:22:09.946 --> 00:22:13.426 A:middle
and this means don't only
collect samples from the threads

427
00:22:13.426 --> 00:22:15.976 A:middle
that are doing work, but
collect samples from the threads

428
00:22:15.976 --> 00:22:17.206 A:middle
that are idle, as well.

429
00:22:18.596 --> 00:22:19.976 A:middle
I happen to know
that I want to do

430
00:22:19.976 --> 00:22:23.286 A:middle
that because I've
rehearsed this talk before.

431
00:22:23.396 --> 00:22:26.356 A:middle
If you choose that option
another really great option

432
00:22:26.356 --> 00:22:28.266 A:middle
to choose in the
view options is just

433
00:22:28.316 --> 00:22:29.956 A:middle
to select running sample times,

434
00:22:30.686 --> 00:22:33.026 A:middle
and what this means is even
though you're collecting the

435
00:22:33.026 --> 00:22:36.936 A:middle
idle samples, don't use them
when computing time spent

436
00:22:37.636 --> 00:22:40.536 A:middle
because they really sort
of water down the results.

437
00:22:40.536 --> 00:22:41.996 A:middle
You're going to have
a lot of idle time

438
00:22:41.996 --> 00:22:44.596 A:middle
and get some very small
numbers that you don't expect.

439
00:22:45.936 --> 00:22:48.306 A:middle
So, with that, I am
going to zoom out,

440
00:22:48.666 --> 00:22:50.236 A:middle
I'm going to click
the Record button

441
00:22:51.006 --> 00:22:53.796 A:middle
to start my app,
and let's see here.

442
00:22:54.116 --> 00:22:57.386 A:middle
So here's my app, I've got a set
of pictures over on the left,

443
00:22:57.386 --> 00:22:59.456 A:middle
I can select them
and get the thumbnail

444
00:22:59.456 --> 00:23:00.396 A:middle
and then get the big view.

445
00:23:00.396 --> 00:23:02.136 A:middle
And now I'm going to go
ahead and click on my button,

446
00:23:03.196 --> 00:23:06.146 A:middle
and whoa, that's awesome.

447
00:23:06.516 --> 00:23:08.956 A:middle
So let's go through
and use a little more.

448
00:23:08.956 --> 00:23:10.466 A:middle
One thing I notice is

449
00:23:10.466 --> 00:23:13.946 A:middle
that between the time I click
the button there's a little

450
00:23:13.946 --> 00:23:17.786 A:middle
pause before the eyes actually
show up, and I don't like that.

451
00:23:18.046 --> 00:23:21.176 A:middle
My app is supposed to be
eyemazing, if you can read

452
00:23:21.176 --> 00:23:24.056 A:middle
that title bar that's
clear, and having to wait

453
00:23:24.056 --> 00:23:26.766 A:middle
for your googly eyes is not
an eyemazing experience.

454
00:23:27.586 --> 00:23:30.306 A:middle
Well, fortunately, I was
capturing a time profile,

455
00:23:30.306 --> 00:23:32.606 A:middle
let's go ahead and see
what's going on here.

456
00:23:33.446 --> 00:23:38.836 A:middle
So now if we look at the track
view, we now have new gestures

457
00:23:38.986 --> 00:23:40.106 A:middle
for working on the track view.

458
00:23:40.806 --> 00:23:44.046 A:middle
And to select a time profile
all I have to do is click,

459
00:23:44.436 --> 00:23:47.246 A:middle
or to select a time filter all
I have to do is click and drag

460
00:23:47.276 --> 00:23:49.086 A:middle
and that applies
the time filter.

461
00:23:50.176 --> 00:23:56.206 A:middle
So it's much simpler,
hopefully far more intuitive

462
00:23:56.206 --> 00:23:57.686 A:middle
than it was before.

463
00:23:57.686 --> 00:24:00.506 A:middle
And then to actually zoom in you
do the same thing, but you hold

464
00:24:00.506 --> 00:24:03.126 A:middle
down the shift key, so I'll do
that now, and I can zoom in,

465
00:24:03.126 --> 00:24:05.376 A:middle
and then I'll go back out.

466
00:24:07.316 --> 00:24:10.726 A:middle
And so now I can see, if I come
down here I can see that most

467
00:24:10.726 --> 00:24:12.446 A:middle
of time is spent
in the main thread

468
00:24:13.066 --> 00:24:15.986 A:middle
and in the start method
and, oh, you're not here

469
00:24:15.986 --> 00:24:18.626 A:middle
to watch me click
disclosure triangles all day.

470
00:24:19.056 --> 00:24:22.626 A:middle
I'm going to go over and I'm
going to use Command 3 to bring

471
00:24:22.626 --> 00:24:24.146 A:middle
up the extended detail pane,

472
00:24:24.746 --> 00:24:27.356 A:middle
and this over here gives
me my heaviest stack trace.

473
00:24:28.006 --> 00:24:30.306 A:middle
And what I'm looking for
is in this column here.

474
00:24:30.306 --> 00:24:33.176 A:middle
I'm looking for a big
drop in the numbers.

475
00:24:33.946 --> 00:24:37.206 A:middle
And I can see right here
I go from 120 to 180,

476
00:24:37.206 --> 00:24:39.786 A:middle
that kind of gives me an
idea of where my problem is,

477
00:24:40.026 --> 00:24:43.716 A:middle
and when I select it in the
stack trace, it selects it

478
00:24:43.716 --> 00:24:44.866 A:middle
in the Call Tree view.

479
00:24:45.166 --> 00:24:47.316 A:middle
And there's still a
lot of stuff in there,

480
00:24:47.316 --> 00:24:49.306 A:middle
a lot of which I don't
really care about.

481
00:24:50.046 --> 00:24:53.146 A:middle
So I'm going to hit Command
1, well, actually Command 2,

482
00:24:53.146 --> 00:24:55.806 A:middle
and go into my view options,
and one of the ones I'm going

483
00:24:55.806 --> 00:24:58.346 A:middle
to choose over here is
to hide missing symbols.

484
00:24:58.846 --> 00:25:01.096 A:middle
No, I'm going to choose
hide system libraries,

485
00:25:01.686 --> 00:25:04.966 A:middle
and this narrows it
down to just my code.

486
00:25:04.966 --> 00:25:08.106 A:middle
And it's kind of nice, if
you look in here you can see,

487
00:25:08.106 --> 00:25:11.246 A:middle
I'm going to expand
this one more.

488
00:25:11.766 --> 00:25:16.116 A:middle
Oop, you can see here's
an Objective-C call,

489
00:25:17.256 --> 00:25:18.116 A:middle
here's a Swift call.

490
00:25:18.116 --> 00:25:19.456 A:middle
Oh, I got this backwards, right?

491
00:25:19.456 --> 00:25:21.876 A:middle
This is the Objective-C call,

492
00:25:22.176 --> 00:25:23.656 A:middle
this one down here
is the Swift call,

493
00:25:23.656 --> 00:25:26.386 A:middle
and it's at Ob-C is the
bridge between them.

494
00:25:26.386 --> 00:25:29.296 A:middle
And if you're using a
hybrid app you'll see those,

495
00:25:29.466 --> 00:25:31.396 A:middle
and just so you're aware
that they're there,

496
00:25:31.396 --> 00:25:34.206 A:middle
they're not causing
any harm or anything,

497
00:25:34.206 --> 00:25:35.016 A:middle
it's not anything wrong.

498
00:25:35.526 --> 00:25:38.246 A:middle
Another thing I want to do is
I want to invert the Call Tree

499
00:25:38.246 --> 00:25:40.676 A:middle
because this makes it a
little easier to kind of see.

500
00:25:41.146 --> 00:25:44.016 A:middle
Frequently the most
expensive calls

501
00:25:44.016 --> 00:25:47.596 A:middle
in your app are towards the end
of the Call Tree, so that kind

502
00:25:47.596 --> 00:25:48.916 A:middle
of helps you narrow in on that.

503
00:25:48.916 --> 00:25:51.356 A:middle
And another thing that makes
this nice is I can see per

504
00:25:51.356 --> 00:25:57.186 A:middle
thread really quickly what each,
what's the expensive calls.

505
00:25:58.366 --> 00:26:00.936 A:middle
So I'm here, so I'm
spending a lot of time

506
00:26:01.846 --> 00:26:04.146 A:middle
in this method right here, so
I'm going to double click on it,

507
00:26:04.146 --> 00:26:06.926 A:middle
and it brings it up, let me make
this window a little bigger,

508
00:26:06.926 --> 00:26:10.496 A:middle
and I can see my Swift code.

509
00:26:11.846 --> 00:26:13.776 A:middle
Ooh, and it scrolls
really quickly,

510
00:26:14.106 --> 00:26:18.866 A:middle
and thanks to this big red
bar I can see that most

511
00:26:18.866 --> 00:26:22.136 A:middle
of my time is being spent on
this particular line of code.

512
00:26:22.136 --> 00:26:22.916 A:middle
What is this code doing?

513
00:26:22.916 --> 00:26:26.256 A:middle
Well, I'm using the core image
face detection to find faces

514
00:26:26.256 --> 00:26:29.426 A:middle
and then to find eyes on those
faces, and that's where most

515
00:26:29.426 --> 00:26:31.906 A:middle
of my time is being spent.

516
00:26:31.906 --> 00:26:32.776 A:middle
What are my options here?

517
00:26:32.776 --> 00:26:36.776 A:middle
Well, I can either change the
accuracy level of the detection

518
00:26:36.776 --> 00:26:38.426 A:middle
so it doesn't find
faces, as well.

519
00:26:38.426 --> 00:26:40.666 A:middle
I can maybe turn off
the blink detection.

520
00:26:40.666 --> 00:26:42.206 A:middle
Those two things
might make it faster,

521
00:26:42.746 --> 00:26:44.426 A:middle
but I don't think
they would provide

522
00:26:44.526 --> 00:26:47.356 A:middle
as an eyemazing experience

523
00:26:47.926 --> 00:26:52.306 A:middle
as having high fidelity face
detection and getting, you know,

524
00:26:52.306 --> 00:26:54.496 A:middle
the googly eyes need to be
on the closed eyes, as well.

525
00:26:55.466 --> 00:26:58.426 A:middle
I could maybe write
my own face detection

526
00:26:58.426 --> 00:27:01.216 A:middle
and maybe that'll be
faster than what's provided

527
00:27:01.216 --> 00:27:03.036 A:middle
in the kit, probably not.

528
00:27:04.106 --> 00:27:05.016 A:middle
So what are my choices here?

529
00:27:05.016 --> 00:27:09.186 A:middle
Well, I actually notice
using the app that even

530
00:27:09.186 --> 00:27:11.706 A:middle
if I can't make this faster
maybe I can change the way the

531
00:27:11.706 --> 00:27:12.606 A:middle
work is being done.

532
00:27:13.636 --> 00:27:17.576 A:middle
And to do that, I actually
am going to change it so that

533
00:27:17.576 --> 00:27:24.446 A:middle
when you click on the app in
the sidebar, when you click

534
00:27:24.446 --> 00:27:26.526 A:middle
on the thumbnail in the
sidebar, we'll go ahead

535
00:27:26.526 --> 00:27:28.996 A:middle
and build the googly
eye image then,

536
00:27:28.996 --> 00:27:30.396 A:middle
and then by the time you click

537
00:27:30.396 --> 00:27:33.726 A:middle
on the button it'll be
already ready for you.

538
00:27:33.896 --> 00:27:39.276 A:middle
And so I'm going to scroll
down to my didSelect,

539
00:27:39.746 --> 00:27:41.766 A:middle
tableViewSelectionDidChange,
and I happen

540
00:27:41.766 --> 00:27:44.746 A:middle
to already be caching my googly
eye images, but I'm now doing,

541
00:27:44.746 --> 00:27:46.776 A:middle
I'm currently doing it
when you click the button.

542
00:27:46.776 --> 00:27:49.056 A:middle
So I'm just going to add a
little code here to generate

543
00:27:49.056 --> 00:27:54.036 A:middle
that when the selection changes.

544
00:27:54.036 --> 00:27:55.476 A:middle
We're going to just move
the work around here,

545
00:27:55.526 --> 00:27:57.616 A:middle
and I'm actually cheating
a little bit here,

546
00:27:57.616 --> 00:27:58.436 A:middle
I want to point this out.

547
00:27:59.076 --> 00:28:04.306 A:middle
I'm using a mutable dictionary
as my cache, and so instead

548
00:28:04.306 --> 00:28:07.316 A:middle
of having to deal with a mutable
dictionary and multiple threads,

549
00:28:07.526 --> 00:28:10.396 A:middle
I'm actually dispatching
this back to the main thread

550
00:28:10.996 --> 00:28:14.236 A:middle
so that all of my
dictionary access happens

551
00:28:14.236 --> 00:28:14.926 A:middle
on the main thread.

552
00:28:14.926 --> 00:28:17.276 A:middle
I can do this because this
is a fairly simple app,

553
00:28:17.276 --> 00:28:20.036 A:middle
it's not a lot of
threading going on,

554
00:28:20.556 --> 00:28:22.686 A:middle
but if you're doing more
complex stuff you're going

555
00:28:22.686 --> 00:28:26.066 A:middle
to need a more involved
solution, but this works for me.

556
00:28:26.066 --> 00:28:28.786 A:middle
And if we scroll up
to the actual-this is

557
00:28:29.676 --> 00:28:31.546 A:middle
when you click the button,

558
00:28:31.586 --> 00:28:34.796 A:middle
you can see here we basically
get the selected row,

559
00:28:34.796 --> 00:28:37.186 A:middle
we see if the image
is in the cache.

560
00:28:37.486 --> 00:28:39.626 A:middle
If it's not, we go ahead
and build it and put it

561
00:28:39.626 --> 00:28:41.706 A:middle
in the cache, and
then we display it.

562
00:28:42.146 --> 00:28:44.176 A:middle
So let's go ahead and see
if this makes it any better.

563
00:28:44.886 --> 00:28:47.716 A:middle
So click the Profile button,
you can see it profile again.

564
00:28:47.946 --> 00:28:50.386 A:middle
Now if you keep your eye on
the track view you'll see

565
00:28:50.386 --> 00:28:53.606 A:middle
that it still does work and you
can still see the spike, right?

566
00:28:54.216 --> 00:28:55.406 A:middle
But by the time I actually go

567
00:28:55.406 --> 00:28:58.096 A:middle
to click the button the
work is already done,

568
00:28:58.766 --> 00:29:02.086 A:middle
so now there's a little
spike, click the button, oh,

569
00:29:02.846 --> 00:29:06.496 A:middle
scroll down here, try this
one, oh, I love this app,

570
00:29:06.496 --> 00:29:07.746 A:middle
I could do this all day.

571
00:29:07.746 --> 00:29:08.946 A:middle
Oh, wait, what's going on here?

572
00:29:09.646 --> 00:29:10.566 A:middle
Where is my scrolling?

573
00:29:10.676 --> 00:29:11.236 A:middle
What's going on?

574
00:29:11.236 --> 00:29:15.706 A:middle
Oh, it's stuttering, oh,
this is not eyemazing.

575
00:29:16.856 --> 00:29:18.016 A:middle
I need to fix this.

576
00:29:18.016 --> 00:29:19.556 A:middle
Okay, let's see what we can do.

577
00:29:19.706 --> 00:29:21.726 A:middle
This is really terrible.

578
00:29:22.276 --> 00:29:26.016 A:middle
Fortunately, I'm still running
Time Profiler, so I'm going

579
00:29:26.016 --> 00:29:28.516 A:middle
to go ahead and select some of
these little spikes in here,

580
00:29:29.026 --> 00:29:32.236 A:middle
and I apply a time filter
and hold down the Shift key,

581
00:29:32.936 --> 00:29:34.056 A:middle
and go ahead and zoom in.

582
00:29:34.306 --> 00:29:38.536 A:middle
And then if I look, I still
have this invert Call Tree,

583
00:29:38.536 --> 00:29:41.406 A:middle
so if I expand my main
thread I can see its most

584
00:29:41.406 --> 00:29:44.036 A:middle
expensive calls.

585
00:29:44.036 --> 00:29:46.866 A:middle
And right here the thing that's
really hurting us is the scaling

586
00:29:46.866 --> 00:29:49.606 A:middle
the image, that's where
we're building the thumbnail

587
00:29:49.606 --> 00:29:50.516 A:middle
and making it smaller.

588
00:29:50.516 --> 00:29:54.256 A:middle
But the other thing
I happen to know:

589
00:29:55.536 --> 00:30:00.436 A:middle
that I can see the CPU spikes
and there's a few of them,

590
00:30:00.796 --> 00:30:02.976 A:middle
but it doesn't really quite
explain that much stuttering.

591
00:30:02.976 --> 00:30:04.226 A:middle
I would expect the CPU to
be doing a lot more work

592
00:30:04.256 --> 00:30:04.976 A:middle
if I was stuttering like that.

593
00:30:05.046 --> 00:30:10.476 A:middle
So another thing I'm going to go
check is I'm going to go up here

594
00:30:10.476 --> 00:30:14.086 A:middle
in the toolbar to our new
strategy buttons, and I'm going

595
00:30:14.086 --> 00:30:15.516 A:middle
to check out the
thread strategy,

596
00:30:15.516 --> 00:30:16.686 A:middle
which is this button over here.

597
00:30:16.686 --> 00:30:19.746 A:middle
And this is going to show me
what each thread is doing.

598
00:30:19.746 --> 00:30:22.446 A:middle
So now you can see
the whole thing.

599
00:30:23.286 --> 00:30:26.926 A:middle
Each of those little
stopwatches represents a sample

600
00:30:27.046 --> 00:30:28.286 A:middle
that was taken on that thread.

601
00:30:28.856 --> 00:30:31.616 A:middle
The ones that are solid are ones
where the thread was doing work,

602
00:30:31.616 --> 00:30:33.866 A:middle
and the ones that are
translucent are the ones

603
00:30:33.866 --> 00:30:34.556 A:middle
where the thread idle.

604
00:30:34.556 --> 00:30:37.936 A:middle
So if I go ahead and click on
one of these and you can kind

605
00:30:37.936 --> 00:30:41.076 A:middle
of see if you look up at the top
it says idle call stack sample,

606
00:30:41.316 --> 00:30:43.436 A:middle
not running on CPU, so
this is an idle case.

607
00:30:43.846 --> 00:30:46.756 A:middle
And now I want to make one
thing clear here because, again,

608
00:30:46.886 --> 00:30:49.486 A:middle
this demo is well rehearsed,
I know exactly which of these

609
00:30:49.486 --> 00:30:51.006 A:middle
to click on to find my problem.

610
00:30:51.876 --> 00:30:53.486 A:middle
When you're dealing
with your app,

611
00:30:53.486 --> 00:30:55.186 A:middle
there's thousands
of these samples.

612
00:30:55.186 --> 00:30:58.926 A:middle
You're going to have to use some
detective work to really narrow

613
00:30:58.926 --> 00:31:01.186 A:middle
down where in your app
you're seeing the stuttering

614
00:31:01.186 --> 00:31:02.826 A:middle
or you're having the problem,
and you're probably going

615
00:31:02.826 --> 00:31:06.196 A:middle
to have to click through
several of these to find

616
00:31:06.196 --> 00:31:07.156 A:middle
out exactly what's going on.

617
00:31:07.866 --> 00:31:10.146 A:middle
But in my case I can look
through and in each of these,

618
00:31:10.486 --> 00:31:13.286 A:middle
I can see in here, what is this:

619
00:31:13.286 --> 00:31:16.576 A:middle
NSURLConnection
sendSynchronousRequest..Whoa,

620
00:31:16.576 --> 00:31:20.676 A:middle
that's a big red flag;
synchronous request, bad idea.

621
00:31:20.676 --> 00:31:24.576 A:middle
Synchronous request on the main
thread-what the heck is going

622
00:31:24.576 --> 00:31:25.126 A:middle
on here?

623
00:31:25.556 --> 00:31:30.826 A:middle
So let's go back to the app,
I know there's something going

624
00:31:30.826 --> 00:31:34.146 A:middle
on here, and I actually
know associated

625
00:31:34.196 --> 00:31:35.516 A:middle
with building the thumbnail.

626
00:31:35.516 --> 00:31:40.146 A:middle
So I'm going to go into my
photo class, and go to where-oh,

627
00:31:40.146 --> 00:31:42.216 A:middle
there's a little comment
here, what does this say?

628
00:31:42.216 --> 00:31:44.716 A:middle
I read on the internet:
Kris from six months ago.

629
00:31:44.716 --> 00:31:46.506 A:middle
I don't even need to
read this whole thing.

630
00:31:46.506 --> 00:31:50.956 A:middle
That guy is a fool, if
only there was some tool.

631
00:31:50.956 --> 00:31:52.276 A:middle
I'll show you a tool.

632
00:31:52.886 --> 00:31:55.256 A:middle
Okay, I'm just deleting
all this code.

633
00:31:55.326 --> 00:31:58.966 A:middle
We don't need to
use a URL request

634
00:31:58.966 --> 00:32:00.206 A:middle
to load a local resource.

635
00:32:00.826 --> 00:32:05.066 A:middle
I happen to know that-that's
good-bye-that the image we're

636
00:32:05.066 --> 00:32:07.566 A:middle
looking for, that we're looking
to create the thumbnail for,

637
00:32:07.566 --> 00:32:09.436 A:middle
if you look down here
in my initializer,

638
00:32:09.436 --> 00:32:12.956 A:middle
I actually have a property that
already contains that image.

639
00:32:13.766 --> 00:32:15.586 A:middle
So instead of doing
whatever that guy

640
00:32:15.586 --> 00:32:17.806 A:middle
from six months ago was
thinking, I'm just going

641
00:32:17.806 --> 00:32:19.176 A:middle
to use the image
that I already have,

642
00:32:19.766 --> 00:32:22.886 A:middle
and that'll free
up my block thread.

643
00:32:23.116 --> 00:32:25.856 A:middle
Now I also happen to know,
this is a well rehearsed demo,

644
00:32:25.856 --> 00:32:27.706 A:middle
that doesn't quite
solve the problem.

645
00:32:27.706 --> 00:32:31.726 A:middle
It helps a bunch, but there's
still a little stuttering,

646
00:32:31.726 --> 00:32:33.136 A:middle
and to fix that we're
actually going

647
00:32:33.136 --> 00:32:34.336 A:middle
to do another little cheat,

648
00:32:34.336 --> 00:32:35.676 A:middle
we're going to move
some work around.

649
00:32:36.146 --> 00:32:38.826 A:middle
I'm actually going to go and
pre-generate those thumbnails

650
00:32:38.826 --> 00:32:41.906 A:middle
when the app starts, and
I'm going to do that here.

651
00:32:41.906 --> 00:32:47.106 A:middle
This, my Swift class here
has a load photos method,

652
00:32:47.706 --> 00:32:50.666 A:middle
and this just goes and
pulls all the photos

653
00:32:50.666 --> 00:32:53.476 A:middle
out of the bundle
and creates a list.

654
00:32:53.476 --> 00:32:56.276 A:middle
And in here I'm going
to add some code

655
00:32:56.276 --> 00:33:00.356 A:middle
that actually goes through, and
just simply touches each photo,

656
00:33:00.356 --> 00:33:04.156 A:middle
asks for its thumbnail, and that
gets-that causes the generation

657
00:33:04.156 --> 00:33:05.936 A:middle
of the thumbnail, and
that work happens.

658
00:33:06.406 --> 00:33:08.806 A:middle
We're doing this in a
background thread, basically,

659
00:33:08.806 --> 00:33:10.806 A:middle
as soon as you load all the
photos the next thing we do is

660
00:33:10.806 --> 00:33:11.986 A:middle
we go and generate
all the thumbnails.

661
00:33:12.246 --> 00:33:14.476 A:middle
This doesn't actually
technically make my app more

662
00:33:14.476 --> 00:33:16.226 A:middle
efficient, it just
moves the work around,

663
00:33:16.786 --> 00:33:17.876 A:middle
but I think for the user,

664
00:33:17.876 --> 00:33:19.716 A:middle
from the user experience
they won't really know.

665
00:33:19.936 --> 00:33:22.966 A:middle
So now if I go ahead and
profile my app again,

666
00:33:24.276 --> 00:33:25.876 A:middle
we take a look, you can watch.

667
00:33:25.926 --> 00:33:30.976 A:middle
At the beginning of the thread
you can see it doing more work,

668
00:33:31.576 --> 00:33:32.776 A:middle
if you actually use the app.

669
00:33:33.006 --> 00:33:36.476 A:middle
I should have some nice
buttery-smooth scrolling here.

670
00:33:37.176 --> 00:33:40.926 A:middle
Oh, this is a good
one: fun at the park,

671
00:33:41.376 --> 00:33:43.366 A:middle
fun at the park with
googly eyes.

672
00:33:44.146 --> 00:33:46.286 A:middle
So now my app is great,
it's super responsive,

673
00:33:46.286 --> 00:33:50.026 A:middle
buttery-smooth scrolling,
it's just so much better.

674
00:33:50.776 --> 00:33:55.536 A:middle
And that's an example
of Time Profiler.

675
00:33:56.516 --> 00:34:02.356 A:middle
[ Applause ]

676
00:34:02.856 --> 00:34:05.416 A:middle
So to real quickly, or I
don't know, maybe I won't be

677
00:34:05.416 --> 00:34:08.045 A:middle
that quick, we'll see,
review what we've done.

678
00:34:08.636 --> 00:34:11.886 A:middle
We talked about the new track
view, you can identify and zoom

679
00:34:11.886 --> 00:34:13.025 A:middle
in on the problem areas.

680
00:34:13.536 --> 00:34:17.335 A:middle
You drag and select to
apply a time range filter.

681
00:34:17.496 --> 00:34:21.246 A:middle
Shift+drag zooms in, and
control+drag will zoom you out.

682
00:34:22.235 --> 00:34:24.726 A:middle
We also talked about
the new inspector panes.

683
00:34:24.726 --> 00:34:27.485 A:middle
There are some new
keyboard shortcuts,

684
00:34:27.485 --> 00:34:29.315 A:middle
so you can quickly
move between them.

685
00:34:29.536 --> 00:34:31.795 A:middle
If you're familiar
with a certain IDE,

686
00:34:31.795 --> 00:34:34.786 A:middle
this should kind of ring a bell.

687
00:34:34.786 --> 00:34:37.556 A:middle
Command 1 is the
record settings.

688
00:34:37.666 --> 00:34:38.976 A:middle
These are the settings
that apply

689
00:34:38.976 --> 00:34:41.186 A:middle
to the next recording session.

690
00:34:42.156 --> 00:34:45.335 A:middle
Command 2 is display settings,
so it alters how you see things,

691
00:34:45.335 --> 00:34:47.666 A:middle
either in the detail
and extended detail

692
00:34:47.666 --> 00:34:49.025 A:middle
or in the track view itself.

693
00:34:49.025 --> 00:34:52.556 A:middle
And then Command 3 is
the extended detail,

694
00:34:52.956 --> 00:34:55.426 A:middle
so you can see basically
it's details

695
00:34:55.426 --> 00:34:58.176 A:middle
on whatever is selected
either in your detailed view,

696
00:34:58.176 --> 00:34:59.596 A:middle
like the Call Tree view

697
00:34:59.916 --> 00:35:04.076 A:middle
or in the actual
instruments tracks itself.

698
00:35:04.216 --> 00:35:07.176 A:middle
We also looked at two
of the strategy views.

699
00:35:07.496 --> 00:35:10.046 A:middle
The one we didn't look
at is the CPU strategy,

700
00:35:10.046 --> 00:35:11.456 A:middle
and this will show
you what worked,

701
00:35:11.456 --> 00:35:14.196 A:middle
each core on your
machine is doing.

702
00:35:15.236 --> 00:35:17.646 A:middle
We did see the Instrument
strategy and a few Instruments

703
00:35:17.646 --> 00:35:19.546 A:middle
that all of you are probably
familiar with this strategy.

704
00:35:19.546 --> 00:35:23.066 A:middle
Each track shows you what
an individual instrument

705
00:35:23.066 --> 00:35:23.846 A:middle
is recording.

706
00:35:23.846 --> 00:35:27.206 A:middle
And then, finally,
the thread strategy,

707
00:35:27.616 --> 00:35:30.976 A:middle
which shows you what
each thread is doing.

708
00:35:31.116 --> 00:35:33.636 A:middle
And then just a quick reminder,

709
00:35:33.636 --> 00:35:36.646 A:middle
if you're in Time Profiler
you can enable record winning

710
00:35:36.646 --> 00:35:38.516 A:middle
threads and see any
blocked threads you have,

711
00:35:38.516 --> 00:35:40.746 A:middle
and then you can go through them
and see maybe there's something

712
00:35:40.746 --> 00:35:42.876 A:middle
in your code that's
preventing your threads

713
00:35:42.876 --> 00:35:44.246 A:middle
from doing work when
they should be.

714
00:35:46.386 --> 00:35:48.446 A:middle
We also talked about a
few Call Tree settings.

715
00:35:48.486 --> 00:35:52.926 A:middle
Since expensive calls are
frequently near the end

716
00:35:52.926 --> 00:35:55.686 A:middle
of the call stack, you can
turn on Invert Call Tree.

717
00:35:55.686 --> 00:35:56.936 A:middle
It's also a great way

718
00:35:56.936 --> 00:36:00.646 A:middle
to see what each thread is
spending its time doing.

719
00:36:01.856 --> 00:36:04.746 A:middle
And then you can hide system
libraries to help you focus

720
00:36:04.746 --> 00:36:08.326 A:middle
on your code and not
really, you know,

721
00:36:08.326 --> 00:36:10.656 A:middle
what the frameworks are
doing-you probably can't do a

722
00:36:10.656 --> 00:36:11.906 A:middle
whole lot about.

723
00:36:13.026 --> 00:36:15.336 A:middle
And now I want to
discuss a couple tips.

724
00:36:15.336 --> 00:36:21.446 A:middle
In the Context Menu, on the
Call Tree view, you can choose

725
00:36:21.446 --> 00:36:24.546 A:middle
to focus and prune
current settings.

726
00:36:25.206 --> 00:36:28.386 A:middle
Charge moves the
associated cost based

727
00:36:28.386 --> 00:36:29.736 A:middle
on which option you select.

728
00:36:31.206 --> 00:36:34.176 A:middle
Prune removes the
associated cost,

729
00:36:34.176 --> 00:36:35.946 A:middle
so those things aren't
even sort of part

730
00:36:35.946 --> 00:36:37.256 A:middle
of the calculation anymore.

731
00:36:37.836 --> 00:36:41.096 A:middle
And then focus you can think
of as a prune everything but.

732
00:36:41.936 --> 00:36:48.516 A:middle
And then, finally, I want to
talk about two more guidelines.

733
00:36:48.516 --> 00:36:51.506 A:middle
Some things you should always do
when you're using Time Profiler.

734
00:36:52.596 --> 00:36:55.726 A:middle
First, you should always
Profile Release builds.

735
00:36:55.886 --> 00:37:00.596 A:middle
The performance characteristics
of a debug build

736
00:37:00.596 --> 00:37:02.766 A:middle
versus a release
build are significant.

737
00:37:03.326 --> 00:37:07.486 A:middle
And profiling debug builds
could cause you to fix problems

738
00:37:07.486 --> 00:37:09.596 A:middle
that aren't actually there,
that get optimized away.

739
00:37:10.216 --> 00:37:15.206 A:middle
The default in Xcode is
to profile Release builds,

740
00:37:15.566 --> 00:37:18.826 A:middle
but this is not necessarily
the best option

741
00:37:18.826 --> 00:37:20.116 A:middle
for every Instrument.

742
00:37:20.116 --> 00:37:23.216 A:middle
For example, the
Allocations Instrument

743
00:37:23.306 --> 00:37:25.006 A:middle
when using Objective-C Code,

744
00:37:25.236 --> 00:37:28.946 A:middle
the debug information provides
it extra data it can use

745
00:37:28.946 --> 00:37:31.886 A:middle
to report on your allocations.

746
00:37:32.206 --> 00:37:34.766 A:middle
And you can change this in
the Scheme Editor in Xcode.

747
00:37:34.766 --> 00:37:37.116 A:middle
You just choose the Profile
button and you can change it

748
00:37:37.116 --> 00:37:38.326 A:middle
from debug to release.

749
00:37:38.906 --> 00:37:42.736 A:middle
And then, finally, for iOS it
is really important for you

750
00:37:42.736 --> 00:37:45.066 A:middle
to profile on the device.

751
00:37:45.066 --> 00:37:48.576 A:middle
The simulator, for
some things it is much,

752
00:37:48.576 --> 00:37:49.746 A:middle
much faster, for many things.

753
00:37:49.746 --> 00:37:52.466 A:middle
for some things it's actually
much slower than the device.

754
00:37:53.026 --> 00:37:56.696 A:middle
It really is not a good use of
your time to run Time Profiler

755
00:37:56.696 --> 00:37:58.826 A:middle
in the simulator, all right?

756
00:37:59.626 --> 00:38:01.546 A:middle
And, with that, I'm going to
hand it off to my colleague,

757
00:38:01.546 --> 00:38:04.216 A:middle
Joe Grzywacz, who is going
to show what options you have

758
00:38:04.256 --> 00:38:09.926 A:middle
when Time Profiler
is not quite enough.

759
00:38:10.196 --> 00:38:11.316 A:middle
&gt;&gt; Thank you, Kris.

760
00:38:11.316 --> 00:38:12.376 A:middle
My name is Joe Grzywacz.

761
00:38:12.486 --> 00:38:14.046 A:middle
I'm going to talk to
you about a few things,

762
00:38:14.046 --> 00:38:16.526 A:middle
starting with what are
Performance Counters?

763
00:38:17.466 --> 00:38:20.796 A:middle
Each of the processors in your
machine contain some small

764
00:38:20.796 --> 00:38:23.116 A:middle
number of these 64-bit
hardware registers.

765
00:38:23.436 --> 00:38:27.096 A:middle
Now you have typically like 4
to 8, some very small number,

766
00:38:27.096 --> 00:38:29.196 A:middle
it's a very limited resource,
and these are separate

767
00:38:29.196 --> 00:38:31.666 A:middle
from the regular floating
point and integer registers

768
00:38:31.666 --> 00:38:33.286 A:middle
that you may think of
when you're talking

769
00:38:33.286 --> 00:38:35.386 A:middle
about your program actually
executing and doing work.

770
00:38:35.606 --> 00:38:37.836 A:middle
Now what can you do
with these registers?

771
00:38:38.266 --> 00:38:42.296 A:middle
Well, they're good for counting
some small number of events,

772
00:38:42.726 --> 00:38:45.126 A:middle
things such as number of
instructions you've executed.

773
00:38:45.126 --> 00:38:47.636 A:middle
It'll do cache misses,
branches taken, you know,

774
00:38:47.636 --> 00:38:49.306 A:middle
low-level CPU-specific things.

775
00:38:50.266 --> 00:38:53.436 A:middle
Alternatively, you can have them
take a call stack every time

776
00:38:53.436 --> 00:38:55.426 A:middle
some predetermined
number of events occurs.

777
00:38:55.946 --> 00:38:57.046 A:middle
So what does that look like?

778
00:38:57.636 --> 00:38:59.586 A:middle
The called performance
monitoring interrupts,

779
00:38:59.586 --> 00:39:00.986 A:middle
or PMIs for short.

780
00:39:00.986 --> 00:39:04.176 A:middle
So let's say we have a program
is actually getting here

781
00:39:04.176 --> 00:39:07.446 A:middle
over time, and the blue
bar represents the number

782
00:39:07.446 --> 00:39:08.776 A:middle
of branches we are executing.

783
00:39:09.786 --> 00:39:12.146 A:middle
And so higher means we actually
did more in this period.

784
00:39:12.846 --> 00:39:15.896 A:middle
With time based sampling we just
saw in Time Profiler we're going

785
00:39:15.896 --> 00:39:18.816 A:middle
to take samples at a regular
periodic interval, 1 millisecond

786
00:39:18.816 --> 00:39:21.256 A:middle
by default, and this is
true for the Time Profiler,

787
00:39:21.256 --> 00:39:22.756 A:middle
as well as the counters
instrument.

788
00:39:23.446 --> 00:39:25.196 A:middle
But if we're really interested
in what our program is doing

789
00:39:25.196 --> 00:39:28.006 A:middle
when it's being very branchy,
what we can do is set up one

790
00:39:28.006 --> 00:39:31.356 A:middle
of these PMIs so that we
actually get more samples during

791
00:39:31.356 --> 00:39:32.686 A:middle
the periods we cared about.

792
00:39:33.076 --> 00:39:36.586 A:middle
So we do, let's say, every
10,000 branches or so,

793
00:39:36.586 --> 00:39:39.656 A:middle
let's actually take a
sample, and so we get more

794
00:39:39.656 --> 00:39:41.956 A:middle
in the areas we care
about, fewer everywhere else

795
00:39:41.956 --> 00:39:43.406 A:middle
because that's just noise to us.

796
00:39:43.406 --> 00:39:45.166 A:middle
And this should let us
hone in on the problem

797
00:39:45.166 --> 00:39:47.076 A:middle
in our application just
a little bit quicker.

798
00:39:47.576 --> 00:39:49.876 A:middle
So what else can you do
with Performance Counters?

799
00:39:50.366 --> 00:39:52.056 A:middle
Well, you can get
more information

800
00:39:52.056 --> 00:39:55.046 A:middle
about your app's performance
beyond just time that we saw,

801
00:39:55.336 --> 00:39:57.306 A:middle
so it's sort of a Time
Profiler on steroids,

802
00:39:57.306 --> 00:39:58.806 A:middle
and this is why we consider
it maybe a little bit more

803
00:39:58.806 --> 00:39:59.586 A:middle
of an advanced instrument,

804
00:39:59.586 --> 00:40:00.976 A:middle
but it's something you should
still have in your toolbox.

805
00:40:01.366 --> 00:40:04.596 A:middle
So what can you learn?

806
00:40:04.946 --> 00:40:07.356 A:middle
Things about how you're
utilizing your CPU resources,

807
00:40:07.596 --> 00:40:10.226 A:middle
things like the various levels
of caches in your machine,

808
00:40:10.456 --> 00:40:13.686 A:middle
the execution units,
translation look aside buffers,

809
00:40:13.686 --> 00:40:14.626 A:middle
if you know what that is.

810
00:40:14.876 --> 00:40:16.606 A:middle
So you can look at all
sorts of low-level details

811
00:40:16.606 --> 00:40:18.846 A:middle
that might be bottlenecks for
your particular application.

812
00:40:19.866 --> 00:40:22.406 A:middle
You can also learn more about
your application, itself.

813
00:40:22.666 --> 00:40:24.426 A:middle
For instance, how often
are you branching?

814
00:40:24.466 --> 00:40:26.306 A:middle
How often are those
branches mis-predicted?

815
00:40:26.966 --> 00:40:28.996 A:middle
You can even look at your
instruction mix, you know,

816
00:40:29.036 --> 00:40:30.746 A:middle
how many integer
operations are you doing,

817
00:40:30.956 --> 00:40:32.686 A:middle
how many floating point
operations are you doing?

818
00:40:32.976 --> 00:40:34.866 A:middle
These are things you can't
always determine statically

819
00:40:34.996 --> 00:40:37.186 A:middle
by looking at your program
because you're depending

820
00:40:37.186 --> 00:40:39.236 A:middle
on some user input or
something from the internet

821
00:40:39.236 --> 00:40:40.936 A:middle
of that sort of thing.

822
00:40:41.276 --> 00:40:43.146 A:middle
So we've had counters
for a few years now,

823
00:40:43.826 --> 00:40:46.086 A:middle
but this year we've
added a few new things.

824
00:40:46.666 --> 00:40:48.356 A:middle
First, you can now
specify formulas,

825
00:40:48.356 --> 00:40:51.426 A:middle
so now you can get
those raw events in,

826
00:40:51.546 --> 00:40:53.776 A:middle
but then actually apply
some basic arithmetic

827
00:40:53.776 --> 00:40:54.836 A:middle
to them on top of that.

828
00:40:55.256 --> 00:40:56.576 A:middle
So you can see, we
can generate IPC,

829
00:40:56.576 --> 00:40:58.356 A:middle
which is instructions per cycle.

830
00:40:58.686 --> 00:41:00.596 A:middle
That's a measure of how
much work you're doing

831
00:41:00.596 --> 00:41:01.856 A:middle
in a given clock tick.

832
00:41:01.856 --> 00:41:04.116 A:middle
Generally, a higher number here
means you're doing more work

833
00:41:04.116 --> 00:41:05.436 A:middle
and performing better.

834
00:41:05.856 --> 00:41:08.176 A:middle
You can calculate branch
misprediction rate or things,

835
00:41:08.176 --> 00:41:09.986 A:middle
like your L1 cache
miss percentage,

836
00:41:10.336 --> 00:41:12.796 A:middle
take the total number of loads
to your L1 cache that missed,

837
00:41:12.886 --> 00:41:15.906 A:middle
add them to the total number of
stores I missed, and then divide

838
00:41:15.906 --> 00:41:18.116 A:middle
that by the number of
total loads plus the number

839
00:41:18.116 --> 00:41:21.246 A:middle
of total stores, and multiply it
by 100 for a missed percentage.

840
00:41:22.236 --> 00:41:27.356 A:middle
Now we've had x86 support for
a few years, and this year

841
00:41:27.356 --> 00:41:30.706 A:middle
with iOS 8 you can get
64-bit ARM devices,

842
00:41:30.706 --> 00:41:31.646 A:middle
tab counters, as well.

843
00:41:31.646 --> 00:41:39.526 A:middle
And then the event profiler
instrument, if you're familiar

844
00:41:39.526 --> 00:41:41.876 A:middle
with that, that's where
you used to go for any kind

845
00:41:41.876 --> 00:41:44.196 A:middle
of PMI-based information
for that kind of sampling.

846
00:41:44.196 --> 00:41:44.986 A:middle
You can just do that right

847
00:41:44.986 --> 00:41:47.526 A:middle
within the counters instrument
now and there's actually no need

848
00:41:47.526 --> 00:41:48.816 A:middle
to go do two separate
instruments.

849
00:41:48.816 --> 00:41:51.266 A:middle
Anything counters-related,
head over to counters.

850
00:41:52.176 --> 00:41:54.136 A:middle
And, with that, we'll
do a little demo

851
00:41:54.136 --> 00:41:55.266 A:middle
of iOS Performance Counters.

852
00:41:55.266 --> 00:41:59.356 A:middle
So I have a little basic
Matrix Multiplication app,

853
00:41:59.546 --> 00:42:02.096 A:middle
so if your linear
algebra is a bit hazy

854
00:42:02.096 --> 00:42:06.886 A:middle
to do a Matrix Multiplication
of a two N by N Matrices,

855
00:42:06.886 --> 00:42:09.346 A:middle
for each element in your
alpha Matrix C you have

856
00:42:09.346 --> 00:42:11.906 A:middle
to multiply piece by
piece an entire row

857
00:42:11.906 --> 00:42:14.116 A:middle
of the input Matrix A
times an entire column

858
00:42:14.426 --> 00:42:16.206 A:middle
of the input Matrix
B, and then add each

859
00:42:16.206 --> 00:42:17.106 A:middle
of those parts together.

860
00:42:17.586 --> 00:42:20.486 A:middle
So in pseudocode it's basically
just this triple-nested

861
00:42:20.486 --> 00:42:23.326 A:middle
for loop here, where all
the work is really the sum

862
00:42:23.326 --> 00:42:24.416 A:middle
of products happening here.

863
00:42:24.926 --> 00:42:32.066 A:middle
So in Swift code, this
does scroll fast-all right,

864
00:42:32.066 --> 00:42:34.666 A:middle
so we have our, basically, this
is our triple-nested for loop,

865
00:42:34.936 --> 00:42:37.576 A:middle
and with all that work being
done again and that summation

866
00:42:37.576 --> 00:42:39.376 A:middle
of the Matrix A times Matrix B.

867
00:42:40.116 --> 00:42:41.456 A:middle
And so what I want
to do is go ahead

868
00:42:41.456 --> 00:42:43.176 A:middle
and profile this in Instruments.

869
00:42:43.336 --> 00:42:45.826 A:middle
So now this is going
to run on my device.

870
00:42:46.476 --> 00:42:49.946 A:middle
I'm going to use the option
profile, so that's just going

871
00:42:49.946 --> 00:42:51.556 A:middle
to launch Time Profiler,
and it's going

872
00:42:51.556 --> 00:42:52.926 A:middle
to start recording on my device.

873
00:42:53.716 --> 00:42:56.686 A:middle
And I can tap a button, and it
starts my Matrix Multiplication.

874
00:42:56.686 --> 00:42:58.296 A:middle
Now this is going to
take a little while

875
00:42:58.296 --> 00:43:01.176 A:middle
because I'm multiplying two
1,000 by 1,000 matrices,

876
00:43:01.176 --> 00:43:04.066 A:middle
each of them contains a
double, so that's 8 bytes,

877
00:43:04.066 --> 00:43:07.306 A:middle
so it's 8 megabytes per
matrix, 24 megabytes in total.

878
00:43:07.636 --> 00:43:10.836 A:middle
And so it takes us here
about-well, it took about, what,

879
00:43:10.836 --> 00:43:13.916 A:middle
12 seconds to do
that calculation.

880
00:43:13.916 --> 00:43:18.346 A:middle
So I'm going to go ahead and
stop, click drag to time filter,

881
00:43:18.396 --> 00:43:19.736 A:middle
to the region of interest.

882
00:43:20.236 --> 00:43:21.516 A:middle
Let me make this
a little bigger.

883
00:43:22.706 --> 00:43:25.756 A:middle
And what I want to see is
where was my app spending time?

884
00:43:27.266 --> 00:43:29.876 A:middle
So if we zoom in here on
our extended detail view,

885
00:43:30.546 --> 00:43:32.646 A:middle
where we can follow
that really big number,

886
00:43:32.766 --> 00:43:34.036 A:middle
that's how many samples
there were.

887
00:43:34.096 --> 00:43:36.316 A:middle
It gets really small
as we drop down here,

888
00:43:36.596 --> 00:43:38.676 A:middle
so the problem is most of the
samples are actually occurring

889
00:43:38.676 --> 00:43:40.656 A:middle
in this Matrix Multiplier
routine.

890
00:43:40.996 --> 00:43:44.056 A:middle
And if we double click on
that routine we get taken

891
00:43:44.056 --> 00:43:46.526 A:middle
to the source code, just
like before, and we can see,

892
00:43:46.526 --> 00:43:49.486 A:middle
just as I expected, 92% of
my time is being spent right

893
00:43:49.486 --> 00:43:50.466 A:middle
on that summation line.

894
00:43:50.916 --> 00:43:52.526 A:middle
I don't have much code,
it's all being spent

895
00:43:52.526 --> 00:43:55.246 A:middle
on the one line I wrote,
so I'm kind of at the end

896
00:43:55.246 --> 00:43:56.206 A:middle
of the road with Time Profiler.

897
00:43:56.206 --> 00:43:58.226 A:middle
I mean, I think I've done
as much as I could do.

898
00:43:59.546 --> 00:44:01.466 A:middle
Well, we can actually
dig a little bit deeper

899
00:44:01.496 --> 00:44:02.976 A:middle
if we're willing to go
look at this assembly.

900
00:44:04.416 --> 00:44:07.936 A:middle
And what we have here is
these ldr instructions

901
00:44:07.936 --> 00:44:09.656 A:middle
that are taking a bunch of time,

902
00:44:09.656 --> 00:44:12.706 A:middle
and an ldr is basically just
loading a register from memory.

903
00:44:13.136 --> 00:44:15.476 A:middle
And so we can see these
two ldr instructions,

904
00:44:15.476 --> 00:44:18.306 A:middle
one of them is loading Matrix A,
one of them is loading Matrix B,

905
00:44:18.306 --> 00:44:19.486 A:middle
and they're taking a long time.

906
00:44:20.136 --> 00:44:21.746 A:middle
So now I can use the
Counters Instrument

907
00:44:21.746 --> 00:44:23.126 A:middle
to actually go and
figure out why.

908
00:44:23.126 --> 00:44:25.276 A:middle
So I'm going to start
a new template,

909
00:44:26.346 --> 00:44:32.436 A:middle
select Counters, there we go.

910
00:44:34.276 --> 00:44:36.636 A:middle
And now I want to add
some interesting events

911
00:44:36.636 --> 00:44:38.636 A:middle
to record using Counters.

912
00:44:39.536 --> 00:44:42.956 A:middle
And so if we choose to add
an event, we can see the list

913
00:44:42.956 --> 00:44:45.636 A:middle
of all of the events that
this device supports,

914
00:44:45.756 --> 00:44:48.916 A:middle
and I'm interested in my
L2 cache, so I'm going

915
00:44:48.916 --> 00:44:50.866 A:middle
to add the number
of L2 cache loads.

916
00:44:51.506 --> 00:44:54.386 A:middle
And I have a favorites list here
already of the L2 cache loads

917
00:44:54.386 --> 00:44:58.276 A:middle
that missed, the number
of stores, and the number

918
00:44:58.276 --> 00:44:59.496 A:middle
of stores that missed.

919
00:44:59.936 --> 00:45:00.966 A:middle
So I have those events.

920
00:45:00.966 --> 00:45:02.656 A:middle
I'm going to create
a formula using them.

921
00:45:03.536 --> 00:45:06.126 A:middle
So I want to get
one number that kind

922
00:45:06.126 --> 00:45:08.836 A:middle
of represents those four
things, and what I'm going

923
00:45:08.836 --> 00:45:12.796 A:middle
to do is actually generate a
miss rate by saying the number

924
00:45:12.796 --> 00:45:16.626 A:middle
of loads plus the number
of stores that missed,

925
00:45:17.416 --> 00:45:22.266 A:middle
and divide that by the summation
of the total number of loads,

926
00:45:22.776 --> 00:45:29.076 A:middle
which is loads plus
stores, okay.

927
00:45:29.976 --> 00:45:34.866 A:middle
And if I multiply that by 100,
now I have my missed percentage,

928
00:45:34.866 --> 00:45:36.936 A:middle
that's a little negative
for me, I prefer to think

929
00:45:36.936 --> 00:45:39.836 A:middle
in hit percentage, so I'll
just take 100 minus that number

930
00:45:40.276 --> 00:45:42.826 A:middle
and give it a name,
L2 Hit Percentage.

931
00:45:42.916 --> 00:45:45.946 A:middle
Add that event, and as I
mentioned before IPC is one

932
00:45:45.946 --> 00:45:47.056 A:middle
of those handy guys to have.

933
00:45:47.056 --> 00:45:49.876 A:middle
There's a predefined formula for
IPC, so I'm going to go ahead

934
00:45:49.876 --> 00:45:51.026 A:middle
and add that, as well.

935
00:45:51.706 --> 00:45:53.716 A:middle
And so I'm going to
start my recording again,

936
00:45:55.176 --> 00:45:58.016 A:middle
and this time I'm going
to see the Call Tree view,

937
00:45:58.346 --> 00:46:01.826 A:middle
as well as the track view has a
bunch more things being drawn,

938
00:46:01.826 --> 00:46:02.846 A:middle
and those are all my events.

939
00:46:02.846 --> 00:46:05.186 A:middle
So I'm going to start my
Matrix Multiplication again,

940
00:46:05.186 --> 00:46:07.716 A:middle
you can see all those
events going by,

941
00:46:07.716 --> 00:46:08.746 A:middle
and those are being calculated.

942
00:46:08.746 --> 00:46:13.616 A:middle
And as this wraps up we
can actually start looking

943
00:46:13.616 --> 00:46:15.956 A:middle
at the information in detail.

944
00:46:15.956 --> 00:46:19.456 A:middle
So it just finished, and what
we have here is the number

945
00:46:19.456 --> 00:46:23.216 A:middle
of L2 cache loads,
was at 462 million.

946
00:46:23.686 --> 00:46:24.666 A:middle
Okay, that's a lot.

947
00:46:24.966 --> 00:46:26.926 A:middle
124 million of them missed,

948
00:46:26.926 --> 00:46:29.126 A:middle
and there's a much more
insignificant number of stores.

949
00:46:29.326 --> 00:46:32.486 A:middle
Our overall hit percentage
was 72% or so.

950
00:46:32.486 --> 00:46:33.906 A:middle
Okay, that's not too bad.

951
00:46:33.956 --> 00:46:37.336 A:middle
Our IPC was 0.6, that
means we're doing less

952
00:46:37.336 --> 00:46:38.686 A:middle
than one instruction per clock.

953
00:46:38.686 --> 00:46:40.766 A:middle
I don't know, I think
that sounds kind of bad,

954
00:46:40.766 --> 00:46:42.886 A:middle
I thought computers could
do multiple things per clock

955
00:46:42.886 --> 00:46:43.396 A:middle
these days.

956
00:46:44.646 --> 00:46:47.026 A:middle
But the number that
sticks out to me most is

957
00:46:47.026 --> 00:46:52.046 A:middle
that L2 cache load number: 462
million loads to my L2 cache

958
00:46:52.396 --> 00:46:55.496 A:middle
when my input matrices are
only 1 million elements each,

959
00:46:55.496 --> 00:46:56.246 A:middle
so a kind

960
00:46:56.246 --> 00:46:58.186 A:middle
of back-of-the-envelope
calculation says I should only

961
00:46:58.186 --> 00:47:01.036 A:middle
probably do about 2
million, so why is it so big?

962
00:47:01.716 --> 00:47:04.136 A:middle
Well, it turns out if
you go online and search,

963
00:47:04.136 --> 00:47:06.736 A:middle
there's actually much better
ways to do Matrix Multiplication

964
00:47:06.736 --> 00:47:10.056 A:middle
that are a lot more cache
friendly for today's processors.

965
00:47:10.366 --> 00:47:12.956 A:middle
And one of those ways
is actually go and block

966
00:47:12.956 --> 00:47:14.926 A:middle
up our Matrix Multiplication
instead of trying

967
00:47:14.926 --> 00:47:17.076 A:middle
to do an entire row and
an entire column at once,

968
00:47:17.076 --> 00:47:18.676 A:middle
we're going to do it
in smaller pieces.

969
00:47:19.066 --> 00:47:21.296 A:middle
Because this Matrix is so
big trying to do it all

970
00:47:21.296 --> 00:47:23.016 A:middle
at once means we're going
to load in a lot of data

971
00:47:23.016 --> 00:47:25.366 A:middle
and then kick it back out to
memory and then load it back

972
00:47:25.366 --> 00:47:26.646 A:middle
in again and kick it back out,

973
00:47:26.646 --> 00:47:28.426 A:middle
and that's very inefficient
and slow.

974
00:47:28.866 --> 00:47:30.116 A:middle
So I have another implementation

975
00:47:30.116 --> 00:47:33.356 A:middle
where I actually block
this matrix up into, oh,

976
00:47:33.356 --> 00:47:36.366 A:middle
like 50 by 50 pieces,
so much smaller.

977
00:47:36.886 --> 00:47:39.436 A:middle
And we can see it execute here
and there, it already finished.

978
00:47:40.266 --> 00:47:43.176 A:middle
So we did this in about, let's
see, time filtered down to

979
00:47:43.176 --> 00:47:47.726 A:middle
that region and we can see
where our running time now is

980
00:47:47.726 --> 00:47:51.566 A:middle
at 3.5 seconds, so we already
split it up about three times

981
00:47:51.566 --> 00:47:54.076 A:middle
and it took about 3 lines of
code, very straightforward.

982
00:47:55.366 --> 00:47:58.986 A:middle
And our L2 cache load
number is now at 24 million,

983
00:47:59.286 --> 00:48:02.306 A:middle
so we went from 450
million down to 24 million,

984
00:48:02.306 --> 00:48:03.516 A:middle
so that's much improved.

985
00:48:03.786 --> 00:48:05.896 A:middle
Cache stores are still
somewhat insignificant,

986
00:48:05.896 --> 00:48:09.756 A:middle
although they're growing
in size relative to loads.

987
00:48:09.756 --> 00:48:10.556 A:middle
Our L2 hit percentage,

988
00:48:10.606 --> 00:48:12.766 A:middle
interestingly enough,
has come down.

989
00:48:12.766 --> 00:48:16.216 A:middle
We were in the low 70s
before, now we're at 64%,

990
00:48:16.216 --> 00:48:17.586 A:middle
that's a little bit odd.

991
00:48:17.996 --> 00:48:20.756 A:middle
Our IPC, though, is much
better, it's at 1.6.

992
00:48:20.756 --> 00:48:23.796 A:middle
Now we're actually doing
1.5 instructions per cycle,

993
00:48:23.796 --> 00:48:25.316 A:middle
so that's a lot better.

994
00:48:26.096 --> 00:48:27.036 A:middle
So this is where we kind

995
00:48:27.036 --> 00:48:28.896 A:middle
of consider this a little
bit more advanced instrument

996
00:48:28.896 --> 00:48:31.066 A:middle
because you can generate a
lot more of these numbers,

997
00:48:31.066 --> 00:48:32.986 A:middle
but you have to know how
to interpret the results.

998
00:48:33.336 --> 00:48:35.546 A:middle
And so our IPC got
better, so that was great.

999
00:48:35.866 --> 00:48:38.636 A:middle
Our cache hit rate went
down, but was that a problem?

1000
00:48:38.636 --> 00:48:41.306 A:middle
Well, no, because we actually
did hundreds of millions

1001
00:48:41.306 --> 00:48:44.236 A:middle
of loads less to that cache, so
the fact that that hit rate came

1002
00:48:44.236 --> 00:48:48.596 A:middle
down a little bit, not
really that big of a deal.

1003
00:48:48.786 --> 00:48:51.756 A:middle
To kind of wrap up, this Matrix
Multiplication thing you could

1004
00:48:51.756 --> 00:48:54.306 A:middle
continue, keep on iterating and
try to write a better version,

1005
00:48:54.666 --> 00:48:56.206 A:middle
however, we've already
done that for you.

1006
00:48:56.346 --> 00:48:59.856 A:middle
There's an Accelerate framework
that has that done, and if I tap

1007
00:48:59.856 --> 00:49:02.516 A:middle
on that version, see it
actually finished here

1008
00:49:02.516 --> 00:49:06.446 A:middle
in about 200 milliseconds
and it's one line of code

1009
00:49:06.576 --> 00:49:08.006 A:middle
and it works, and it's optimized

1010
00:49:08.006 --> 00:49:09.806 A:middle
for multiple cores,
multiple devices.

1011
00:49:09.806 --> 00:49:11.816 A:middle
A piece of cake, please
don't go write your own

1012
00:49:11.816 --> 00:49:12.896 A:middle
Matrix Multiplication.

1013
00:49:14.866 --> 00:49:17.916 A:middle
Now the last thing to point out
on this demo is I spend a lot

1014
00:49:17.916 --> 00:49:21.076 A:middle
of time over here, down
here, adding these events,

1015
00:49:21.166 --> 00:49:22.156 A:middle
adding these formulas.

1016
00:49:22.156 --> 00:49:23.106 A:middle
They're really useful.

1017
00:49:23.106 --> 00:49:25.326 A:middle
I'm going to come here to this
instrument many, many times.

1018
00:49:25.556 --> 00:49:28.706 A:middle
I don't want to type them
in again, so be sure to go

1019
00:49:28.706 --> 00:49:32.886 A:middle
up to File &gt; Save As a Template,
give this some interesting name:

1020
00:49:32.936 --> 00:49:36.036 A:middle
L2 Hit Rate Counter,
or something like that.

1021
00:49:37.156 --> 00:49:39.836 A:middle
And then save that off, and
then the next time you go

1022
00:49:39.836 --> 00:49:42.136 A:middle
to the template chooser,
use the custom filter,

1023
00:49:42.496 --> 00:49:44.246 A:middle
load up this template,
you don't have to type

1024
00:49:44.246 --> 00:49:45.876 A:middle
that in again and
again and again.

1025
00:49:46.516 --> 00:49:53.236 A:middle
[ Applause ]

1026
00:49:53.736 --> 00:49:54.396 A:middle
So what did we see?

1027
00:49:54.396 --> 00:49:57.356 A:middle
With counters you're
basically going to collect data

1028
00:49:57.416 --> 00:49:59.306 A:middle
by default, similar
to Time Profiler.

1029
00:49:59.616 --> 00:50:01.836 A:middle
It's a statistical sampling
of your application.

1030
00:50:01.836 --> 00:50:03.596 A:middle
This is an important
point: that basically

1031
00:50:03.596 --> 00:50:06.516 A:middle
for the past 1 millisecond
by default,

1032
00:50:06.516 --> 00:50:08.666 A:middle
we're aggregating the
time and all the events,

1033
00:50:08.666 --> 00:50:10.286 A:middle
and then we're going to
attribute it to that one moment

1034
00:50:10.286 --> 00:50:12.016 A:middle
in time where we take
a call stack sample

1035
00:50:12.016 --> 00:50:12.716 A:middle
of your application.

1036
00:50:13.296 --> 00:50:15.706 A:middle
This means you want to
get a lot of CPU samples

1037
00:50:15.706 --> 00:50:17.076 A:middle
to get really an
accurate picture

1038
00:50:17.076 --> 00:50:18.446 A:middle
of what your application
is doing.

1039
00:50:18.496 --> 00:50:20.096 A:middle
If you're not very
CPU-intensive,

1040
00:50:20.096 --> 00:50:21.726 A:middle
this isn't the instrument
for you.

1041
00:50:21.766 --> 00:50:23.976 A:middle
You can tweak that slightly

1042
00:50:23.976 --> 00:50:26.396 A:middle
by using the Performance
Monitoring Interrupts.

1043
00:50:26.396 --> 00:50:29.756 A:middle
So this allows you to vary
the sampling rate based

1044
00:50:29.756 --> 00:50:31.166 A:middle
on the number of events
that are happening.

1045
00:50:31.166 --> 00:50:32.786 A:middle
So if you're really
interested in branches

1046
00:50:33.036 --> 00:50:36.456 A:middle
or L2 cache hit rate you
can actually sample based

1047
00:50:36.456 --> 00:50:38.116 A:middle
on how many of those
things are occurring

1048
00:50:38.176 --> 00:50:42.546 A:middle
and get more refined results
on what you're looking at.

1049
00:50:42.546 --> 00:50:45.146 A:middle
Note that the PMI
instructions can be slightly,

1050
00:50:45.146 --> 00:50:49.106 A:middle
a little bit imprecise in that,
by the time the interrupt fires,

1051
00:50:49.106 --> 00:50:50.966 A:middle
let's say you take a call
stack, a small number

1052
00:50:50.966 --> 00:50:54.106 A:middle
of instructions may have gone
by, which means you won't be

1053
00:50:54.106 --> 00:50:56.236 A:middle
on the precise instruction that
caused this, but you're going

1054
00:50:56.236 --> 00:50:57.886 A:middle
to be right in the
neighborhood and it'll get you

1055
00:50:57.886 --> 00:50:59.376 A:middle
to the problem a
lot more quickly.

1056
00:50:59.966 --> 00:51:02.546 A:middle
And be sure to use formulas,

1057
00:51:02.586 --> 00:51:04.046 A:middle
so you can gather
all these raw events,

1058
00:51:04.046 --> 00:51:06.666 A:middle
but a lot of times it's a lot
easier to generate one metric,

1059
00:51:06.666 --> 00:51:09.126 A:middle
that makes it a lot easier
to see the problem at hand.

1060
00:51:09.476 --> 00:51:12.616 A:middle
So generate those formulas
and then save them inside

1061
00:51:12.616 --> 00:51:14.926 A:middle
of a template so
that you can get back

1062
00:51:14.926 --> 00:51:16.116 A:middle
to them quickly in the future.

1063
00:51:18.406 --> 00:51:19.656 A:middle
Changing gears entirely.

1064
00:51:21.176 --> 00:51:23.706 A:middle
DTrace, if you're
unfamiliar with DTrace,

1065
00:51:23.796 --> 00:51:26.396 A:middle
I recommend you go
online, there's plenty

1066
00:51:26.396 --> 00:51:27.446 A:middle
of information about it.

1067
00:51:27.746 --> 00:51:29.926 A:middle
Basically, it's a kernel-based
recording technology,

1068
00:51:29.926 --> 00:51:31.336 A:middle
it'll let you get
more information

1069
00:51:31.336 --> 00:51:32.586 A:middle
about your application,

1070
00:51:32.586 --> 00:51:34.326 A:middle
especially how it
interacts with the kernel.

1071
00:51:34.326 --> 00:51:35.856 A:middle
Today we're only going to talk

1072
00:51:35.856 --> 00:51:38.186 A:middle
about what's new
with OS X Yosemite.

1073
00:51:39.936 --> 00:51:41.676 A:middle
First, there's a
dynamic tracemem.

1074
00:51:41.826 --> 00:51:43.596 A:middle
So a tracemem is a
way to actually print

1075
00:51:43.596 --> 00:51:44.986 A:middle
out the contents of your memory.

1076
00:51:45.496 --> 00:51:48.836 A:middle
So previously you had to
know the size of your array

1077
00:51:48.836 --> 00:51:51.396 A:middle
and compile time, and
that happens to work a lot

1078
00:51:51.396 --> 00:51:52.716 A:middle
of the times, but not always.

1079
00:51:52.716 --> 00:51:55.386 A:middle
Now it'll work with
variable size arrays.

1080
00:51:55.716 --> 00:51:58.476 A:middle
So say I want to trace this
CGContextFillRects guy?

1081
00:51:58.836 --> 00:52:03.396 A:middle
Arg1 is a variable size rects
array, and Arg2 is the count

1082
00:52:03.396 --> 00:52:04.656 A:middle
of how many things are in there.

1083
00:52:05.476 --> 00:52:08.046 A:middle
So you can write this DTrace
script that upon entry

1084
00:52:08.216 --> 00:52:11.236 A:middle
into CGContextFillRects, what
we're going to do is copy

1085
00:52:11.286 --> 00:52:14.036 A:middle
in Arg1, which is the
array, and then the size

1086
00:52:14.036 --> 00:52:15.016 A:middle
of that array is the size

1087
00:52:15.016 --> 00:52:18.166 A:middle
of a single CGRect times
Arg2, which is the count.

1088
00:52:18.586 --> 00:52:20.566 A:middle
So once you have that copied
into the kernel we're going

1089
00:52:20.566 --> 00:52:23.866 A:middle
to call tracemem on that, so
we pass the array, we pass 512,

1090
00:52:23.866 --> 00:52:26.106 A:middle
which is the maximum size
we ever expect it to be

1091
00:52:26.596 --> 00:52:29.756 A:middle
for our application, and then
again we pass that same count.

1092
00:52:29.756 --> 00:52:32.056 A:middle
So now tracemem works on
your variable sized arrays.

1093
00:52:33.306 --> 00:52:35.346 A:middle
The next big improvement
is the Histograms

1094
00:52:35.346 --> 00:52:36.436 A:middle
that have been improved vastly.

1095
00:52:36.576 --> 00:52:39.146 A:middle
There's a number of new options,
too many to discuss here,

1096
00:52:39.486 --> 00:52:42.406 A:middle
but basically you'll get much
better, improved Histograms,

1097
00:52:42.856 --> 00:52:45.326 A:middle
easier to read, better
ASCII art on your terminal

1098
00:52:45.326 --> 00:52:46.496 A:middle
when you're generating
these things.

1099
00:52:46.846 --> 00:52:49.676 A:middle
I refer you to that excellent
blog post on DTrace.org

1100
00:52:49.676 --> 00:52:51.736 A:middle
that will describe to you all
the options and all the ways

1101
00:52:51.736 --> 00:52:52.726 A:middle
that it will be helpful to you.

1102
00:52:53.276 --> 00:52:56.656 A:middle
There's a few other
new features.

1103
00:52:57.016 --> 00:52:58.806 A:middle
Previously, if you wanted

1104
00:52:58.806 --> 00:53:01.606 A:middle
to make sure you got every
single probe firing from DTrace,

