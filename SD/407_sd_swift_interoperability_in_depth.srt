

1
00:00:00.506 --> 00:00:11.516 A:middle
[ Silence ]

2
00:00:12.016 --> 00:00:16.000 A:middle
[ Applause ]

3
00:00:16.516 --> 00:00:16.986 A:middle
&gt;&gt; Welcome.

4
00:00:18.216 --> 00:00:19.176 A:middle
So I'm Doug Gregor.

5
00:00:19.416 --> 00:00:22.656 A:middle
I'm an engineer on the Swift
Compiler Team, and we're here

6
00:00:22.656 --> 00:00:24.976 A:middle
to talk about Swift
Interoperabiity.

7
00:00:28.626 --> 00:00:30.416 A:middle
We're going to talk about a
couple of different things here.

8
00:00:31.166 --> 00:00:33.986 A:middle
So, of course, Swift is
a new language for Cocoa

9
00:00:33.986 --> 00:00:35.526 A:middle
and Cocoa Touch development.

10
00:00:36.856 --> 00:00:38.746 A:middle
Now, Cocoa's not
written in Swift.

11
00:00:38.746 --> 00:00:41.286 A:middle
It's written in Objective-C,
a language you've been using

12
00:00:41.286 --> 00:00:43.526 A:middle
for years and that all of
your apps are written in.

13
00:00:44.276 --> 00:00:47.036 A:middle
So, interoperability between
these two very different

14
00:00:47.036 --> 00:00:49.626 A:middle
programming languages
is absolutely critical.

15
00:00:50.106 --> 00:00:52.636 A:middle
So we're going to talk about
how that interoperating works

16
00:00:53.076 --> 00:00:54.576 A:middle
at the language level.

17
00:00:55.116 --> 00:00:58.786 A:middle
We're going to hit a number
of different topics today.

18
00:00:59.426 --> 00:01:01.336 A:middle
We're going to talk
about working with Cocoa,

19
00:01:01.436 --> 00:01:06.816 A:middle
seeing how the Cocoa APIs or
Objective-C APIs look and feel

20
00:01:06.816 --> 00:01:09.916 A:middle
in Swift and how to work
with them, as well as working

21
00:01:09.916 --> 00:01:13.786 A:middle
with some more Swift concepts
like dealing with AnyObject

22
00:01:13.786 --> 00:01:17.046 A:middle
and doing dynamic
checks on your types.

23
00:01:18.106 --> 00:01:20.206 A:middle
Then we're going to
talk about bridging

24
00:01:20.526 --> 00:01:23.356 A:middle
of the core Cocoa
datatypes and NSArray

25
00:01:23.356 --> 00:01:27.386 A:middle
and NSDictionary NSString into
their Swift native equivalents.

26
00:01:28.616 --> 00:01:30.796 A:middle
Then we'll move on
to subclassing,

27
00:01:30.946 --> 00:01:33.946 A:middle
so writing Swift classes
that subclass or Objective-C

28
00:01:34.186 --> 00:01:36.576 A:middle
and how they're mapped
back into Objective-C

29
00:01:36.856 --> 00:01:38.926 A:middle
so that you can use these
two languages together.

30
00:01:40.156 --> 00:01:42.526 A:middle
And, finally, we're going to
talk about core foundation

31
00:01:42.526 --> 00:01:44.316 A:middle
and core graphics, and
this general notion

32
00:01:44.316 --> 00:01:48.276 A:middle
of CF Interoperability within
the Swift Programming Language.

33
00:01:48.806 --> 00:01:53.366 A:middle
Let's get started talking
about working with Cocoa.

34
00:01:55.466 --> 00:01:59.616 A:middle
So swift provides seamless
access of Objective-C APIs

35
00:01:59.916 --> 00:02:03.166 A:middle
through the Objective-C Module
System we introduced last year.

36
00:02:03.796 --> 00:02:06.986 A:middle
So you can pull your Objective-C
APIs whether they be from Cocoa

37
00:02:06.986 --> 00:02:09.826 A:middle
or your own into
Swift and use them.

38
00:02:10.556 --> 00:02:13.206 A:middle
And then Swift maps
those Objective-C APIs

39
00:02:13.306 --> 00:02:15.126 A:middle
into the Swift syntax.

40
00:02:15.836 --> 00:02:19.186 A:middle
This covers both the objective
parts of Objective-C --

41
00:02:19.306 --> 00:02:21.656 A:middle
the classes, protocols,
methods, and so on,

42
00:02:22.116 --> 00:02:24.856 A:middle
as well as the lower level
C things like functions,

43
00:02:24.856 --> 00:02:26.956 A:middle
enumerations, structs, pointers.

44
00:02:27.456 --> 00:02:29.966 A:middle
So you have access to all
of your Objective-C APIs.

45
00:02:31.456 --> 00:02:33.926 A:middle
Now when you look at one of
these Objective-C APIs in Swift,

46
00:02:34.486 --> 00:02:36.366 A:middle
it's going to be
different from Objective-C.

47
00:02:37.316 --> 00:02:39.286 A:middle
There are inherent
syntactic differences

48
00:02:39.336 --> 00:02:41.346 A:middle
between these two
language, of course.

49
00:02:42.426 --> 00:02:46.506 A:middle
Swift also has some
modern features that we use

50
00:02:46.506 --> 00:02:49.266 A:middle
when expressing those
Objective-C APIs in Swift

51
00:02:49.266 --> 00:02:51.196 A:middle
that will make it look
a little bit different,

52
00:02:51.516 --> 00:02:54.066 A:middle
as well as the bridging
of core Cocoa types

53
00:02:54.316 --> 00:02:55.306 A:middle
that I mentioned earlier.

54
00:02:55.926 --> 00:02:59.486 A:middle
Now, despite all of these
differences that you see

55
00:02:59.486 --> 00:03:02.396 A:middle
when looking at the
APIs, it's still Cocoa,

56
00:03:02.586 --> 00:03:04.006 A:middle
it's still Cocoa Touch.

57
00:03:04.236 --> 00:03:07.366 A:middle
And the same conventions
and idioms still apply,

58
00:03:07.766 --> 00:03:10.166 A:middle
so what you know of
Cocoa works in Swift.

59
00:03:10.206 --> 00:03:11.676 A:middle
It's just a different
programming language

60
00:03:11.766 --> 00:03:14.646 A:middle
for the same great platform,
the same great frameworks.

61
00:03:16.136 --> 00:03:19.356 A:middle
So we're going to walk through
part of something we know

62
00:03:19.356 --> 00:03:22.336 A:middle
and love, and that's
the UIDocument class.

63
00:03:23.736 --> 00:03:26.456 A:middle
Here's a tiny slice
of it in Objective-C.

64
00:03:26.846 --> 00:03:30.706 A:middle
We're going to walk through how
and why that maps into Swift.

65
00:03:31.546 --> 00:03:33.976 A:middle
First thing, something
simple, a property;

66
00:03:34.546 --> 00:03:36.596 A:middle
fileModificationDate,
it is an NSDate!

67
00:03:37.826 --> 00:03:40.756 A:middle
This comes into Swift
as a property.

68
00:03:40.986 --> 00:03:41.956 A:middle
It's the var keyword.

69
00:03:42.536 --> 00:03:45.536 A:middle
The NSDate class, of course
just comes into Swift.

70
00:03:45.536 --> 00:03:47.346 A:middle
Nothing interesting there except

71
00:03:47.346 --> 00:03:50.396 A:middle
for this little exclamation
point that you may have noticed.

72
00:03:50.896 --> 00:03:55.966 A:middle
Now that exclamation point is an
Implicitly Unwrapped Optional.

73
00:03:56.486 --> 00:03:58.846 A:middle
What does that mean?

74
00:03:59.156 --> 00:04:01.456 A:middle
Well, let's look at
Swift in Objective-C.

75
00:04:01.456 --> 00:04:03.946 A:middle
They're different languages with
some different ideas in them.

76
00:04:04.456 --> 00:04:06.616 A:middle
So in Swift, when
you have a value

77
00:04:06.616 --> 00:04:09.366 A:middle
of class type, so
I have an NSDate!

78
00:04:09.866 --> 00:04:11.746 A:middle
That can never be nil.

79
00:04:12.466 --> 00:04:13.826 A:middle
So a very strong constraint.

80
00:04:14.566 --> 00:04:16.616 A:middle
And it makes life a bit
simpler when you know

81
00:04:16.616 --> 00:04:17.565 A:middle
that thing is not nil.

82
00:04:19.036 --> 00:04:21.646 A:middle
Now, when you want to deal
with nil, you have an NSDate!

83
00:04:21.646 --> 00:04:25.056 A:middle
that could be nil, you
use an optional type,

84
00:04:25.236 --> 00:04:27.256 A:middle
and optional types are
covered extensively

85
00:04:27.256 --> 00:04:29.506 A:middle
in the Intermediate Swift talk.

86
00:04:30.046 --> 00:04:31.526 A:middle
We're going to cover them
a little bit more now.

87
00:04:32.976 --> 00:04:34.546 A:middle
That's the Swift side of things.

88
00:04:34.986 --> 00:04:36.226 A:middle
What about Objective-C?

89
00:04:36.656 --> 00:04:39.756 A:middle
Well, it does not have
the notion of a never

90
00:04:39.756 --> 00:04:42.816 A:middle
"never-nil" pointer
like we have in Swift.

91
00:04:43.356 --> 00:04:45.876 A:middle
And so we have a little
impedance mismatch here.

92
00:04:45.876 --> 00:04:50.256 A:middle
The Objective-C APIs don't have
the notion of this is not nil,

93
00:04:50.256 --> 00:04:52.146 A:middle
but we need to bring
them into Swift.

94
00:04:52.796 --> 00:04:56.066 A:middle
And so, we have the
implicitly unwrapped optional

95
00:04:56.146 --> 00:04:57.486 A:middle
with the exclamation point here.

96
00:04:57.486 --> 00:04:59.916 A:middle
And this gives us
a nice balance.

97
00:04:59.916 --> 00:05:02.336 A:middle
It means that we can
express the notion of nil

98
00:05:03.006 --> 00:05:05.686 A:middle
and you can test it against
nil to do those checks.

99
00:05:06.426 --> 00:05:09.656 A:middle
However, you can also just
directly access properties

100
00:05:09.656 --> 00:05:12.346 A:middle
or directly call a method
of it, or you can convert it

101
00:05:12.346 --> 00:05:14.786 A:middle
down to NSNil, and we'll unwrap

102
00:05:14.936 --> 00:05:17.116 A:middle
that optional object
automatically

103
00:05:17.116 --> 00:05:17.976 A:middle
for you doing the checking.

104
00:05:18.046 --> 00:05:21.976 A:middle
So it's a fairly syntactically
lightweight way of dealing

105
00:05:21.976 --> 00:05:26.786 A:middle
with nil in a language where nil
is a much more explicit entity

106
00:05:27.376 --> 00:05:28.006 A:middle
like in Swift.

107
00:05:29.406 --> 00:05:32.976 A:middle
Let's look at another property.

108
00:05:33.096 --> 00:05:35.396 A:middle
So here we have the fileType
property that's in NSString.

109
00:05:36.676 --> 00:05:42.456 A:middle
This is going to come into
Swift as a native Swift string.

110
00:05:43.196 --> 00:05:45.636 A:middle
Now, again, we have the
implicitly unwrapped optional

111
00:05:45.636 --> 00:05:47.876 A:middle
here so that nil can be passed

112
00:05:47.876 --> 00:05:50.866 A:middle
through since String doesn't
have a notion of nil inside it.

113
00:05:52.446 --> 00:05:55.106 A:middle
And there's a number
of Objective-C types

114
00:05:55.286 --> 00:05:58.056 A:middle
that get mapped slightly
differently into Swift.

115
00:05:58.776 --> 00:06:01.846 A:middle
So there's some very, very
fundamental types like BOOL

116
00:06:01.896 --> 00:06:07.036 A:middle
and NSInteger that map into the
Bool and Int types within Swift.

117
00:06:07.256 --> 00:06:08.846 A:middle
So we're working
all the Swift types.

118
00:06:09.636 --> 00:06:12.706 A:middle
There's id and Class
which we're very familiar

119
00:06:12.706 --> 00:06:14.396 A:middle
with in Objective-C.

120
00:06:14.676 --> 00:06:18.196 A:middle
These map over to AnyObject and
AnyClass, something we're going

121
00:06:18.196 --> 00:06:19.346 A:middle
to talk about in a
couple of minutes.

122
00:06:20.366 --> 00:06:22.746 A:middle
And we also have the core
Cocoa types that are bridged

123
00:06:22.746 --> 00:06:24.846 A:middle
like NSString and
NSArray mapping

124
00:06:24.846 --> 00:06:26.586 A:middle
to their Swift native
equivalents.

125
00:06:26.776 --> 00:06:28.616 A:middle
Again, we'll talk about
that later in this talk.

126
00:06:29.956 --> 00:06:31.106 A:middle
Let's take a look at Methods.

127
00:06:32.346 --> 00:06:34.316 A:middle
There's an Objective-C
Method file name extension

128
00:06:34.316 --> 00:06:35.796 A:middle
for Type, saveOperation.

129
00:06:36.356 --> 00:06:39.796 A:middle
It comes into Swift here
as, again, a method.

130
00:06:40.906 --> 00:06:43.946 A:middle
Now, one important thing
to know here is that all

131
00:06:43.946 --> 00:06:47.596 A:middle
of the selector pieces from
the Objective-C Method are here

132
00:06:47.666 --> 00:06:49.926 A:middle
in the Methods signature
in Swift.

133
00:06:50.556 --> 00:06:53.236 A:middle
The first selector piece has
become the so-called base name

134
00:06:53.236 --> 00:06:53.846 A:middle
of the Method.

135
00:06:54.436 --> 00:06:56.816 A:middle
The second selector
piece, SaveOperation,

136
00:06:57.226 --> 00:07:00.576 A:middle
has become a label on
the second argument.

137
00:07:01.966 --> 00:07:05.046 A:middle
A really important thing
here is that these labels

138
00:07:05.306 --> 00:07:08.846 A:middle
and their Order are
enforced at the call site.

139
00:07:09.656 --> 00:07:13.026 A:middle
So, you must call it as
fileNameExtensionForType,

140
00:07:13.266 --> 00:07:15.746 A:middle
saveOperation, just
like you do in Cocoa

141
00:07:16.036 --> 00:07:18.236 A:middle
with the exact same
ordering, so to preserve

142
00:07:18.506 --> 00:07:21.416 A:middle
that nice readability from
Cocoa that we all know and love.

143
00:07:23.466 --> 00:07:26.516 A:middle
Now the other thing to know
here is the consistency here

144
00:07:26.516 --> 00:07:27.296 A:middle
on the Swift side.

145
00:07:28.496 --> 00:07:31.106 A:middle
All of the names and the
colons and the parentheses

146
00:07:31.106 --> 00:07:33.586 A:middle
and the commas are in
exactly the same places

147
00:07:34.166 --> 00:07:37.206 A:middle
in the declaration of
the Method in the middle

148
00:07:37.676 --> 00:07:39.946 A:middle
and in the call site of
the Method at the bottom.

149
00:07:39.946 --> 00:07:41.846 A:middle
So the kind of consistency
we like out

150
00:07:41.846 --> 00:07:43.196 A:middle
of building a new language.

151
00:07:43.196 --> 00:07:47.296 A:middle
Let's look at a little bit
more complicated method here

152
00:07:47.296 --> 00:07:48.646 A:middle
where we have some
blocks going on,

153
00:07:48.646 --> 00:07:51.506 A:middle
some more interesting things,
and map that into Swift.

154
00:07:52.326 --> 00:07:54.556 A:middle
And here there are two different
things I want to talk about.

155
00:07:54.596 --> 00:07:58.496 A:middle
The first thing I want to
talk about is the naming

156
00:07:58.586 --> 00:08:02.096 A:middle
of these argument labels and
the internal parameter names.

157
00:08:02.676 --> 00:08:05.816 A:middle
So here in Objective-C you
always have a selector piece

158
00:08:06.556 --> 00:08:07.586 A:middle
goes before the colon.

159
00:08:07.976 --> 00:08:09.236 A:middle
And then you have
the name of the --

160
00:08:09.236 --> 00:08:11.606 A:middle
at the internal parameter
that you use

161
00:08:11.606 --> 00:08:14.196 A:middle
when you're defining the
method in your Dot M File.

162
00:08:14.406 --> 00:08:17.416 A:middle
In Objective-C you always
have to write both of these,

163
00:08:17.416 --> 00:08:19.536 A:middle
of course, and many
times they're the same.

164
00:08:19.536 --> 00:08:20.696 A:middle
So you have some redundancy.

165
00:08:21.316 --> 00:08:24.566 A:middle
We do a little bit of syntax
optimization here in Swift,

166
00:08:24.566 --> 00:08:25.866 A:middle
so you just write the name once.

167
00:08:26.236 --> 00:08:28.996 A:middle
It serves both as the label
and the internal name.

168
00:08:29.906 --> 00:08:32.525 A:middle
If you want those names
to be different, fine,

169
00:08:32.525 --> 00:08:33.576 A:middle
we can handle that, too.

170
00:08:33.706 --> 00:08:35.416 A:middle
You just write the two
names next to each other.

171
00:08:35.626 --> 00:08:37.816 A:middle
The first one is the label
because that's what's important

172
00:08:37.816 --> 00:08:38.996 A:middle
for the caller to use.

173
00:08:39.616 --> 00:08:42.376 A:middle
And then the second one is the
internal name that you're going

174
00:08:42.376 --> 00:08:44.896 A:middle
to use within the
implementation of your Method.

175
00:08:46.366 --> 00:08:50.106 A:middle
The next thing I want to
point out here is the Block.

176
00:08:51.436 --> 00:08:54.596 A:middle
So here we have a Method
that takes a Block,

177
00:08:55.126 --> 00:08:59.716 A:middle
and Blocks in Objective-C get
mapped into Closures in Swift.

178
00:09:00.566 --> 00:09:03.316 A:middle
You see, again, this is an
implicitly unwrapped optional

179
00:09:03.536 --> 00:09:05.936 A:middle
so that you can pass
a nil Block in here.

180
00:09:07.486 --> 00:09:08.806 A:middle
Now the really great thing

181
00:09:09.076 --> 00:09:13.036 A:middle
about getting Objective-C Blocks
mapped into Swift Closures is

182
00:09:13.036 --> 00:09:16.316 A:middle
that we get all of the great
closure syntax that is provided

183
00:09:16.316 --> 00:09:18.766 A:middle
by Swift including
trailing closures

184
00:09:18.986 --> 00:09:20.826 A:middle
when your block is
the last parameter.

185
00:09:21.356 --> 00:09:23.816 A:middle
So all of your block spaced
APIs that you've written,

186
00:09:23.886 --> 00:09:26.526 A:middle
all the ones from Cocoa, when
they're following the convention

187
00:09:26.526 --> 00:09:30.736 A:middle
of putting the block last get
this nice trailing closure

188
00:09:30.736 --> 00:09:31.736 A:middle
syntax in Swift.

189
00:09:32.166 --> 00:09:37.026 A:middle
Let's talk a little
bit about Initializers.

190
00:09:38.626 --> 00:09:41.796 A:middle
So in Objective-C
we have init methods

191
00:09:42.576 --> 00:09:46.506 A:middle
and init methods have a lot of
conventions built around them.

192
00:09:47.036 --> 00:09:48.376 A:middle
They start with the word "init."

193
00:09:49.046 --> 00:09:51.016 A:middle
They should be returning
instance type,

194
00:09:51.546 --> 00:09:52.966 A:middle
although that's a
fairly new invention.

195
00:09:52.966 --> 00:09:54.746 A:middle
So sometimes they're
still returning ID.

196
00:09:56.206 --> 00:09:58.036 A:middle
And when you're implementing
these things,

197
00:09:58.036 --> 00:09:59.356 A:middle
you have a lot of requirements.

198
00:09:59.356 --> 00:09:59.966 A:middle
You need to call "super init."

199
00:10:00.046 --> 00:10:01.896 A:middle
You need to reassign "self."

200
00:10:01.896 --> 00:10:03.996 A:middle
You need to check "self,"
you need to return "self."

201
00:10:05.926 --> 00:10:09.666 A:middle
So all of the screams, we
need something formalized

202
00:10:09.696 --> 00:10:10.506 A:middle
in the language.

203
00:10:10.536 --> 00:10:13.476 A:middle
And so Swift has this
notion of Initializers.

204
00:10:13.906 --> 00:10:18.236 A:middle
And we import Objective-C Init
Methods as Swift Initializers.

205
00:10:19.206 --> 00:10:21.696 A:middle
How do we get from the
top Objective-C code

206
00:10:21.696 --> 00:10:23.016 A:middle
to the Swift code in the bottom?

207
00:10:23.526 --> 00:10:27.436 A:middle
Well, we find the init,
so we match the init name

208
00:10:27.436 --> 00:10:28.916 A:middle
and the camel case string here.

209
00:10:28.916 --> 00:10:31.586 A:middle
We actually look forward
a little bit to see

210
00:10:31.586 --> 00:10:34.546 A:middle
if it's really initWith
because that's extremely common.

211
00:10:34.986 --> 00:10:37.756 A:middle
And then we take the
rest of that Selector,

212
00:10:37.846 --> 00:10:39.826 A:middle
and lower-case the
first character in it,

213
00:10:40.146 --> 00:10:43.666 A:middle
and turn that into an argument
label for the Swift Initializer.

214
00:10:44.976 --> 00:10:45.866 A:middle
Now, why do we do this?

215
00:10:45.866 --> 00:10:47.736 A:middle
Well, let's look at
how we build objects

216
00:10:47.736 --> 00:10:49.996 A:middle
in Objective-C versus in Swift.

217
00:10:50.566 --> 00:10:54.196 A:middle
So in Objective-C you do
an alloc on your class

218
00:10:54.386 --> 00:10:58.256 A:middle
and then you immediately
send it an init message

219
00:10:58.386 --> 00:10:59.556 A:middle
to initialize the Object.

220
00:10:59.846 --> 00:11:02.246 A:middle
These two steps are
almost never separated.

221
00:11:02.866 --> 00:11:07.376 A:middle
Now in Swift we have
our Initializers

222
00:11:07.856 --> 00:11:11.116 A:middle
and we use this Unified
Object Construction syntax

223
00:11:11.386 --> 00:11:13.176 A:middle
where we write the
name of the Class

224
00:11:13.536 --> 00:11:16.346 A:middle
and then we pass arguments
directly to the Initializer.

225
00:11:16.916 --> 00:11:20.626 A:middle
And notice here, we're using the
Argument Label of FileURL to say

226
00:11:20.626 --> 00:11:22.786 A:middle
which Initializer
we're actually using

227
00:11:23.146 --> 00:11:24.316 A:middle
and then give it the argument.

228
00:11:25.046 --> 00:11:27.556 A:middle
And, of course, we folded the
al loc and the init together

229
00:11:27.556 --> 00:11:29.906 A:middle
in this one nice syntax
that also happens to work

230
00:11:29.906 --> 00:11:32.786 A:middle
for all other types of in Swift
where they be structs or enums.

231
00:11:33.336 --> 00:11:38.186 A:middle
Okay. So let's talk
about Factory Methods

232
00:11:38.226 --> 00:11:40.026 A:middle
because this is the other way

233
00:11:40.176 --> 00:11:42.376 A:middle
that we build Objects
in Objective-C.

234
00:11:42.816 --> 00:11:44.746 A:middle
So here we have something
from UIColor.

235
00:11:44.746 --> 00:11:46.106 A:middle
I've stepped away
from UIDocument.

236
00:11:46.106 --> 00:11:48.316 A:middle
And they've colorwithRed
blue green alpha.

237
00:11:48.726 --> 00:11:50.366 A:middle
And, of course, we
can go and construct

238
00:11:50.366 --> 00:11:55.366 A:middle
that by calling UIColor
colorwithRed green blue alpha.

239
00:11:55.616 --> 00:11:58.206 A:middle
All of this can be
directly imported in Swift.

240
00:11:58.646 --> 00:12:01.496 A:middle
It would just be a Class
Method, colorwithRed

241
00:12:01.496 --> 00:12:04.406 A:middle
and green blue alpha
as argument labels,

242
00:12:04.846 --> 00:12:07.456 A:middle
and we could just
call it on the class.

243
00:12:08.396 --> 00:12:09.286 A:middle
This would be fine.

244
00:12:09.286 --> 00:12:10.876 A:middle
However, we don't really love

245
00:12:10.876 --> 00:12:12.626 A:middle
that they're two
completely different kinds

246
00:12:12.626 --> 00:12:13.626 A:middle
of initialization.

247
00:12:14.916 --> 00:12:19.496 A:middle
So we recognize the
common patterns

248
00:12:19.496 --> 00:12:22.066 A:middle
in how Factory Methods are
described in Objective-C,

249
00:12:22.236 --> 00:12:24.786 A:middle
and bring them in as
Swift Initializers.

250
00:12:25.976 --> 00:12:27.906 A:middle
And the really great
thing here is we get

251
00:12:27.906 --> 00:12:31.416 A:middle
that common Initialization
Syntax for all

252
00:12:31.416 --> 00:12:32.816 A:middle
of these Objective-C APIs.

253
00:12:33.266 --> 00:12:35.396 A:middle
You don't have to think is
there an init method for this

254
00:12:35.396 --> 00:12:38.156 A:middle
or is there a class
method for this?

255
00:12:39.046 --> 00:12:40.486 A:middle
It's there as an Initializer.

256
00:12:43.176 --> 00:12:43.956 A:middle
Do you like that?

257
00:12:44.516 --> 00:12:49.026 A:middle
[ Applause ]

258
00:12:49.526 --> 00:12:51.166 A:middle
Let's go a little
bit down the stack

259
00:12:51.586 --> 00:12:52.856 A:middle
and let's talk about Enums.

260
00:12:54.006 --> 00:12:56.826 A:middle
So here's the
UIDocumentSaveOperation Enum

261
00:12:57.186 --> 00:12:58.556 A:middle
as defined in Objective-C.

262
00:12:59.646 --> 00:13:02.666 A:middle
And if we look at this we see
a whole lot of redundancy.

263
00:13:03.416 --> 00:13:06.646 A:middle
This UIDocumentSave
prefix is used for the enum

264
00:13:06.916 --> 00:13:09.136 A:middle
and for both of its enum values.

265
00:13:10.066 --> 00:13:10.986 A:middle
Why is this?

266
00:13:10.986 --> 00:13:12.436 A:middle
Well, this is C.

267
00:13:13.236 --> 00:13:16.896 A:middle
The enum values in C are
in a global namespace.

268
00:13:17.276 --> 00:13:20.386 A:middle
We can't call these enum
values just ForCreating

269
00:13:20.386 --> 00:13:22.456 A:middle
and ForOverwriting because
that's going to stomp

270
00:13:22.456 --> 00:13:25.016 A:middle
on some other completely
different enumeration somewhere

271
00:13:25.016 --> 00:13:27.546 A:middle
else in the system
and cause havoc.

272
00:13:28.396 --> 00:13:31.456 A:middle
So we do this common
prefix by convention.

273
00:13:31.496 --> 00:13:33.506 A:middle
It helps Code Completion
find the right thing.

274
00:13:33.506 --> 00:13:37.196 A:middle
But when we're talking about
Swift, it's also a great cue

275
00:13:37.196 --> 00:13:38.776 A:middle
for us that we can do better.

276
00:13:39.376 --> 00:13:44.246 A:middle
And so we can import
this NS underscore Enum

277
00:13:44.246 --> 00:13:46.876 A:middle
as a [inaudible] chopping off
all of those common prefixes

278
00:13:47.116 --> 00:13:49.396 A:middle
to get us nice short
names for the cases.

279
00:13:50.886 --> 00:13:54.126 A:middle
Now the reason we can do this
is because the enum cases

280
00:13:54.126 --> 00:13:57.446 A:middle
in Swift are scoped within
the enum type itself.

281
00:13:58.016 --> 00:14:02.026 A:middle
How does this play
out in actual code?

282
00:14:02.596 --> 00:14:04.656 A:middle
Well, okay, if we call
fileNameExtensionForType

283
00:14:04.656 --> 00:14:08.606 A:middle
saveOperation we can refer
to, say for creating,

284
00:14:09.306 --> 00:14:12.216 A:middle
with its fully dotted
name -- class name.enum,

285
00:14:12.216 --> 00:14:13.996 A:middle
the same dotted syntax we use

286
00:14:14.146 --> 00:14:16.686 A:middle
for a number of anything
in Swift.

287
00:14:17.896 --> 00:14:19.626 A:middle
But Swift has type inference.

288
00:14:20.496 --> 00:14:23.426 A:middle
We know that this method takes
the UIDocumentSaveOperation,

289
00:14:23.536 --> 00:14:25.446 A:middle
so there's absolutely
no reason to write that.

290
00:14:25.756 --> 00:14:27.626 A:middle
You can just pass .ForCreating

291
00:14:27.626 --> 00:14:30.546 A:middle
and we will infer the
enum type from that.

292
00:14:36.046 --> 00:14:38.426 A:middle
I'd also like to
talk about NSError.

293
00:14:39.276 --> 00:14:43.086 A:middle
So this is our pattern in
Cocoa for dealing with errors.

294
00:14:43.676 --> 00:14:45.846 A:middle
And so there are many
methods throughout Cocoa

295
00:14:45.846 --> 00:14:49.776 A:middle
and throughout your own apps
that take an NSError star star,

296
00:14:49.906 --> 00:14:53.266 A:middle
and that's a C pointer
to an NSError object.

297
00:14:53.896 --> 00:14:57.076 A:middle
We bring this in with a
special type in Swift.

298
00:14:57.166 --> 00:14:58.216 A:middle
In fact, if you type alias

299
00:14:58.216 --> 00:15:01.896 A:middle
for a much longer type
name call NSErrorPointer.

300
00:15:03.026 --> 00:15:03.356 A:middle
We're going

301
00:15:03.356 --> 00:15:05.976 A:middle
to see NSErrorPointer
twice in this talk.

302
00:15:06.826 --> 00:15:08.846 A:middle
For now we're going to
talk about how to use it

303
00:15:09.356 --> 00:15:11.326 A:middle
when we're calling into the API.

304
00:15:13.036 --> 00:15:15.646 A:middle
And it's not actually all that
much different from Objective-C.

305
00:15:16.506 --> 00:15:20.506 A:middle
So, if we bring this up, we
declare a local variable.

306
00:15:20.936 --> 00:15:22.026 A:middle
It's called error.

307
00:15:22.096 --> 00:15:24.036 A:middle
It's a type NSError optional.

308
00:15:24.996 --> 00:15:27.566 A:middle
And we pass its address
in when we're calling

309
00:15:27.566 --> 00:15:28.766 A:middle
contentsForType Error.

310
00:15:30.076 --> 00:15:32.816 A:middle
And so in this code we check
whether we're getting back some

311
00:15:32.816 --> 00:15:33.826 A:middle
contents from this.

312
00:15:34.726 --> 00:15:36.106 A:middle
Then we can deal
with those contents.

313
00:15:36.736 --> 00:15:39.446 A:middle
If we fail to find any contents
well, we probably have an error.

314
00:15:39.446 --> 00:15:42.056 A:middle
So we can go unwrap
that optional error

315
00:15:42.356 --> 00:15:43.726 A:middle
and present it to the user.

316
00:15:44.126 --> 00:15:46.626 A:middle
And if we fall through the
else here now we're in trouble

317
00:15:46.626 --> 00:15:49.256 A:middle
because something failed and we
have nothing we can do about it.

318
00:15:49.906 --> 00:15:52.476 A:middle
We hope that doesn't happen.

319
00:15:52.686 --> 00:15:55.456 A:middle
But this is the pattern
you'll be using when dealing

320
00:15:55.456 --> 00:15:57.026 A:middle
with NSError in Swift.

321
00:15:57.296 --> 00:16:00.176 A:middle
If you truly don't care about
the error you can also pass nil.

322
00:16:01.656 --> 00:16:04.916 A:middle
So we've walked through
a lot of little pieces

323
00:16:05.356 --> 00:16:08.446 A:middle
of the Objective-C
Mapping into Swift.

324
00:16:08.446 --> 00:16:11.306 A:middle
And there are a lot of
rules that we've talked

325
00:16:11.306 --> 00:16:13.016 A:middle
about that you're certainly
not going to remember.

326
00:16:14.166 --> 00:16:15.196 A:middle
That's perfectly fine.

327
00:16:15.366 --> 00:16:16.506 A:middle
XCode has your back here.

328
00:16:17.226 --> 00:16:18.466 A:middle
Use the tools to help you.

329
00:16:19.026 --> 00:16:21.346 A:middle
So if you're in XCode,
you're in some Swift Code,

330
00:16:21.346 --> 00:16:23.636 A:middle
you can CommandClick
on a class name.

331
00:16:23.886 --> 00:16:25.956 A:middle
And we'll show you
the Swift projection

332
00:16:26.276 --> 00:16:28.096 A:middle
of the underlying
Objective-C Class.

333
00:16:28.896 --> 00:16:31.046 A:middle
So take your favorite
Cocoa Class and look

334
00:16:31.046 --> 00:16:33.176 A:middle
at how it maps into Swift.

335
00:16:33.566 --> 00:16:35.616 A:middle
Get a feel for the
language, an intuitive feel

336
00:16:35.616 --> 00:16:38.806 A:middle
for how these languages
work together and you'll get

337
00:16:38.806 --> 00:16:40.336 A:middle
into Swift really fast.

338
00:16:41.126 --> 00:16:43.956 A:middle
And the great thing
is, all of these tools,

339
00:16:44.166 --> 00:16:47.016 A:middle
all the rules I've talked
about, apply equally

340
00:16:47.016 --> 00:16:50.976 A:middle
to any Objective-C API
when it comes into Swift.

341
00:16:51.416 --> 00:16:52.636 A:middle
It doesn't matter if it's Cocoa.

342
00:16:52.636 --> 00:16:53.776 A:middle
It doesn't matter if
it's your own API.

343
00:16:54.256 --> 00:16:58.876 A:middle
The same rules apply, and you
can view your own Objective-C

344
00:16:58.956 --> 00:17:01.186 A:middle
APIs in Swift to get
to know them better.

345
00:17:02.246 --> 00:17:05.146 A:middle
Now this works best
when you're following

346
00:17:05.175 --> 00:17:07.136 A:middle
"modern" Objective-C practices.

347
00:17:07.705 --> 00:17:11.935 A:middle
So these are using features
like Properties, instancetype,

348
00:17:12.726 --> 00:17:15.036 A:middle
marking your enumerations
with NS underscore Enumer

349
00:17:15.036 --> 00:17:17.866 A:middle
and it Options to describe
more semantic information

350
00:17:17.866 --> 00:17:20.366 A:middle
about what these enums
actually mean in C.

351
00:17:21.616 --> 00:17:23.276 A:middle
We've also introduced NS
underscore DESIGNATED underscore

352
00:17:23.276 --> 00:17:27.086 A:middle
INITIALIZER this year to mark
your designated Initializers

353
00:17:27.606 --> 00:17:29.546 A:middle
and formalize a Designated
Initializer pattern,

354
00:17:29.546 --> 00:17:31.676 A:middle
both in Objective-C
through additional warnings,

355
00:17:32.306 --> 00:17:35.486 A:middle
and as the initialization
model for Swift.

356
00:17:36.736 --> 00:17:39.176 A:middle
So, of course, we want
you to follow all of these

357
00:17:39.176 --> 00:17:42.496 A:middle
"modern" Objective-C
practices but we don't want you

358
00:17:42.496 --> 00:17:43.296 A:middle
to have to go it alone.

359
00:17:44.046 --> 00:17:47.316 A:middle
And so this year we introduced
the Objective-C Modernizer

360
00:17:47.776 --> 00:17:50.296 A:middle
that helps find these
cases in your code

361
00:17:50.596 --> 00:17:53.376 A:middle
where we could possible
modernize them to work

362
00:17:53.376 --> 00:17:55.496 A:middle
with all these "modern"
Objective-C features

363
00:17:55.786 --> 00:17:57.876 A:middle
and give you a better
projection into Swift.

364
00:17:58.426 --> 00:18:00.696 A:middle
And that Modernizer is
discussed in the "What's New

365
00:18:00.696 --> 00:18:02.666 A:middle
in LLVM" talk earlier today.

366
00:18:03.296 --> 00:18:05.076 A:middle
Highly recommend you catch
it on video if you missed it.

367
00:18:05.586 --> 00:18:12.056 A:middle
With that, let's talk about id.

368
00:18:13.766 --> 00:18:15.176 A:middle
What is id in Objective-C?

369
00:18:15.736 --> 00:18:19.576 A:middle
It's kind of a placeholder
in some sense.

370
00:18:19.766 --> 00:18:21.596 A:middle
It means, I have a value.

371
00:18:22.016 --> 00:18:25.066 A:middle
I know it's an object
but I don't know

372
00:18:25.066 --> 00:18:28.686 A:middle
or I don't care what the
static type of that object is.

373
00:18:29.096 --> 00:18:30.996 A:middle
It's going to vary at
runtime most likely.

374
00:18:31.766 --> 00:18:34.026 A:middle
And there's a couple
of core operations

375
00:18:34.026 --> 00:18:35.316 A:middle
that you can perform on id.

376
00:18:35.316 --> 00:18:38.216 A:middle
You can do Upcasting on it.

377
00:18:38.296 --> 00:18:41.996 A:middle
So, if I have this
variable object of type id,

378
00:18:42.366 --> 00:18:44.416 A:middle
I can put an NSURL into it.

379
00:18:45.406 --> 00:18:48.376 A:middle
Later I can go reassign it
and I can put an UIVIEW in it.

380
00:18:48.736 --> 00:18:49.646 A:middle
That's perfectly fine.

381
00:18:49.806 --> 00:18:52.626 A:middle
They can both be upcasted
essentially to id.

382
00:18:52.806 --> 00:18:53.596 A:middle
They're both objects.

383
00:18:54.536 --> 00:18:57.796 A:middle
I can do Message sends
to id just directly

384
00:18:57.796 --> 00:18:58.816 A:middle
by doing a Message Send.

385
00:18:59.206 --> 00:19:02.786 A:middle
I can subscript an id
if I really feel like.

386
00:19:03.516 --> 00:19:08.546 A:middle
In Swift, any object is
the equivalent to id.

387
00:19:08.546 --> 00:19:12.386 A:middle
And it provides these
same core operations --

388
00:19:12.636 --> 00:19:15.576 A:middle
Upcasting, Message
Sends, Subscripting --

389
00:19:15.876 --> 00:19:17.736 A:middle
that you can do on
id in Objective-C.

390
00:19:17.736 --> 00:19:23.316 A:middle
Now one of the things we know
from using id in Objective-C is

391
00:19:23.316 --> 00:19:25.636 A:middle
that you sometimes have
to be a little bit careful

392
00:19:26.906 --> 00:19:28.816 A:middle
because if you send a
message to an object

393
00:19:29.386 --> 00:19:31.256 A:middle
that doesn't have a
corresponding method,

394
00:19:31.446 --> 00:19:33.036 A:middle
you're going to get
a runtime failure

395
00:19:33.036 --> 00:19:34.866 A:middle
that this is an unrecognized
selector.

396
00:19:35.916 --> 00:19:37.976 A:middle
Now in Objective-C we
have an answer for this.

397
00:19:38.456 --> 00:19:40.476 A:middle
Using this respondsToSelector
idiom.

398
00:19:40.966 --> 00:19:44.186 A:middle
Do an if. Check whether it
respondsToSelector, then do it.

399
00:19:45.356 --> 00:19:47.556 A:middle
In Swift we like to do
a little bit better.

400
00:19:48.556 --> 00:19:51.046 A:middle
So let's take the
same call and let's

401
00:19:51.046 --> 00:19:53.076 A:middle
to a removeFromSuperview
call on this object.

402
00:19:54.506 --> 00:19:59.216 A:middle
And the thing to note here
is that removeFromSuperview

403
00:19:59.836 --> 00:20:02.576 A:middle
on an object of unknown type,

404
00:20:02.946 --> 00:20:04.976 A:middle
it may be there, it
may not be there.

405
00:20:06.226 --> 00:20:07.876 A:middle
Well, how do we deal with
this notion in Swift?

406
00:20:08.246 --> 00:20:11.406 A:middle
We use an "optional" that says
there may be a value there;

407
00:20:11.496 --> 00:20:12.226 A:middle
there may not be.

408
00:20:12.566 --> 00:20:14.726 A:middle
And so the reference
to removeFromSuperview

409
00:20:14.726 --> 00:20:17.086 A:middle
on object is in effect optional.

410
00:20:17.506 --> 00:20:20.936 A:middle
That means we can use the
optional Chaining Operator here

411
00:20:21.886 --> 00:20:22.026 A:middle
to --

412
00:20:23.516 --> 00:20:29.066 A:middle
[ Applause ]

413
00:20:29.566 --> 00:20:30.616 A:middle
What we're doing, of course,

414
00:20:30.806 --> 00:20:33.266 A:middle
is we're folding the
response ToSelector check in,

415
00:20:33.696 --> 00:20:36.566 A:middle
so we do the reference, go
look for RemoveFromSuperview.

416
00:20:36.976 --> 00:20:39.126 A:middle
If it's there, go on, call it.

417
00:20:39.886 --> 00:20:42.176 A:middle
If it's not there, stop
evaluating this expression.

418
00:20:42.176 --> 00:20:42.536 A:middle
We're done.

419
00:20:44.276 --> 00:20:47.156 A:middle
Now, something that id does

420
00:20:47.156 --> 00:20:50.496 A:middle
that AnyObject does not
do is implicitly downcast.

421
00:20:50.816 --> 00:20:54.316 A:middle
So I have Object, is a type
AnyObject, and I'm trying

422
00:20:54.316 --> 00:20:56.486 A:middle
to assign it into a UIView.

423
00:20:57.506 --> 00:20:59.166 A:middle
This is going to
produce a compiler error

424
00:20:59.166 --> 00:21:01.786 A:middle
because this is a
unsafe downcast.

425
00:21:02.276 --> 00:21:05.146 A:middle
How do we deal with this?

426
00:21:05.236 --> 00:21:06.666 A:middle
Well, there's really
two cases here that need

427
00:21:06.666 --> 00:21:07.866 A:middle
that you need to think about.

428
00:21:08.536 --> 00:21:12.796 A:middle
One case is, I know it's a
UIView but for some reason

429
00:21:12.796 --> 00:21:15.496 A:middle
that strong type information
got lost when going

430
00:21:15.496 --> 00:21:16.626 A:middle
through some API somewhere.

431
00:21:17.226 --> 00:21:19.126 A:middle
If I know for sure
it's a UIView,

432
00:21:19.456 --> 00:21:21.716 A:middle
I can use the cast
operation "as"

433
00:21:22.476 --> 00:21:25.066 A:middle
to say treat this
object as a UIView.

434
00:21:26.466 --> 00:21:29.326 A:middle
We're going to do these kind
of class check at run time

435
00:21:29.326 --> 00:21:31.196 A:middle
to make sure that's
absolutely true.

436
00:21:31.836 --> 00:21:36.336 A:middle
But the types [inaudible]
believe you at this point.

437
00:21:36.516 --> 00:21:40.976 A:middle
Now if you don't know whether
this object is a UIView

438
00:21:40.976 --> 00:21:42.906 A:middle
or not, you can use the "as?"

439
00:21:43.036 --> 00:21:45.976 A:middle
to perform a conditional
downcast.

440
00:21:46.516 --> 00:21:52.606 A:middle
[ Applause ]

441
00:21:53.106 --> 00:21:54.286 A:middle
Think you guys have
figured it out?

442
00:21:54.286 --> 00:21:57.476 A:middle
But just to be sure, this is
doing is kind of class check.

443
00:21:57.476 --> 00:22:00.936 A:middle
And it's wrapping the result
in an optional UIView.

444
00:22:01.756 --> 00:22:03.336 A:middle
It's nil if the check failed.

445
00:22:03.636 --> 00:22:06.426 A:middle
It has the UIView if
the check succeeded.

446
00:22:06.826 --> 00:22:08.256 A:middle
We can do an if let here

447
00:22:08.676 --> 00:22:10.986 A:middle
to completely do this
entire thing safely,

448
00:22:11.336 --> 00:22:13.896 A:middle
and view in here is the
UIView we were looking for.

449
00:22:15.276 --> 00:22:17.886 A:middle
So let's take a little
bit of detour and talk

450
00:22:17.886 --> 00:22:19.366 A:middle
about tiny bit of protocols.

451
00:22:19.836 --> 00:22:24.026 A:middle
Here's an Objective-C Protocol
for a UITableViewDataSource

452
00:22:24.536 --> 00:22:27.426 A:middle
and its Swift equivalent.

453
00:22:27.786 --> 00:22:31.496 A:middle
Not a whole lot new here.

454
00:22:31.706 --> 00:22:33.866 A:middle
But there are two things that
I do I want to point out.

455
00:22:33.926 --> 00:22:38.076 A:middle
The first thing I want to point
out is optional and required.

456
00:22:38.546 --> 00:22:39.856 A:middle
So in Objective-C optional

457
00:22:39.856 --> 00:22:42.406 A:middle
and required are essentially
modes in the protocol.

458
00:22:42.916 --> 00:22:44.826 A:middle
You say at optional,
and everything

459
00:22:44.826 --> 00:22:48.036 A:middle
that follows is optional up
until the point where you hit an

460
00:22:48.036 --> 00:22:50.066 A:middle
at required and then
everything is required.

461
00:22:50.836 --> 00:22:54.426 A:middle
And we're not totally thrilled
with this decision now.

462
00:22:54.976 --> 00:22:56.996 A:middle
And the basic reason is
that you can't just look

463
00:22:56.996 --> 00:22:59.126 A:middle
at one single declaration
in the protocol

464
00:22:59.126 --> 00:23:00.846 A:middle
and know whether it's
optional or required.

465
00:23:00.846 --> 00:23:03.636 A:middle
You have to go scan up
your protocol to find it.

466
00:23:04.006 --> 00:23:06.056 A:middle
And so we did something a
little bit different in Swift

467
00:23:06.756 --> 00:23:10.876 A:middle
in that requirements in
Protocol are required

468
00:23:10.876 --> 00:23:12.506 A:middle
by default in Swift.

469
00:23:12.806 --> 00:23:15.326 A:middle
If you want to make them
optional, then tag them

470
00:23:15.326 --> 00:23:17.596 A:middle
with the optional attribute
to make them optional.

471
00:23:18.936 --> 00:23:20.696 A:middle
The other thing I want
to point out here.

472
00:23:21.016 --> 00:23:23.216 A:middle
We're doing a little bit
of Protocol Inheritance

473
00:23:23.916 --> 00:23:26.416 A:middle
and we're inheriting
from NSObjectProtocol.

474
00:23:28.196 --> 00:23:31.376 A:middle
So in Objective-C we would
[inaudible] have NSObject the

475
00:23:31.376 --> 00:23:34.046 A:middle
class and NSObject the protocol.

476
00:23:35.216 --> 00:23:38.716 A:middle
And they have the same name so
we have to add the "the class"

477
00:23:38.716 --> 00:23:40.746 A:middle
or "the protocol" at the
end when we talk about it.

478
00:23:41.106 --> 00:23:45.296 A:middle
The language keeps these in
syntactically distinct points

479
00:23:45.736 --> 00:23:47.456 A:middle
so the language isn't confused.

480
00:23:48.086 --> 00:23:50.606 A:middle
But in Swift we wanted
to bring all these things

481
00:23:50.606 --> 00:23:53.476 A:middle
into the same namespace because
that's far more convenient

482
00:23:53.476 --> 00:23:54.476 A:middle
for the general case.

483
00:23:54.876 --> 00:23:56.436 A:middle
And so we needed to
rename something.

484
00:23:57.056 --> 00:23:59.376 A:middle
And essentially when there's a
conflict between a class name

485
00:23:59.376 --> 00:24:01.336 A:middle
and a protocol name,
we'll append protocol

486
00:24:01.336 --> 00:24:03.286 A:middle
to the name of the protocol.

487
00:24:03.846 --> 00:24:06.286 A:middle
Why did we do this?

488
00:24:06.286 --> 00:24:10.766 A:middle
Well, let's take a look at
another use of id that we see

489
00:24:10.846 --> 00:24:14.086 A:middle
in Objective-C, and that's
protocol qualified id.

490
00:24:15.086 --> 00:24:19.426 A:middle
So this dataSource here is an
object of some unknown type.

491
00:24:20.626 --> 00:24:22.336 A:middle
But we know that
the type conforms

492
00:24:22.336 --> 00:24:24.346 A:middle
to the UITableViewDataSource
protocol.

493
00:24:25.526 --> 00:24:27.416 A:middle
We describe that a
little bit more directly

494
00:24:27.416 --> 00:24:30.056 A:middle
in the Swift language by
just saying the dataSource is

495
00:24:30.056 --> 00:24:31.486 A:middle
a UITableViewDataSource.

496
00:24:32.146 --> 00:24:33.026 A:middle
That's it.

497
00:24:33.716 --> 00:24:38.006 A:middle
Now some of you here noticed
with protocol-qualified id,

498
00:24:38.256 --> 00:24:40.766 A:middle
you can have many different
protocols if you want.

499
00:24:41.346 --> 00:24:44.836 A:middle
We can use the protocol
keyword with angle brackets

500
00:24:44.996 --> 00:24:46.396 A:middle
to describe more
than one protocol.

501
00:24:46.396 --> 00:24:49.456 A:middle
Now, one of the things we do

502
00:24:49.456 --> 00:24:52.116 A:middle
with Protocol Conformance is we
have an object of unknown type

503
00:24:52.116 --> 00:24:55.266 A:middle
and we want to determine, does
it conform to the protocol?

504
00:24:55.456 --> 00:24:57.606 A:middle
This is the conforms
to protocol check

505
00:24:57.606 --> 00:25:00.236 A:middle
in the Objective-C runtime.

506
00:25:00.356 --> 00:25:02.506 A:middle
In Swift, we do this same thing

507
00:25:03.056 --> 00:25:05.276 A:middle
with the conditional
downcast operator.

508
00:25:05.836 --> 00:25:09.106 A:middle
So we can just ask, is my object
the UITableViewDataSource,

509
00:25:09.686 --> 00:25:11.916 A:middle
conforms to protocol check,
happens in the runtime,

510
00:25:12.196 --> 00:25:15.156 A:middle
captures the results in an
optional -- here we can go --

511
00:25:15.156 --> 00:25:18.136 A:middle
easily do that, call one of the
methods and compute the number

512
00:25:18.136 --> 00:25:21.406 A:middle
of rows in the first section
of this TableViewDataSource.

513
00:25:21.916 --> 00:25:25.146 A:middle
Let's make our example a
little bit more interesting.

514
00:25:25.766 --> 00:25:28.446 A:middle
Let's compute the number of
rows in the last section.

515
00:25:29.716 --> 00:25:32.446 A:middle
So here we need to compute the
number of sections that exist

516
00:25:32.446 --> 00:25:36.936 A:middle
in the TableView, subtract 1
off of it, and then we can ask

517
00:25:36.936 --> 00:25:38.576 A:middle
for the number of
rows in that section.

518
00:25:39.076 --> 00:25:41.506 A:middle
Now there's a problem
with this code.

519
00:25:42.566 --> 00:25:45.226 A:middle
And the problem is the number
of sections in TableView,

520
00:25:45.266 --> 00:25:48.186 A:middle
as you might remember,
is an optional method.

521
00:25:48.766 --> 00:25:50.196 A:middle
It might not be there
at runtime.

522
00:25:50.886 --> 00:25:53.876 A:middle
So we're going to need to
compile error out of this

523
00:25:53.876 --> 00:25:55.706 A:middle
because we need to deal
with the optionality

524
00:25:55.706 --> 00:25:57.006 A:middle
of this protocol method.

525
00:25:57.836 --> 00:25:59.796 A:middle
And we deal with this
the same way we deal

526
00:25:59.796 --> 00:26:02.736 A:middle
with optionality everywhere
else in the Swift language,

527
00:26:03.576 --> 00:26:05.176 A:middle
using the mechanisms we have.

528
00:26:05.266 --> 00:26:08.536 A:middle
We here we're going to use the
chaining question mark operator.

529
00:26:09.416 --> 00:26:11.916 A:middle
We're checking, does my
DataSource have a number

530
00:26:11.916 --> 00:26:13.626 A:middle
of sections in TableView method?

531
00:26:14.066 --> 00:26:16.606 A:middle
If so, call it, given
the TableView,

532
00:26:16.956 --> 00:26:19.156 A:middle
and then we capture the
result in numSections

533
00:26:19.456 --> 00:26:21.226 A:middle
so we can compute the
last section number

534
00:26:21.696 --> 00:26:23.926 A:middle
and get the number of rows

535
00:26:24.026 --> 00:26:28.766 A:middle
in the last section
of our TableView.

536
00:26:29.046 --> 00:26:30.996 A:middle
That's about all we're going to
talk about with Protocols here.

537
00:26:31.716 --> 00:26:33.776 A:middle
If you're interested
in Protocols and some

538
00:26:33.776 --> 00:26:35.196 A:middle
of the amazing things
they can do,

539
00:26:35.586 --> 00:26:37.996 A:middle
there's an Advanced Swift
talk tomorrow morning.

540
00:26:38.556 --> 00:26:41.756 A:middle
It goes into more depth on
those and their interaction

541
00:26:42.296 --> 00:26:46.196 A:middle
with the generic system.

542
00:26:46.196 --> 00:26:51.646 A:middle
So, wrapping up here, AnyObject
is Swift's equivalent to id.

543
00:26:52.346 --> 00:26:53.856 A:middle
The functionality is similar.

544
00:26:53.856 --> 00:26:56.386 A:middle
The ideas are similar
and the uses are similar.

545
00:26:56.746 --> 00:26:58.706 A:middle
However, it's more
safe by default.

546
00:26:59.756 --> 00:27:02.826 A:middle
Now we didn't talk about it,
but there's also AnyClass

547
00:27:02.956 --> 00:27:06.706 A:middle
which is Swift's equivalent
to Class and has most

548
00:27:06.706 --> 00:27:07.876 A:middle
of the same behaviors.

549
00:27:08.446 --> 00:27:12.256 A:middle
Now the other thing that we've
seen is how Optionals are used

550
00:27:12.336 --> 00:27:15.656 A:middle
throughout the language to
represent dynamic checks.

551
00:27:16.276 --> 00:27:18.456 A:middle
We've taken is kind
of class checks,

552
00:27:18.826 --> 00:27:22.416 A:middle
conforms to protocol checks,
responds to selector checks,

553
00:27:22.706 --> 00:27:25.616 A:middle
and folded them all into
the notion of Optionals

554
00:27:25.616 --> 00:27:28.706 A:middle
within the language with
their optimized syntax

555
00:27:28.746 --> 00:27:31.976 A:middle
to make them easy to use and
easy to do the right thing.

556
00:27:32.526 --> 00:27:38.336 A:middle
With that, let's switch
gears a little bit and talk

557
00:27:38.336 --> 00:27:40.546 A:middle
about Bridging of
Coco Data Types.

558
00:27:41.106 --> 00:27:44.516 A:middle
Now first, let's talk a little
bit about the NativeStrings,

559
00:27:44.516 --> 00:27:46.736 A:middle
Arrays, and the Dictionaries
within Swift.

560
00:27:47.586 --> 00:27:50.006 A:middle
The goal of Swift
is to have one set

561
00:27:50.006 --> 00:27:53.296 A:middle
of general-purpose native
value types that you use

562
00:27:53.296 --> 00:27:54.456 A:middle
for nearly everything.

563
00:27:55.396 --> 00:27:57.066 A:middle
These need to be
safe by default.

564
00:27:57.066 --> 00:27:58.846 A:middle
This means [inaudible]
restricting for arrays,

565
00:27:58.846 --> 00:28:00.796 A:middle
automatic memory
management, and so on.

566
00:28:01.926 --> 00:28:04.636 A:middle
They need to have predictable
performance so that you can look

567
00:28:04.636 --> 00:28:07.176 A:middle
at code and have a sense
of how it's going to behave

568
00:28:07.176 --> 00:28:09.356 A:middle
with no surprises, how
it's going to perform.

569
00:28:10.746 --> 00:28:13.116 A:middle
And, of course, we want
arrays and dictionaries

570
00:28:13.616 --> 00:28:16.956 A:middle
to be collections and they need
to be strongly typed collections

571
00:28:16.956 --> 00:28:17.946 A:middle
that work with any type.

572
00:28:18.056 --> 00:28:19.886 A:middle
We can't limit them
just to objects

573
00:28:19.926 --> 00:28:22.486 A:middle
because sometimes you need
an array of strings or ints.

574
00:28:23.576 --> 00:28:26.746 A:middle
And we don't have a seed to
fall back to you for the cases

575
00:28:26.746 --> 00:28:27.976 A:middle
where the other tools
don't work.

576
00:28:28.416 --> 00:28:31.206 A:middle
This is it.

577
00:28:31.476 --> 00:28:34.776 A:middle
Now, to support having
this one notion of one set

578
00:28:34.776 --> 00:28:37.656 A:middle
of general purpose native value
types, we're going to bridge

579
00:28:37.656 --> 00:28:40.446 A:middle
from Cocoa's NSString,
NSArray, NSDictionary,

580
00:28:40.816 --> 00:28:42.496 A:middle
into the Swift native
equivalents.

581
00:28:44.616 --> 00:28:46.836 A:middle
So let's first talk a little bit

582
00:28:46.986 --> 00:28:49.226 A:middle
about the Native
String Type itself.

583
00:28:50.326 --> 00:28:54.146 A:middle
So, String is an efficient,
Unicode-compliant string type.

584
00:28:55.556 --> 00:28:59.356 A:middle
Core string type of Swift
has Unicode built in through

585
00:28:59.356 --> 00:29:01.056 A:middle
and through so it makes
it easy to work with.

586
00:29:01.626 --> 00:29:02.706 A:middle
We provide flexible

587
00:29:02.706 --> 00:29:06.226 A:middle
and efficient high-level
APIs to work with strings.

588
00:29:06.226 --> 00:29:08.696 A:middle
You can easily to
concatenation, searches,

589
00:29:08.816 --> 00:29:11.076 A:middle
prefix matches, sub-strings.

590
00:29:11.516 --> 00:29:14.106 A:middle
And the strings provide
value semantics

591
00:29:14.206 --> 00:29:15.716 A:middle
which makes them
easier to work with.

592
00:29:16.416 --> 00:29:21.286 A:middle
And value semantics is generally
a fairly simple notion of,

593
00:29:21.606 --> 00:29:23.476 A:middle
you know, if I have two
variables of string type,

594
00:29:24.106 --> 00:29:27.706 A:middle
modifying one of them doesn't
affect the other one, all right.

595
00:29:27.796 --> 00:29:30.436 A:middle
This is very nice for a
fundamental data type.

596
00:29:32.716 --> 00:29:35.126 A:middle
Now, of course, you can also
think of strings as a unit,

597
00:29:35.326 --> 00:29:37.026 A:middle
but you can think of
them as being composed

598
00:29:37.026 --> 00:29:39.496 A:middle
of characters which,
in fact, they are.

599
00:29:40.476 --> 00:29:44.576 A:middle
And so we can go walk over a
strings and using the for loop,

600
00:29:44.816 --> 00:29:47.196 A:middle
and get all of the
characters out of the string.

601
00:29:47.506 --> 00:29:49.596 A:middle
And you get the answer
that you would expect.

602
00:29:49.646 --> 00:29:52.806 A:middle
There are 5 characters here even
though there's no moji [assumed

603
00:29:53.596 --> 00:29:55.516 A:middle
spelling] at the end.

604
00:29:55.516 --> 00:30:01.016 A:middle
So I want to talk a little bit
about characters and code points

605
00:30:02.106 --> 00:30:03.856 A:middle
because the character
that you're getting

606
00:30:03.856 --> 00:30:04.976 A:middle
out of here is a full
Unicode character.

607
00:30:05.236 --> 00:30:09.166 A:middle
It's not a UTF-8 code
point or UTF-16 code point

608
00:30:09.166 --> 00:30:09.936 A:middle
that you have to deal with.

609
00:30:10.376 --> 00:30:12.226 A:middle
It is a Unicode character.

610
00:30:13.386 --> 00:30:14.716 A:middle
And now, one of the challenges

611
00:30:14.716 --> 00:30:18.156 A:middle
with the Unicode characters is
you really can't encode them

612
00:30:18.326 --> 00:30:21.876 A:middle
efficiently in a way
that treats a string

613
00:30:21.876 --> 00:30:24.866 A:middle
as just an array of characters.

614
00:30:25.586 --> 00:30:26.456 A:middle
It would be too large.

615
00:30:27.096 --> 00:30:28.946 A:middle
And so what you generally see is

616
00:30:28.946 --> 00:30:33.346 A:middle
that a string is encoded
as, say, UTF-8 or UTF-16.

617
00:30:34.376 --> 00:30:37.446 A:middle
But working with those
UTF-8 or UTF-16 code points,

618
00:30:37.736 --> 00:30:40.556 A:middle
that requires Unicode expertise
to get right all the time.

619
00:30:42.246 --> 00:30:44.126 A:middle
And so we made a really
interesting decision here.

620
00:30:45.336 --> 00:30:49.066 A:middle
We decided not to provide the
super low-level operations

621
00:30:49.066 --> 00:30:52.856 A:middle
like length and characterAtIndex
to let you poke directly

622
00:30:52.856 --> 00:30:55.796 A:middle
at the UTF-16 or UTF-8 code
points, or whatever is stored

623
00:30:55.796 --> 00:30:59.786 A:middle
in the string because doing
so causes big problems.

624
00:30:59.886 --> 00:31:03.876 A:middle
Instead we want you to
use the high-level APIs

625
00:31:04.186 --> 00:31:06.726 A:middle
and let the library do
the hard work of dealing

626
00:31:06.726 --> 00:31:08.516 A:middle
with all the intricacies
of Unicode.

627
00:31:09.086 --> 00:31:13.056 A:middle
Of course, there's still common
operations you want to use.

628
00:31:13.546 --> 00:31:16.836 A:middle
You may want to count the number
of characters in a string,

629
00:31:17.526 --> 00:31:19.946 A:middle
so there's this countElements
algorithm.

630
00:31:19.946 --> 00:31:23.296 A:middle
It works on any sequence
and allows you to, well,

631
00:31:23.366 --> 00:31:24.956 A:middle
just count the number
of characters of number

632
00:31:24.956 --> 00:31:27.146 A:middle
in a string, and this
produces the right answer

633
00:31:27.146 --> 00:31:29.566 A:middle
which is there are five
characters in this string.

634
00:31:30.426 --> 00:31:32.846 A:middle
Some of you will want to
work with code points, right.

635
00:31:33.336 --> 00:31:36.006 A:middle
You may be Unicode experts
and that's wonderful.

636
00:31:36.396 --> 00:31:38.206 A:middle
You can get access
to the code points.

637
00:31:38.356 --> 00:31:42.996 A:middle
There's a property UTF-16 that
give you a lazily computed view

638
00:31:42.996 --> 00:31:46.976 A:middle
on the string producing
the UTF-16 code points

639
00:31:46.976 --> 00:31:47.746 A:middle
in that string.

640
00:31:49.316 --> 00:31:53.216 A:middle
And we can go walk over
the 16-bit unsigned integer

641
00:31:53.546 --> 00:31:54.656 A:middle
code points.

642
00:31:55.096 --> 00:31:58.536 A:middle
We can print out the number of
code points here and, of course,

643
00:31:58.536 --> 00:32:03.936 A:middle
you'll get the answer 6 because
there are 6 UTF-16 code points

644
00:32:04.326 --> 00:32:04.966 A:middle
in this string.

645
00:32:06.056 --> 00:32:06.956 A:middle
The last thing I want to talk

646
00:32:06.956 --> 00:32:09.376 A:middle
about with strings
is the relationship

647
00:32:09.376 --> 00:32:11.466 A:middle
between string and NSSring.

648
00:32:12.726 --> 00:32:14.686 A:middle
So NSString has a wealth

649
00:32:14.926 --> 00:32:17.586 A:middle
of really great text
processing APIs

650
00:32:17.916 --> 00:32:19.856 A:middle
that you've probably
been using for years.

651
00:32:20.376 --> 00:32:23.886 A:middle
So we've made all those
Foundation APIs directly

652
00:32:23.886 --> 00:32:26.846 A:middle
available on the string
type, so the APIs you know

653
00:32:26.846 --> 00:32:29.506 A:middle
and love are there,
and you can use them.

654
00:32:30.716 --> 00:32:33.706 A:middle
Now in doing so, we've made
them a little bit more Swift.

655
00:32:33.706 --> 00:32:35.976 A:middle
We've tightened up the
type signatures so that

656
00:32:35.976 --> 00:32:38.996 A:middle
if you're going to split a
string into its components,

657
00:32:38.996 --> 00:32:41.826 A:middle
well, you're getting it back
in array of strings rather

658
00:32:41.826 --> 00:32:43.726 A:middle
than just an array
of something's.

659
00:32:45.596 --> 00:32:49.316 A:middle
Now you may have developed
your own categories on NSString

660
00:32:49.566 --> 00:32:51.426 A:middle
with additional functionality
that you use

661
00:32:51.426 --> 00:32:52.896 A:middle
within your own applications.

662
00:32:53.896 --> 00:32:55.946 A:middle
You can get to those
with a simple Cast.

663
00:32:56.086 --> 00:32:59.626 A:middle
So you can take a Swift String,
turn it into an NSString,

664
00:32:59.796 --> 00:33:00.926 A:middle
so this is just a conversion,

665
00:33:01.986 --> 00:33:05.046 A:middle
and then call your
NSString method.

666
00:33:05.636 --> 00:33:07.996 A:middle
If you find yourselves
doing this a lot,

667
00:33:08.696 --> 00:33:10.646 A:middle
feel free to just go ahead

668
00:33:10.646 --> 00:33:12.656 A:middle
and extend the underlying
String type.

669
00:33:12.966 --> 00:33:15.196 A:middle
Add your StringMethod,
make it a little more Swift

670
00:33:15.196 --> 00:33:17.486 A:middle
with strong type signatures,
closures if you'd like.

671
00:33:18.766 --> 00:33:22.146 A:middle
But this should help you feel
at home in Swift fairly quickly

672
00:33:22.376 --> 00:33:24.166 A:middle
and use the String type.

673
00:33:25.476 --> 00:33:29.306 A:middle
Now let's move from
String to a container.

674
00:33:29.566 --> 00:33:31.486 A:middle
Let's talk about Arrays.

675
00:33:32.376 --> 00:33:36.396 A:middle
So here we have toolbar
items that is in an NSArray.

676
00:33:37.036 --> 00:33:43.386 A:middle
That's going to come into
Swift as an Array of AnyObject.

677
00:33:44.386 --> 00:33:46.656 A:middle
Now these two types
are fairly similar.

678
00:33:47.346 --> 00:33:49.826 A:middle
You can iterate over them
and what you're going to get

679
00:33:49.826 --> 00:33:52.396 A:middle
out of it are values
of type AnyObject.

680
00:33:52.466 --> 00:33:54.646 A:middle
They're objects but you don't
know what kind of object it is.

681
00:33:55.356 --> 00:33:57.486 A:middle
You can subscript into
them and, of course,

682
00:33:57.486 --> 00:33:58.786 A:middle
you will get an AnyObject.

683
00:34:00.256 --> 00:34:04.976 A:middle
Now, in Swift, you tend to deal
in typed arrays more often.

684
00:34:05.446 --> 00:34:07.906 A:middle
And so there are
some other operations

685
00:34:07.906 --> 00:34:09.846 A:middle
that the core language
needs to provide

686
00:34:09.846 --> 00:34:11.315 A:middle
for you to make this clean.

687
00:34:12.085 --> 00:34:16.696 A:middle
So maybe I'm composing my
toolbar items into a Swift Array

688
00:34:17.176 --> 00:34:20.406 A:middle
and that Swift Array is going
to contain UIBarButtonItems.

689
00:34:20.926 --> 00:34:24.716 A:middle
That's what actually goes into
the toolbar items property.

690
00:34:25.706 --> 00:34:29.636 A:middle
I can work with that Swift
Array and then I can assign it

691
00:34:29.636 --> 00:34:31.335 A:middle
into the AnyObject Array.

692
00:34:31.335 --> 00:34:35.065 A:middle
So this is essentially doing
a safe upcast of any array

693
00:34:35.065 --> 00:34:37.636 A:middle
of ToolbarItems to any
array of AnyObjects.

694
00:34:38.456 --> 00:34:40.906 A:middle
It also happens to be
calling into Objective-C,

695
00:34:41.085 --> 00:34:43.916 A:middle
which we'll get to in a minute.

696
00:34:44.076 --> 00:34:47.366 A:middle
Now we also see the flip
side of this where we want

697
00:34:47.366 --> 00:34:49.636 A:middle
to say iterate over
all the ToolbarItems

698
00:34:50.735 --> 00:34:56.295 A:middle
in this particular new
controller and here we're going

699
00:34:56.295 --> 00:34:59.476 A:middle
to get AnyObject values and
we talked about cast earlier,

700
00:34:59.476 --> 00:35:01.226 A:middle
so we can downcast each of them.

701
00:35:01.756 --> 00:35:04.406 A:middle
This is fine but it's a little
bit on the tedious side.

702
00:35:04.766 --> 00:35:07.076 A:middle
And so we have specialized
syntax here

703
00:35:07.296 --> 00:35:13.496 A:middle
to downcast an entire array
at a time doing the is kind

704
00:35:13.496 --> 00:35:14.656 A:middle
of class checks necessary

705
00:35:14.656 --> 00:35:17.436 A:middle
to make this safe
lazily, behind the scenes.

706
00:35:18.596 --> 00:35:19.956 A:middle
And then you can walk over
[inaudible] with them.

707
00:35:20.516 --> 00:35:26.086 A:middle
[ Applause ]

708
00:35:26.586 --> 00:35:29.646 A:middle
Now, we've seen NSArrays
in the Objective-C side,

709
00:35:30.176 --> 00:35:32.506 A:middle
Swift Arrays on the Swift side.

710
00:35:32.946 --> 00:35:35.116 A:middle
Let's take a little bit
of a peek under the hood

711
00:35:35.296 --> 00:35:38.226 A:middle
at how this actually
works because you're going

712
00:35:38.226 --> 00:35:41.526 A:middle
to be writing a lot of Swift
code that interacts with a lot

713
00:35:41.526 --> 00:35:43.626 A:middle
of Objective-C code and we
want this to perform well.

714
00:35:45.456 --> 00:35:48.496 A:middle
So there's a Swift array.

715
00:35:48.536 --> 00:35:52.896 A:middle
And the Swift array actually has
two internal representations.

716
00:35:53.826 --> 00:35:56.726 A:middle
Its first representation is
probably what you'd expect

717
00:35:56.726 --> 00:35:57.286 A:middle
out of Swift.

718
00:35:57.756 --> 00:35:59.206 A:middle
It's a Native representation.

719
00:35:59.596 --> 00:36:02.166 A:middle
It has a length, which is the
number of elements in the array.

720
00:36:02.166 --> 00:36:04.316 A:middle
It has a capacity that's used

721
00:36:04.316 --> 00:36:07.026 A:middle
so we can algorithmically
efficiently add things

722
00:36:07.026 --> 00:36:07.556 A:middle
to the array.

723
00:36:09.126 --> 00:36:12.926 A:middle
And then it has the buffer of
elements that are in the array.

724
00:36:14.416 --> 00:36:17.916 A:middle
And, of course, those buffered
elements, whatever kind

725
00:36:17.916 --> 00:36:19.736 A:middle
of array it is, that's how
much storage they take.

726
00:36:19.736 --> 00:36:21.906 A:middle
If we have an array
of 32-bit integers,

727
00:36:21.906 --> 00:36:24.156 A:middle
each element takes
32 bits of storage.

728
00:36:24.156 --> 00:36:25.966 A:middle
There's not extra
boxing going on here,

729
00:36:26.666 --> 00:36:27.776 A:middle
no extra performance loss.

730
00:36:27.946 --> 00:36:30.986 A:middle
It's just a native buffer.

731
00:36:31.166 --> 00:36:33.906 A:middle
Now we also have this
second representation

732
00:36:34.526 --> 00:36:37.446 A:middle
and we do a couple of pointer
tricks so that we can fit it

733
00:36:37.446 --> 00:36:39.546 A:middle
into just a tiny
amount of memory.

734
00:36:40.116 --> 00:36:42.076 A:middle
And that's the Cocoa
representation.

735
00:36:43.236 --> 00:36:49.096 A:middle
So any Swift array can actually
be an NSArray underneath

736
00:36:49.256 --> 00:36:50.346 A:middle
as representation.

737
00:36:50.966 --> 00:36:54.476 A:middle
And all the operations
on an array handle both

738
00:36:54.476 --> 00:36:55.996 A:middle
of these representations.

739
00:36:56.486 --> 00:37:00.386 A:middle
So if I subscript my array and
it happens to be an NSArray,

740
00:37:00.916 --> 00:37:02.776 A:middle
we'll use object and
index behind the scenes.

741
00:37:02.776 --> 00:37:04.926 A:middle
So you get that result
that you want.

742
00:37:05.916 --> 00:37:07.606 A:middle
If we do append to
such an array, well,

743
00:37:07.636 --> 00:37:10.196 A:middle
we can flip the representation
quickly and give you

744
00:37:10.196 --> 00:37:11.566 A:middle
that efficient append operation.

745
00:37:12.166 --> 00:37:16.176 A:middle
So given these two
representations,

746
00:37:16.356 --> 00:37:20.066 A:middle
we can talk about the notion
of bridging, of converting

747
00:37:20.666 --> 00:37:23.746 A:middle
between an NSArray, as
Objective-C would see,

748
00:37:24.786 --> 00:37:26.936 A:middle
and a Swift array that
you use within Swift.

749
00:37:28.256 --> 00:37:29.946 A:middle
There's two directions
here going

750
00:37:29.946 --> 00:37:31.686 A:middle
to Objective-C and coming back.

751
00:37:32.986 --> 00:37:36.416 A:middle
So first, let's talk
about coming back.

752
00:37:37.196 --> 00:37:39.036 A:middle
So we have an Objective-C
method.

753
00:37:39.036 --> 00:37:41.336 A:middle
In this case it's the
getter for toolbar items.

754
00:37:41.766 --> 00:37:43.686 A:middle
In Objective-C, that
returns NSArray.

755
00:37:44.406 --> 00:37:47.576 A:middle
In Swift, that's going to come
back as an array of AnyObject.

756
00:37:48.236 --> 00:37:49.136 A:middle
How do we do this?

757
00:37:49.586 --> 00:37:51.406 A:middle
Well, given our two
representations,

758
00:37:51.956 --> 00:37:53.386 A:middle
it's extremely efficient
to do it

759
00:37:53.386 --> 00:37:54.976 A:middle
because we have our
representation

760
00:37:55.266 --> 00:37:57.846 A:middle
that can just take
that NSArray directly.

761
00:37:58.426 --> 00:38:00.616 A:middle
All we need to do is
one copy operation

762
00:38:00.946 --> 00:38:03.256 A:middle
to make sure the contents
don't change underneath us

763
00:38:03.256 --> 00:38:04.616 A:middle
if it's a mutable array.

764
00:38:05.746 --> 00:38:08.206 A:middle
But the common case here is
that it's not a mutable array.

765
00:38:08.336 --> 00:38:12.436 A:middle
It's an immutable NSArray and so
this copy operation is trivial.

766
00:38:12.436 --> 00:38:14.966 A:middle
It's the message send that's
a retain, and that's it.

767
00:38:15.366 --> 00:38:16.926 A:middle
So its conversion
is extremely fast.

768
00:38:17.746 --> 00:38:20.646 A:middle
Let's talk about
the other direction,

769
00:38:21.576 --> 00:38:23.656 A:middle
going from a Swift
array to an NSArray.

770
00:38:24.146 --> 00:38:27.556 A:middle
So this would happen when we
take, say, our ToolbarItems.

771
00:38:27.556 --> 00:38:28.436 A:middle
It's a Swift array.

772
00:38:28.946 --> 00:38:32.886 A:middle
And we call the Objective-C
setter which expects an NSArray.

773
00:38:33.586 --> 00:38:36.036 A:middle
Well, now we have an
interesting question

774
00:38:36.906 --> 00:38:38.686 A:middle
because there's two possible
representations here.

775
00:38:39.176 --> 00:38:40.496 A:middle
There's the really easy answer.

776
00:38:41.036 --> 00:38:43.186 A:middle
It's already in the
Cocoa representation

777
00:38:43.386 --> 00:38:46.246 A:middle
and we can just hand off
the NSArray, no work at all.

778
00:38:47.696 --> 00:38:50.546 A:middle
But the native one, that a
different question entirely.

779
00:38:51.406 --> 00:38:55.906 A:middle
We could copy the whole buffer
but that would be awful.

780
00:38:55.906 --> 00:38:59.016 A:middle
We could possibly go
allocate a little shim object.

781
00:38:59.016 --> 00:39:00.636 A:middle
That's also possible.

782
00:39:01.346 --> 00:39:05.096 A:middle
Instead, we decided to make
our native representation

783
00:39:06.016 --> 00:39:08.866 A:middle
into a little bit of an
Objective-C object [laughter].

784
00:39:09.526 --> 00:39:12.376 A:middle
It's already an NSArray.

785
00:39:13.516 --> 00:39:15.986 A:middle
And we've optimized
the allocation here

786
00:39:16.406 --> 00:39:18.656 A:middle
so we can build these
objects super fast

787
00:39:19.476 --> 00:39:21.776 A:middle
and just pass off our
native representation

788
00:39:21.956 --> 00:39:24.826 A:middle
as if it were an NSArray
and it works beautifully

789
00:39:24.826 --> 00:39:26.466 A:middle
on the Objective-C side.

790
00:39:29.516 --> 00:39:33.856 A:middle
[ Applause ]

791
00:39:34.356 --> 00:39:37.216 A:middle
I think that's enough
of Bridging.

792
00:39:37.836 --> 00:39:44.416 A:middle
Let's talk about sub-classing.

793
00:39:45.746 --> 00:39:52.556 A:middle
Okay. So, Swift objects are
all Objective-C objects.

794
00:39:53.776 --> 00:39:56.546 A:middle
Now what this means is that if
you define a class in Swift,

795
00:39:57.456 --> 00:39:59.976 A:middle
it has basic Objective-C
inoperability built in.

796
00:40:00.226 --> 00:40:03.976 A:middle
We use the same layout
as an Objective-C class

797
00:40:04.616 --> 00:40:06.346 A:middle
so there's an is a
pointer in there.

798
00:40:06.346 --> 00:40:09.366 A:middle
The is a pointer points out
to Objective-C metadata.

799
00:40:10.166 --> 00:40:12.306 A:middle
There's the same
underlying infrastructure,

800
00:40:12.306 --> 00:40:15.836 A:middle
the thing that make ARC work
and the basic frameworks work

801
00:40:15.836 --> 00:40:16.906 A:middle
with retained release.

802
00:40:17.116 --> 00:40:18.296 A:middle
You can't expect a class.

803
00:40:19.136 --> 00:40:19.786 A:middle
That sort of thing.

804
00:40:20.086 --> 00:40:20.896 A:middle
They're all available.

805
00:40:22.416 --> 00:40:25.376 A:middle
Now, if you really want to
make use of your classes

806
00:40:25.486 --> 00:40:29.386 A:middle
from within your
Objective-C code, well,

807
00:40:29.386 --> 00:40:32.246 A:middle
then you should inherit
from an Objective-C class,

808
00:40:32.616 --> 00:40:35.106 A:middle
whether it's NSObject
or some other class.

809
00:40:35.596 --> 00:40:38.926 A:middle
And this is going to expose your
class to the Objective-C world

810
00:40:38.926 --> 00:40:42.516 A:middle
and make all the things you
write in Swift available also

811
00:40:42.516 --> 00:40:43.606 A:middle
to your Objective-C code.

812
00:40:44.746 --> 00:40:47.226 A:middle
So we're going to continue
with our UIDocument example

813
00:40:47.226 --> 00:40:50.636 A:middle
from earlier and we're going to
create a little MyDocument class

814
00:40:50.676 --> 00:40:52.766 A:middle
that inherits from UIDocument.

815
00:40:53.266 --> 00:40:57.046 A:middle
And we're going to
talk about a couple

816
00:40:57.046 --> 00:40:58.666 A:middle
of the things that
some classes do.

817
00:40:59.076 --> 00:41:00.266 A:middle
They override methods.

818
00:41:01.276 --> 00:41:03.546 A:middle
So here we're going to
override the handleError,

819
00:41:03.546 --> 00:41:05.566 A:middle
userInteractionPermitted method.

820
00:41:06.636 --> 00:41:09.486 A:middle
And you do this exactly
the same way as you'd do it

821
00:41:09.486 --> 00:41:11.156 A:middle
if you were overriding
a Swift method.

822
00:41:11.426 --> 00:41:12.196 A:middle
It doesn't matter.

823
00:41:12.196 --> 00:41:13.486 A:middle
The syntax is the same.

824
00:41:13.636 --> 00:41:15.856 A:middle
The fact that the super class
is written in Objective-C,

825
00:41:16.116 --> 00:41:18.596 A:middle
completely irrelevant to
the syntax of the language

826
00:41:18.896 --> 00:41:19.796 A:middle
and how you work with it.

827
00:41:21.856 --> 00:41:23.916 A:middle
Now one thing to note
in Swift is that the

828
00:41:23.916 --> 00:41:26.726 A:middle
"override" keyword is mandatory.

829
00:41:28.146 --> 00:41:28.976 A:middle
Why do we do that?

830
00:41:29.296 --> 00:41:30.656 A:middle
There's a couple of
reasons for doing that.

831
00:41:31.346 --> 00:41:35.136 A:middle
One of the reasons is because
when you look at a method,

832
00:41:35.726 --> 00:41:38.306 A:middle
you probably want to know
if the intention here is

833
00:41:38.306 --> 00:41:41.046 A:middle
to override your
super class's behavior

834
00:41:41.046 --> 00:41:43.906 A:middle
because that's a really
important part of your API.

835
00:41:44.136 --> 00:41:47.766 A:middle
It's a really part of understand
what this method is supposed

836
00:41:47.766 --> 00:41:48.166 A:middle
to do.

837
00:41:48.766 --> 00:41:54.236 A:middle
Now the other thing it does is
it helps overriding accidents.

838
00:41:55.236 --> 00:41:58.496 A:middle
For example, I meant to override
something from my super class,

839
00:41:59.056 --> 00:42:01.046 A:middle
but I typed part of
the selector wrong

840
00:42:01.796 --> 00:42:04.006 A:middle
and the method name
no longer overrides.

841
00:42:04.286 --> 00:42:06.896 A:middle
My code isn't running
and I have no idea why.

842
00:42:06.896 --> 00:42:09.696 A:middle
Well, with mandatory
override, we catch that.

843
00:42:09.946 --> 00:42:12.286 A:middle
If you didn't override something
and you thought you did,

844
00:42:12.986 --> 00:42:13.826 A:middle
compiler will complain.

845
00:42:15.456 --> 00:42:19.196 A:middle
There's also the real
surprise which is

846
00:42:19.256 --> 00:42:21.916 A:middle
when you override something
from your super class

847
00:42:21.966 --> 00:42:23.786 A:middle
that you didn't even
know existed.

848
00:42:24.386 --> 00:42:30.046 A:middle
And this is the case where you
just wrote a method and maybe

849
00:42:30.046 --> 00:42:32.266 A:middle
in this release that
method happens to exist

850
00:42:32.266 --> 00:42:34.276 A:middle
or maybe it doesn't
exist in this release,

851
00:42:34.736 --> 00:42:37.516 A:middle
but some joker added it to the
next release in the frameworks

852
00:42:37.516 --> 00:42:39.696 A:middle
that you use and now
you're overriding something

853
00:42:39.696 --> 00:42:41.166 A:middle
that you didn't know
existed at the time.

854
00:42:41.996 --> 00:42:44.886 A:middle
We can catch that by
requiring override throughout

855
00:42:45.356 --> 00:42:45.926 A:middle
the language.

856
00:42:46.516 --> 00:42:51.686 A:middle
We could also talk a little bit
about overriding properties.

857
00:42:53.436 --> 00:42:57.406 A:middle
So, in Swift, you don't
override the getter

858
00:42:57.586 --> 00:42:58.926 A:middle
or the setter separately.

859
00:42:59.146 --> 00:43:01.796 A:middle
Instead you override
the property itself

860
00:43:02.396 --> 00:43:06.116 A:middle
and then you provide a getter
or a setter as appropriate.

861
00:43:06.716 --> 00:43:08.276 A:middle
So here we're doing
something very simple.

862
00:43:08.276 --> 00:43:10.476 A:middle
We're overriding the
description property

863
00:43:11.046 --> 00:43:12.616 A:middle
and providing a new
getter for it.

864
00:43:13.806 --> 00:43:16.176 A:middle
Now what this means to
the Objective-C runtime,

865
00:43:16.416 --> 00:43:17.636 A:middle
to your Objective-C code,

866
00:43:17.636 --> 00:43:19.326 A:middle
is that you've overridden
the getter.

867
00:43:20.546 --> 00:43:23.276 A:middle
But the semantic model
in Swift is different.

868
00:43:23.276 --> 00:43:26.386 A:middle
It's based on overriding the
actual thing that was declared.

869
00:43:26.386 --> 00:43:27.646 A:middle
In this case, the property.

870
00:43:28.216 --> 00:43:32.636 A:middle
As I mentioned before,
NSError is going to come back.

871
00:43:33.446 --> 00:43:35.966 A:middle
So we have contentsForType
error we're going

872
00:43:35.966 --> 00:43:37.346 A:middle
to override in our subclass.

873
00:43:37.766 --> 00:43:40.576 A:middle
And remember that the
Objective-C method took NSError

874
00:43:40.576 --> 00:43:45.806 A:middle
Star Star, a C pointer to an
NSError which could be nil.

875
00:43:47.346 --> 00:43:49.986 A:middle
The way we work with
these in Swift is

876
00:43:49.986 --> 00:43:53.646 A:middle
that the NSErrorPointer Class
provides a couple of operations

877
00:43:53.646 --> 00:43:55.336 A:middle
that you would expect
out of a pointer.

878
00:43:55.736 --> 00:43:58.966 A:middle
You can test if for nil, as
we do in the if check here,

879
00:43:59.396 --> 00:44:01.976 A:middle
to see whether we were actually
given a valid point error

880
00:44:01.976 --> 00:44:04.216 A:middle
where it says being
give nil by our caller.

881
00:44:05.426 --> 00:44:07.596 A:middle
Now, if it's not
nil, we can point

882
00:44:07.596 --> 00:44:10.006 A:middle
at the memory location
associated with that pointer

883
00:44:10.556 --> 00:44:14.756 A:middle
by referring to it as
error.memory and we can read

884
00:44:14.756 --> 00:44:16.846 A:middle
from that memory or
write to that memory

885
00:44:16.846 --> 00:44:18.356 A:middle
by just reading or
signing to it.

886
00:44:19.566 --> 00:44:21.426 A:middle
Now when this error pointer
is going to take care

887
00:44:21.426 --> 00:44:24.726 A:middle
of the nitty-gritty details
of making this auto-releasing

888
00:44:24.866 --> 00:44:27.146 A:middle
to fit in with the
code conventions

889
00:44:27.146 --> 00:44:29.316 A:middle
of Cocoa NSError handling.

890
00:44:29.316 --> 00:44:33.146 A:middle
So it's actually fairly easy
to deal with the C pointer

891
00:44:33.346 --> 00:44:34.516 A:middle
from within the Swift world.

892
00:44:35.266 --> 00:44:36.626 A:middle
Now let's take a look
at the Swift class

893
00:44:36.626 --> 00:44:37.856 A:middle
that we've been building here.

894
00:44:38.436 --> 00:44:42.266 A:middle
We have MyDocument.

895
00:44:42.266 --> 00:44:43.796 A:middle
It inherits from UIDocument.

896
00:44:44.356 --> 00:44:45.556 A:middle
It has a property in it.

897
00:44:45.556 --> 00:44:47.226 A:middle
It has some method overrides.

898
00:44:47.986 --> 00:44:50.106 A:middle
It's just a Swift class
through and through.

899
00:44:51.256 --> 00:44:54.316 A:middle
But all of this is
accessible directly

900
00:44:54.316 --> 00:44:56.096 A:middle
in your Objective-C code.

901
00:44:57.386 --> 00:44:58.346 A:middle
So if you project this

902
00:44:58.346 --> 00:45:01.656 A:middle
into Objective-C it
would look like this.

903
00:45:01.656 --> 00:45:04.406 A:middle
All the same elements are there.

904
00:45:04.406 --> 00:45:05.306 A:middle
We have properties.

905
00:45:05.306 --> 00:45:06.166 A:middle
We have methods.

906
00:45:06.686 --> 00:45:08.636 A:middle
Now there's some interesting
things to point out.

907
00:45:09.216 --> 00:45:12.596 A:middle
Well, for one, we have
this item's property

908
00:45:12.596 --> 00:45:13.776 A:middle
that is in an NSArray.

909
00:45:14.866 --> 00:45:16.596 A:middle
Remember, we talked
about bridging here.

910
00:45:17.836 --> 00:45:21.046 A:middle
The original Swift code
had an array of strings.

911
00:45:22.496 --> 00:45:25.416 A:middle
We bridged that seamlessly
over to an NSArray

912
00:45:25.446 --> 00:45:27.666 A:middle
that contains NSString objects

913
00:45:27.866 --> 00:45:29.626 A:middle
for your Objective-C
code to use.

914
00:45:30.146 --> 00:45:35.166 A:middle
So you can use strong typing
in the Swift world and it maps

915
00:45:35.166 --> 00:45:38.606 A:middle
over to the natural thing
within the Objective-C world.

916
00:45:39.746 --> 00:45:43.486 A:middle
The other thing I want to point
out is this really ugly name

917
00:45:43.486 --> 00:45:44.436 A:middle
up top you've noticed.

918
00:45:45.346 --> 00:45:46.466 A:middle
So this is a mangled name.

919
00:45:47.386 --> 00:45:49.266 A:middle
Usually you're going to see this

920
00:45:49.266 --> 00:45:52.716 A:middle
as MyApp.MyDocument
unless you're poking

921
00:45:52.716 --> 00:45:53.716 A:middle
at the internal somewhere.

922
00:45:54.306 --> 00:46:00.126 A:middle
And the purpose of this mangled
name is to put everything

923
00:46:00.126 --> 00:46:02.566 A:middle
in a namespace of some
sort so you don't have

924
00:46:02.566 --> 00:46:04.756 A:middle
to prefix all of
your class names.

925
00:46:05.616 --> 00:46:09.436 A:middle
Instead, what Swift does
is it puts the module name,

926
00:46:09.496 --> 00:46:11.786 A:middle
which is your target, your
framework, or your app --

927
00:46:12.886 --> 00:46:16.186 A:middle
that name into the names
of the classes it creates

928
00:46:16.386 --> 00:46:18.956 A:middle
so you can use the
simple names that you want

929
00:46:18.956 --> 00:46:21.486 A:middle
to use throughout your
application and not worry

930
00:46:21.486 --> 00:46:24.246 A:middle
about a conflict with something
else in the system somewhere.

931
00:46:26.516 --> 00:46:32.286 A:middle
[ Applause ]

932
00:46:32.786 --> 00:46:34.976 A:middle
When you're writing your
Swift Classes you do need

933
00:46:34.976 --> 00:46:38.886 A:middle
to be a little bit cognizant
of the limits of Objective-C.

934
00:46:39.906 --> 00:46:42.286 A:middle
Swift has a lot of cool
features; you might want

935
00:46:42.286 --> 00:46:45.336 A:middle
to use them -- Tuples,
Generics, and so on.

936
00:46:45.876 --> 00:46:48.426 A:middle
And if you go crazy
in your classes

937
00:46:48.426 --> 00:46:51.526 A:middle
and you use these features,
you might be a little surprised

938
00:46:51.526 --> 00:46:55.966 A:middle
that this generic method that
returns a tuple doesn't show

939
00:46:55.966 --> 00:46:58.576 A:middle
up in your Objective-C coded
because Objective-C has no way

940
00:46:58.576 --> 00:46:59.766 A:middle
to express that signature.

941
00:47:00.306 --> 00:47:01.076 A:middle
There's nothing we can do.

942
00:47:01.076 --> 00:47:02.386 A:middle
We don't have tuples
in Objective-C.

943
00:47:04.216 --> 00:47:07.186 A:middle
So if this happens to you
and you're surprised by it,

944
00:47:08.176 --> 00:47:10.046 A:middle
there's an attribute you
can add to your method.

945
00:47:10.716 --> 00:47:12.046 A:middle
It's the objc attribute.

946
00:47:12.596 --> 00:47:16.656 A:middle
And what this does is it
asks the compiler to check

947
00:47:17.166 --> 00:47:22.326 A:middle
and make sure that this method
or property or initializer

948
00:47:22.326 --> 00:47:26.636 A:middle
or whatever is expressible in
Objective-C so it can be used

949
00:47:26.636 --> 00:47:27.856 A:middle
from your Objective-C code.

950
00:47:28.566 --> 00:47:31.566 A:middle
And if it's not expressible in
Objective-C for some reason,

951
00:47:31.896 --> 00:47:33.696 A:middle
the compiler will
give you a hard error

952
00:47:33.696 --> 00:47:36.536 A:middle
to tell you this is not
something you can use

953
00:47:36.536 --> 00:47:37.246 A:middle
from Objective-C.

954
00:47:39.006 --> 00:47:42.676 A:middle
Now the objc attribute
actually has a second purpose.

955
00:47:42.866 --> 00:47:45.626 A:middle
And that's controlling
the names that you see

956
00:47:45.626 --> 00:47:47.386 A:middle
in the Objective-C
side of things.

957
00:47:48.456 --> 00:47:50.096 A:middle
So, here's a property enabled.

958
00:47:50.286 --> 00:47:51.046 A:middle
It has a getter.

959
00:47:51.046 --> 00:47:51.806 A:middle
It has a setter.

960
00:47:53.486 --> 00:47:56.336 A:middle
In Objective-C this is going to
come through as a property named

961
00:47:56.336 --> 00:47:59.026 A:middle
"enabled," a getter
named "enabled,"

962
00:47:59.316 --> 00:48:01.586 A:middle
and a setter named
setEnable colon."

963
00:48:03.076 --> 00:48:04.436 A:middle
That's not Cocoa convention.

964
00:48:04.596 --> 00:48:07.346 A:middle
You'd really rather the
call, the getter, is enabled.

965
00:48:08.726 --> 00:48:11.186 A:middle
And so to do that we just
use the objc attribute,

966
00:48:11.946 --> 00:48:13.976 A:middle
providing with the
selector "is enabled,"

967
00:48:14.346 --> 00:48:17.136 A:middle
so we can control
the mapping ourselves

968
00:48:17.136 --> 00:48:18.746 A:middle
between these two languages.

969
00:48:19.476 --> 00:48:21.206 A:middle
I don't expect you
to do this often,

970
00:48:21.856 --> 00:48:24.866 A:middle
but it's there if you need it.

971
00:48:25.136 --> 00:48:29.746 A:middle
You can also do this
for the name of a class.

972
00:48:29.916 --> 00:48:32.106 A:middle
And what we have here
in the parentheses,

973
00:48:32.326 --> 00:48:33.456 A:middle
in the objc attribute,

974
00:48:33.626 --> 00:48:36.806 A:middle
is the non-named
spaced name of a class.

975
00:48:37.406 --> 00:48:38.706 A:middle
So why would you do this?

976
00:48:39.206 --> 00:48:42.556 A:middle
Well, perhaps you're hoarding
part of your application

977
00:48:42.556 --> 00:48:44.496 A:middle
from Objective-C to
Swift for some reason.

978
00:48:45.036 --> 00:48:46.906 A:middle
And so you had ABCMyDocument.

979
00:48:47.226 --> 00:48:48.816 A:middle
Now you just want to
call it MYDocument

980
00:48:48.816 --> 00:48:50.316 A:middle
because you're sick
of typing ABC.

981
00:48:51.346 --> 00:48:53.876 A:middle
However, you have some
archives that you still want

982
00:48:53.876 --> 00:48:55.446 A:middle
to have work, because
this is going

983
00:48:55.446 --> 00:48:57.466 A:middle
to be a drop-in compatible
implementation.

984
00:48:58.316 --> 00:49:00.116 A:middle
In Swift, for your
Objective-C class,

985
00:49:00.476 --> 00:49:01.976 A:middle
you can use the objc attribute

986
00:49:02.116 --> 00:49:06.676 A:middle
to give this class the
runtime name of ABCMyDocument

987
00:49:06.926 --> 00:49:08.526 A:middle
and keep all of your
archives working.

988
00:49:08.526 --> 00:49:11.836 A:middle
One last thing I
promised to talk about,

989
00:49:12.276 --> 00:49:14.246 A:middle
and that CF Interoperability.

990
00:49:15.286 --> 00:49:20.216 A:middle
So by CF we're referring
to all of the C-like APIs

991
00:49:20.296 --> 00:49:22.686 A:middle
that work with the C objects.

992
00:49:22.966 --> 00:49:24.476 A:middle
So, this is Core Foundation.

993
00:49:24.476 --> 00:49:27.706 A:middle
This is Core Graphics
and other frameworks,

994
00:49:27.706 --> 00:49:29.056 A:middle
maybe some of your
own frameworks.

995
00:49:29.866 --> 00:49:32.976 A:middle
And let's take a
little look at using CF,

996
00:49:33.196 --> 00:49:35.906 A:middle
particularly Core
Graphics in Objective-C.

997
00:49:36.256 --> 00:49:38.426 A:middle
I'm going to do something
really simple here.

998
00:49:38.496 --> 00:49:42.806 A:middle
I'm going to draw a gradient in
a rectangle using Core Graphics.

999
00:49:43.276 --> 00:49:46.686 A:middle
Here's my start.

1000
00:49:47.096 --> 00:49:48.916 A:middle
I need to go build
up the ColorSpace

1001
00:49:49.006 --> 00:49:49.986 A:middle
and build up the Gradient.

1002
00:49:50.036 --> 00:49:54.496 A:middle
Now there's a couple of things
of here that I find non-optimal.

1003
00:49:55.236 --> 00:49:56.956 A:middle
So the one thing is bridgecasts.

1004
00:49:57.916 --> 00:49:58.726 A:middle
So we're in ARC.

1005
00:50:00.056 --> 00:50:00.666 A:middle
It's partly great.

1006
00:50:00.666 --> 00:50:02.366 A:middle
It's handling our
NSArray for us.

1007
00:50:02.366 --> 00:50:04.596 A:middle
We're using the nice
array literal syntax.

1008
00:50:04.846 --> 00:50:07.826 A:middle
But now we need to do
bridgecasts between CGColorRef

1009
00:50:08.406 --> 00:50:11.296 A:middle
and id so we can put
things into the NSArray.

1010
00:50:12.866 --> 00:50:15.536 A:middle
And we have this
CFArray [inaudible] sort

1011
00:50:15.536 --> 00:50:16.836 A:middle
of doing toll free
bridging there

1012
00:50:16.996 --> 00:50:19.296 A:middle
between the NSArray
and the CFArray.

1013
00:50:20.666 --> 00:50:24.076 A:middle
And there's also this
semi-amusing thing

1014
00:50:24.076 --> 00:50:26.656 A:middle
that we're using three
different kinds of arrays

1015
00:50:27.186 --> 00:50:28.356 A:middle
in four lines of code.

1016
00:50:28.796 --> 00:50:34.246 A:middle
And you can write this -- you
can try to write this better.

1017
00:50:34.246 --> 00:50:37.546 A:middle
I couldn't, actually, find a way
to make it cleaner than this.

1018
00:50:38.216 --> 00:50:40.186 A:middle
And it's really unfortunate

1019
00:50:40.416 --> 00:50:43.236 A:middle
because the NSArray gives
us some useful behavior.

1020
00:50:43.236 --> 00:50:45.056 A:middle
ARC is managing its
lifetime for us.

1021
00:50:45.056 --> 00:50:45.686 A:middle
That's great.

1022
00:50:46.086 --> 00:50:49.676 A:middle
We need the CArray because we
need to put CGFloats in it,

1023
00:50:50.246 --> 00:50:52.166 A:middle
and we can't do that
within NSArray.

1024
00:50:53.596 --> 00:50:56.256 A:middle
And finally, we need to
do the toll-free bridging

1025
00:50:56.256 --> 00:51:00.846 A:middle
over to CFArrayRef
because that's what we use

1026
00:51:00.846 --> 00:51:04.846 A:middle
with Core Graphics APIs.

1027
00:51:05.056 --> 00:51:07.066 A:middle
Now, moving along, we
can create some points

1028
00:51:07.066 --> 00:51:10.696 A:middle
with CGPointMake and, of course,
even though you're under ARC

1029
00:51:10.986 --> 00:51:12.996 A:middle
where memory management
is automatic,

1030
00:51:13.366 --> 00:51:15.556 A:middle
it's not automated
for CF things.

1031
00:51:15.556 --> 00:51:17.796 A:middle
So we have to remember
to release the ColorSpace

1032
00:51:17.896 --> 00:51:18.906 A:middle
and release the Gradient.

1033
00:51:19.636 --> 00:51:21.046 A:middle
We feel like we can
do a little bit better

1034
00:51:21.046 --> 00:51:21.816 A:middle
in the world of Swift.

1035
00:51:23.106 --> 00:51:26.686 A:middle
So let's start again,
this time in Swift.

1036
00:51:27.126 --> 00:51:29.296 A:middle
And first let's build
our colorSpace.

1037
00:51:30.256 --> 00:51:33.156 A:middle
So here we're just calling
CGColorSpaceCreateDeviceRGB.

1038
00:51:34.746 --> 00:51:35.996 A:middle
Nothing different about that.

1039
00:51:36.856 --> 00:51:39.236 A:middle
However, the type that we infer

1040
00:51:39.236 --> 00:51:43.106 A:middle
for this ColorSpace
variable is CGColorSpace.

1041
00:51:44.016 --> 00:51:46.406 A:middle
Note the lack of a ref
at the end of this.

1042
00:51:46.986 --> 00:51:49.006 A:middle
This isn't some opaque pointer.

1043
00:51:49.686 --> 00:51:54.386 A:middle
This is the CGColorSpace
class that we've created.

1044
00:51:55.866 --> 00:51:57.676 A:middle
What's the nice thing
about being a class?

1045
00:51:57.996 --> 00:52:00.226 A:middle
Well, that means we're in
the ARC Model and we're going

1046
00:52:00.226 --> 00:52:02.606 A:middle
to automatically manage
the memory for you.

1047
00:52:04.516 --> 00:52:09.946 A:middle
[ Applause ]

1048
00:52:10.446 --> 00:52:13.166 A:middle
Let's go a little
further and create

1049
00:52:13.166 --> 00:52:14.446 A:middle
that Gradient we talked about.

1050
00:52:15.896 --> 00:52:18.936 A:middle
So here, remember, we need to
pass a couple of arrays through.

1051
00:52:19.816 --> 00:52:23.426 A:middle
We can use this nice
Swift Array literal syntax

1052
00:52:23.906 --> 00:52:26.456 A:middle
to form an array containing
startColor and Color.

1053
00:52:27.296 --> 00:52:30.166 A:middle
We're doing all of the bridging
automatically here for you.

1054
00:52:30.426 --> 00:52:32.186 A:middle
So we've created
the NSArray we need.

1055
00:52:32.516 --> 00:52:36.386 A:middle
We've toll-free bridged it to
the CFArray behind the scenes

1056
00:52:36.536 --> 00:52:38.616 A:middle
so you don't have to deal
with the fact that there are

1057
00:52:38.616 --> 00:52:40.106 A:middle
so many array types
running around.

1058
00:52:40.606 --> 00:52:44.606 A:middle
Did the exact same
thing for the C parts.

1059
00:52:45.226 --> 00:52:48.936 A:middle
So here we just have an array
of floating point values.

1060
00:52:49.366 --> 00:52:52.756 A:middle
So it's treated as a native
Swift array of CGFloats

1061
00:52:53.866 --> 00:52:57.516 A:middle
that we bridged seamlessly
to the underlying CArray

1062
00:52:57.776 --> 00:52:59.436 A:middle
that this C function expects.

1063
00:52:59.926 --> 00:53:03.136 A:middle
Let's keep going with
our example here.

1064
00:53:04.976 --> 00:53:08.716 A:middle
CGPoints. You can use
CGPointMake if you want.

1065
00:53:09.086 --> 00:53:10.106 A:middle
It's perfectly fine.

1066
00:53:10.106 --> 00:53:13.126 A:middle
It works exactly the same way
as it does in Objective-C.

1067
00:53:14.256 --> 00:53:16.556 A:middle
However, whenever
we import a struct,

1068
00:53:16.726 --> 00:53:20.346 A:middle
like CGPoint is a struct, we
provide it with initializers

1069
00:53:21.126 --> 00:53:22.626 A:middle
that have labeled arguments.

1070
00:53:23.056 --> 00:53:26.256 A:middle
And so a better way to
build CGPoints in Swift is

1071
00:53:26.496 --> 00:53:29.706 A:middle
to just construct a
CGPoint value using

1072
00:53:29.706 --> 00:53:32.046 A:middle
that same construction
syntax we've been talking

1073
00:53:32.046 --> 00:53:33.266 A:middle
about throughout this talk.

1074
00:53:34.726 --> 00:53:37.506 A:middle
And then use the
argument labels x and y

1075
00:53:37.806 --> 00:53:39.926 A:middle
to make it absolutely
clear what you're doing.

1076
00:53:39.926 --> 00:53:42.996 A:middle
And this brings a
little bit of a flavor

1077
00:53:43.146 --> 00:53:46.646 A:middle
of that nice Cocoa readability
using argument labels

1078
00:53:47.036 --> 00:53:48.646 A:middle
into the underlying CF APIs.

1079
00:53:48.646 --> 00:53:52.366 A:middle
And that's it for
our example in Swift.

1080
00:53:52.846 --> 00:53:53.626 A:middle
It's smaller.

1081
00:53:53.626 --> 00:53:54.416 A:middle
It's easier.

1082
00:53:54.416 --> 00:53:56.746 A:middle
There's far fewer concepts
that you have to deal

1083
00:53:56.746 --> 00:53:58.336 A:middle
with because we've
automatically taken

1084
00:53:58.336 --> 00:53:58.846 A:middle
over the [inaudible] frame.

1085
00:53:59.516 --> 00:54:06.356 A:middle
[ Applause ]

1086
00:54:06.856 --> 00:54:09.086 A:middle
Now you may have some of
your own APIs that we refer

1087
00:54:09.086 --> 00:54:11.066 A:middle
to as explicitly bridged.

1088
00:54:11.726 --> 00:54:14.046 A:middle
So these are CF-like APIs

1089
00:54:14.526 --> 00:54:17.136 A:middle
where we're not quite sure
whether you're following all the

1090
00:54:17.136 --> 00:54:22.066 A:middle
CF memory conventions because,
unlike the world of Cocoa

1091
00:54:22.066 --> 00:54:25.126 A:middle
which is fairly tame, and we've
been following conventions

1092
00:54:25.126 --> 00:54:28.016 A:middle
fairly well for many years,
we haven't been following them

1093
00:54:28.016 --> 00:54:30.056 A:middle
so well in C as a community.

1094
00:54:30.746 --> 00:54:34.356 A:middle
And so we may have this
function GetRandomColor,

1095
00:54:34.696 --> 00:54:35.886 A:middle
produces some random color.

1096
00:54:36.976 --> 00:54:40.836 A:middle
When we pull this in, the Swift
Compiler doesn't know whether we

1097
00:54:40.836 --> 00:54:43.886 A:middle
can really trust that this
returns plus zero or not.

1098
00:54:43.956 --> 00:54:46.186 A:middle
It has get in the name
but we're not sure.

1099
00:54:46.686 --> 00:54:49.126 A:middle
And so we do the safe
thing and we import it

1100
00:54:49.126 --> 00:54:51.356 A:middle
as an Unmanaged CGColor

1101
00:54:52.546 --> 00:54:55.326 A:middle
which means we can't directly
manage the memory here

1102
00:54:55.326 --> 00:54:57.076 A:middle
because we don't know
what the conventions are.

1103
00:54:58.656 --> 00:55:00.536 A:middle
So what is this Unmanaged thing?

