

1
00:00:13.976 --> 00:00:14.396 A:middle
&gt;&gt; Good morning.

2
00:00:15.686 --> 00:00:16.546 A:middle
I'm Sean Callanan.

3
00:00:17.716 --> 00:00:18.186 A:middle
Thank you.

4
00:00:18.186 --> 00:00:18.546 A:middle
Thank you.

5
00:00:20.346 --> 00:00:24.966 A:middle
I work on the Debugger Team at
Apple and I'm really excited

6
00:00:24.966 --> 00:00:26.476 A:middle
to show you this stuff today.

7
00:00:27.136 --> 00:00:31.426 A:middle
Now, a funny thing, before, when
I was preparing these slides,

8
00:00:31.816 --> 00:00:33.776 A:middle
I thought by the time
I'm giving this talk,

9
00:00:34.076 --> 00:00:36.626 A:middle
maybe some people have looked at
the language manual for Swift,

10
00:00:36.996 --> 00:00:38.916 A:middle
maybe some people have
tried the Playground.

11
00:00:40.286 --> 00:00:43.206 A:middle
It's gone a little
faster than that.

12
00:00:43.906 --> 00:00:45.126 A:middle
I am really impressed.

13
00:00:45.536 --> 00:00:48.216 A:middle
You guys, I look on the
labs, I look on Twitter.

14
00:00:48.866 --> 00:00:50.676 A:middle
You guys have apps
started already,

15
00:00:50.676 --> 00:00:52.286 A:middle
entire apps running in Swift.

16
00:00:52.486 --> 00:00:54.046 A:middle
I saw somebody with a raytracer.

17
00:00:54.316 --> 00:00:55.046 A:middle
It's crazy.

18
00:00:56.476 --> 00:00:59.516 A:middle
This is the sort of
thing that makes me happy

19
00:00:59.516 --> 00:01:00.466 A:middle
to be working at Apple.

20
00:01:00.706 --> 00:01:02.416 A:middle
You guys are such
awesome developers.

21
00:01:02.736 --> 00:01:04.936 A:middle
It's really just an honor
to write the tools you use.

22
00:01:05.096 --> 00:01:05.886 A:middle
Thank you very much.

23
00:01:06.516 --> 00:01:11.296 A:middle
[ Applause ]

24
00:01:11.796 --> 00:01:16.596 A:middle
So, I'm going to tell you about
using LLDB and the Swift REPL.

25
00:01:17.966 --> 00:01:21.296 A:middle
Now, as you're writing a Swift
app, you're probably going

26
00:01:21.296 --> 00:01:23.486 A:middle
to write one or two
lines of buggy code

27
00:01:23.566 --> 00:01:25.696 A:middle
and that's where LLDB fits in.

28
00:01:26.946 --> 00:01:29.896 A:middle
Now, the good news
is LLDB is better

29
00:01:29.896 --> 00:01:31.516 A:middle
than it's ever been with Swift.

30
00:01:32.146 --> 00:01:35.616 A:middle
And I'm going to tell you about
some of the basic features

31
00:01:35.616 --> 00:01:38.236 A:middle
that LLDB has to help you
find bugs in your program.

32
00:01:38.236 --> 00:01:41.326 A:middle
LLDB at its core is a tool

33
00:01:41.706 --> 00:01:44.606 A:middle
to help you fix problems
in your code.

34
00:01:45.676 --> 00:01:49.446 A:middle
It's got a great set of
basic features for tracking

35
00:01:49.446 --> 00:01:50.936 A:middle
down where your bugs are.

36
00:01:52.576 --> 00:01:55.386 A:middle
The first tool is the stack.

37
00:01:55.956 --> 00:02:00.296 A:middle
The stack is a tool
that lets you look

38
00:02:00.666 --> 00:02:07.116 A:middle
at why your program has stopped
and what functions got called

39
00:02:07.116 --> 00:02:09.485 A:middle
to get you to the point
where your program stopped.

40
00:02:11.156 --> 00:02:14.316 A:middle
Now, your program doesn't
always obediently stop

41
00:02:14.316 --> 00:02:15.166 A:middle
where you want it to.

42
00:02:16.036 --> 00:02:18.196 A:middle
In that case, you
need breakpoints.

43
00:02:18.996 --> 00:02:21.886 A:middle
Breakpoints are another
great tool LLDB provides

44
00:02:22.606 --> 00:02:25.106 A:middle
that let you stop
whenever you want to.

45
00:02:27.006 --> 00:02:30.146 A:middle
Finally, no matter how
you stop your program,

46
00:02:30.606 --> 00:02:32.606 A:middle
we have a great expression
command

47
00:02:33.126 --> 00:02:35.596 A:middle
that lets you inspect your
data right at the point

48
00:02:35.596 --> 00:02:36.726 A:middle
where your program stopped.

49
00:02:37.176 --> 00:02:39.746 A:middle
In today's presentation,

50
00:02:40.046 --> 00:02:42.646 A:middle
I'm going to show you these
tools working with Swift.

51
00:02:43.746 --> 00:02:46.916 A:middle
The good news is, the
commands are basically the same

52
00:02:47.226 --> 00:02:50.376 A:middle
as they used to be but
I'm going to show you how

53
00:02:50.376 --> 00:02:53.496 A:middle
to find some familiar bugs
that you may have seen before

54
00:02:54.346 --> 00:02:57.226 A:middle
and also a couple of new
ones that are introduced

55
00:02:57.426 --> 00:02:59.146 A:middle
when you're working with Swift.

56
00:03:00.956 --> 00:03:06.216 A:middle
Now, the cool thing is this
isn't all I have to talk about.

57
00:03:06.636 --> 00:03:08.796 A:middle
We now have a REPL, too.

58
00:03:09.636 --> 00:03:13.326 A:middle
The Swift REPL is
built on top of LLDB.

59
00:03:13.996 --> 00:03:22.176 A:middle
You can access it just at the
LLDB command prompt any time

60
00:03:22.386 --> 00:03:24.996 A:middle
that you're debugging
your program.

61
00:03:25.616 --> 00:03:28.496 A:middle
That's not all though.

62
00:03:28.626 --> 00:03:30.396 A:middle
You can also access
the Swift REPL

63
00:03:30.646 --> 00:03:32.216 A:middle
when you don't have
a program running.

64
00:03:32.516 --> 00:03:34.976 A:middle
You can access it directly
off of the shell prompt.

65
00:03:36.056 --> 00:03:39.226 A:middle
For a clean slate, I'm
going to tell you lots more

66
00:03:39.226 --> 00:03:41.186 A:middle
about interacting
with the REPL later

67
00:03:41.686 --> 00:03:43.116 A:middle
but there are two basic ways

68
00:03:43.446 --> 00:03:45.226 A:middle
that we want you
to use the REPL.

69
00:03:45.776 --> 00:03:51.206 A:middle
The first is when you've got a
program with some code and you'd

70
00:03:51.206 --> 00:03:54.026 A:middle
like to find out if it works,

71
00:03:54.306 --> 00:03:59.316 A:middle
if it's doing what you expect it
to, you can use this LLDB REPL

72
00:03:59.596 --> 00:04:01.376 A:middle
to test your app interactively.

73
00:04:02.756 --> 00:04:07.176 A:middle
Another great use for this
LLDB REPL is to add new code.

74
00:04:08.166 --> 00:04:10.236 A:middle
You can write new functions,

75
00:04:10.236 --> 00:04:14.346 A:middle
new classes in an existing
LLDB session and they get put

76
00:04:14.346 --> 00:04:16.926 A:middle
into your code and they can
interact with your code just

77
00:04:16.926 --> 00:04:19.065 A:middle
as if you'd written them
in your source files.

78
00:04:22.576 --> 00:04:27.016 A:middle
Now, if you've noticed,
one theme this year,

79
00:04:27.156 --> 00:04:30.686 A:middle
one thing that's kind of
over and over we're seeing

80
00:04:30.906 --> 00:04:32.536 A:middle
in all the presentations
starting right

81
00:04:32.536 --> 00:04:35.796 A:middle
at the keynote is how everything
seems a little bit more alive.

82
00:04:36.096 --> 00:04:37.806 A:middle
Everything is a little
bit more interactive.

83
00:04:37.806 --> 00:04:40.016 A:middle
Stuffs coming in, Craig is
telling you about his hair,

84
00:04:40.406 --> 00:04:44.986 A:middle
it's -- everything is
much more immediate

85
00:04:45.756 --> 00:04:47.376 A:middle
and LLDB is the same way.

86
00:04:48.476 --> 00:04:50.886 A:middle
Now we have a couple
of tools that are,

87
00:04:50.886 --> 00:04:53.546 A:middle
that have already existed
that are very interactive

88
00:04:54.096 --> 00:04:55.486 A:middle
and we're adding more this year.

89
00:04:57.236 --> 00:04:59.536 A:middle
First of all, you have
the expression command

90
00:04:59.596 --> 00:05:00.836 A:middle
as I alluded to earlier.

91
00:05:01.686 --> 00:05:03.976 A:middle
That's a great way for
when you're stopped to poke

92
00:05:03.976 --> 00:05:06.656 A:middle
at your variables, to call
a couple of local functions.

93
00:05:08.346 --> 00:05:12.536 A:middle
We also have, if you're a little
bit more experienced LLDB user

94
00:05:12.536 --> 00:05:15.026 A:middle
or maybe you've watched some
of our previous session videos,

95
00:05:15.506 --> 00:05:17.206 A:middle
LLDB Python scripting.

96
00:05:17.816 --> 00:05:20.526 A:middle
I'm not going to tell you too
much about that in this session

97
00:05:21.156 --> 00:05:24.166 A:middle
but it's a great way to
create new debugger features

98
00:05:24.346 --> 00:05:26.206 A:middle
and automate your
debugging processes.

99
00:05:27.886 --> 00:05:31.386 A:middle
This year, we've added
Playgrounds which allow you

100
00:05:31.386 --> 00:05:33.676 A:middle
to prototype entire
new algorithms

101
00:05:33.676 --> 00:05:35.576 A:middle
from scratch and learn APIs.

102
00:05:36.466 --> 00:05:38.476 A:middle
And we've also added
the LLDB REPL.

103
00:05:38.476 --> 00:05:40.436 A:middle
Now what's the difference

104
00:05:40.566 --> 00:05:42.756 A:middle
between the LLDB
REPL and Playgrounds?

105
00:05:44.456 --> 00:05:48.146 A:middle
Playgrounds, as I told you and
as you saw in Wednesday's demo

106
00:05:48.146 --> 00:05:51.226 A:middle
which Rick and Connor showed
you all the fantastic ways

107
00:05:51.226 --> 00:05:52.366 A:middle
that you can use Playgrounds,

108
00:05:53.446 --> 00:05:55.396 A:middle
Playgrounds works
from a blank slate.

109
00:05:55.816 --> 00:05:58.656 A:middle
You've got a text editor,
you import the stuff you want

110
00:05:58.656 --> 00:06:02.176 A:middle
to import, then you write some
code and you see how it works.

111
00:06:02.176 --> 00:06:07.156 A:middle
On the other hand, the
point of the LLDB REPL is

112
00:06:07.156 --> 00:06:10.396 A:middle
to let you investigate
how code would work

113
00:06:10.396 --> 00:06:13.176 A:middle
if it were inside your
preexisting program.

114
00:06:13.176 --> 00:06:16.806 A:middle
Now, in today's session,

115
00:06:16.806 --> 00:06:21.146 A:middle
I'm going to give
you two basic things.

116
00:06:22.286 --> 00:06:26.336 A:middle
First, an overview of the kind
of skills that you're going

117
00:06:26.336 --> 00:06:28.126 A:middle
to want to apply just
working with LLDB

118
00:06:28.126 --> 00:06:29.366 A:middle
in your regular debugging.

119
00:06:30.936 --> 00:06:33.866 A:middle
And then, I'm going to tell you

120
00:06:33.866 --> 00:06:35.776 A:middle
about some new debugging
workflows

121
00:06:36.046 --> 00:06:37.876 A:middle
that the Swift REPL enables.

122
00:06:39.656 --> 00:06:42.646 A:middle
Finally, I'm going to
sum up and tell you

123
00:06:42.826 --> 00:06:44.836 A:middle
where you can go for
more information.

124
00:06:45.466 --> 00:06:51.396 A:middle
So, let's jump right
into basic debugging.

125
00:06:52.656 --> 00:06:56.426 A:middle
Now in these slides, I'm
going to show you interactions

126
00:06:56.426 --> 00:07:00.266 A:middle
with LLDB, but really
there's two basic ways

127
00:07:00.266 --> 00:07:01.596 A:middle
of talking to LLDB.

128
00:07:02.706 --> 00:07:04.756 A:middle
So, one is if you're
inside Xcode.

129
00:07:05.826 --> 00:07:09.476 A:middle
In Xcode, you have the debugger
console which is usually

130
00:07:09.476 --> 00:07:11.286 A:middle
at the bottom of your window
when you're debugging.

131
00:07:11.976 --> 00:07:16.176 A:middle
You can work with the debugger
console and enter commands

132
00:07:17.016 --> 00:07:20.446 A:middle
and also Xcode provides you
with a bunch of UI features

133
00:07:20.736 --> 00:07:21.816 A:middle
that let you automatic --

134
00:07:21.926 --> 00:07:24.246 A:middle
that let you automate
certain things like stepping.

135
00:07:25.266 --> 00:07:29.736 A:middle
There's another way of
working with LLDB that some

136
00:07:29.736 --> 00:07:32.516 A:middle
of you more experienced users
may use from time to time,

137
00:07:33.256 --> 00:07:34.176 A:middle
and that's the terminal.

138
00:07:35.516 --> 00:07:39.496 A:middle
The LLDB command line interface
uses the exact same commands

139
00:07:39.496 --> 00:07:42.336 A:middle
that you're familiar with, with
typing in commands in Xcode.

140
00:07:43.726 --> 00:07:46.386 A:middle
I'm going to show you the
command line interface

141
00:07:46.776 --> 00:07:49.016 A:middle
but there's great sessions
as I'll tell you later

142
00:07:49.416 --> 00:07:54.476 A:middle
that tell you more about
how to use it through Xcode.

143
00:07:54.876 --> 00:08:00.656 A:middle
Now, this is a situation that
probably all of you have run

144
00:08:00.656 --> 00:08:01.966 A:middle
into at one time or another.

145
00:08:02.696 --> 00:08:04.806 A:middle
You're debugging
along in your program

146
00:08:05.116 --> 00:08:06.676 A:middle
and your program crashes.

147
00:08:07.496 --> 00:08:10.796 A:middle
It's stopped and now the
question is, well, what do I do?

148
00:08:10.796 --> 00:08:12.816 A:middle
There's all this
information here.

149
00:08:13.256 --> 00:08:15.326 A:middle
There are a couple
of basic questions

150
00:08:15.546 --> 00:08:19.236 A:middle
that you should be asking that
will help you find your bug

151
00:08:19.236 --> 00:08:20.316 A:middle
as quickly as possible.

152
00:08:21.526 --> 00:08:24.116 A:middle
The first is what
is the stop reason?

153
00:08:24.356 --> 00:08:25.296 A:middle
Why are we stopped?

154
00:08:26.766 --> 00:08:30.396 A:middle
The stop reason is a
facility that LLDB provides

155
00:08:31.376 --> 00:08:35.726 A:middle
that tells you why your
program was told to stop.

156
00:08:36.256 --> 00:08:37.826 A:middle
Something makes it stop.

157
00:08:38.196 --> 00:08:43.275 A:middle
The next question is, all
right, well, I know what --

158
00:08:43.275 --> 00:08:47.366 A:middle
that the program was told to
stop, how did it get there?

159
00:08:47.366 --> 00:08:49.656 A:middle
What code ran to get
us to this bad point?

160
00:08:51.066 --> 00:08:54.206 A:middle
This is where you use the
stack as I alluded to earlier.

161
00:08:55.186 --> 00:08:59.316 A:middle
You want to look up the stack
and find your own code so look

162
00:08:59.316 --> 00:09:00.836 A:middle
through all the framework code,

163
00:09:00.836 --> 00:09:03.726 A:middle
look through all the standard
library code and find frames

164
00:09:03.726 --> 00:09:05.786 A:middle
in your own code that
are responsible for this.

165
00:09:07.146 --> 00:09:08.686 A:middle
Once you've located the place

166
00:09:08.686 --> 00:09:10.066 A:middle
where things might
have gone wrong,

167
00:09:10.496 --> 00:09:13.486 A:middle
then you can start investigating
the failure conditions looking

168
00:09:13.486 --> 00:09:16.766 A:middle
at your variables and seeing
what variable values might have

169
00:09:16.896 --> 00:09:18.536 A:middle
gotten you into a bad state.

170
00:09:20.516 --> 00:09:24.386 A:middle
So let's get started and look at
applying these basic techniques

171
00:09:24.616 --> 00:09:27.516 A:middle
to some crashes you might
see out in the world.

172
00:09:27.556 --> 00:09:32.916 A:middle
Now, let's say your
program is crashed.

173
00:09:33.726 --> 00:09:35.746 A:middle
The first question as
I told you is you want

174
00:09:35.746 --> 00:09:37.476 A:middle
to know the stop reason.

175
00:09:38.056 --> 00:09:39.016 A:middle
Why did it crash?

176
00:09:40.786 --> 00:09:43.826 A:middle
The command that helps you
find this information is called

177
00:09:43.926 --> 00:09:44.776 A:middle
Thread Info.

178
00:09:46.076 --> 00:09:48.446 A:middle
Now, I'm showing you two
versions of the command here.

179
00:09:49.276 --> 00:09:51.316 A:middle
They both do the
exact same thing.

180
00:09:52.676 --> 00:09:56.966 A:middle
It's just that the short
version, t i, is very quick

181
00:09:57.026 --> 00:10:00.826 A:middle
to type and if you're doing
repeated stops and you're trying

182
00:10:00.826 --> 00:10:02.006 A:middle
to get your work done quickly,

183
00:10:02.196 --> 00:10:04.206 A:middle
you'll probably use short
versions of commands.

184
00:10:05.046 --> 00:10:07.356 A:middle
There's also a long, long
version of the command.

185
00:10:07.776 --> 00:10:09.706 A:middle
Now there are two reasons
why this might be helpful.

186
00:10:10.726 --> 00:10:14.316 A:middle
The first is it's more
explicit about what you're doing

187
00:10:14.396 --> 00:10:17.736 A:middle
and the second thing is you
can find it in the help.

188
00:10:18.596 --> 00:10:22.136 A:middle
So if you use the help command
or the apropos command in LLDB,

189
00:10:22.376 --> 00:10:24.266 A:middle
you can find this
command very easily.

190
00:10:25.536 --> 00:10:28.246 A:middle
Now, let's say you typed
thread info at the LLDB prompt.

191
00:10:28.606 --> 00:10:29.836 A:middle
You're going to get
some information

192
00:10:29.836 --> 00:10:32.126 A:middle
about the thread that's
currently stopped.

193
00:10:33.176 --> 00:10:35.566 A:middle
There's two pieces of
information that you want

194
00:10:35.606 --> 00:10:37.156 A:middle
to know when you're crashed.

195
00:10:38.226 --> 00:10:40.866 A:middle
The first is what
piece of code crashed?

196
00:10:41.466 --> 00:10:43.086 A:middle
In this case, we're stopped

197
00:10:43.086 --> 00:10:45.556 A:middle
in a function called
Swift.underscore

198
00:10:45.556 --> 00:10:46.706 A:middle
getOptionalValue.

199
00:10:46.706 --> 00:10:49.746 A:middle
Now the Swift underscore part --

200
00:10:49.746 --> 00:10:52.256 A:middle
the Swift dot part is
very important here

201
00:10:53.016 --> 00:10:56.796 A:middle
because it tells you that
you're inside the Swift module.

202
00:10:57.686 --> 00:10:59.946 A:middle
The Swift module is the
Swift's standard library,

203
00:11:00.466 --> 00:11:03.316 A:middle
so we already know that
standard library code crashed.

204
00:11:04.826 --> 00:11:07.816 A:middle
Now, what was the reason
that it gave for crashing?

205
00:11:08.426 --> 00:11:10.286 A:middle
The reason is a bad instruction.

206
00:11:11.626 --> 00:11:14.876 A:middle
Now, some of you may have
seen this message before.

207
00:11:16.026 --> 00:11:19.146 A:middle
A bad instruction is when the
CPU doesn't understand the

208
00:11:19.146 --> 00:11:20.296 A:middle
instruction that's being given.

209
00:11:20.296 --> 00:11:25.356 A:middle
But wait a second, we've got
a compiler that's being pretty

210
00:11:25.356 --> 00:11:27.556 A:middle
smart about issuing
the right instructions.

211
00:11:27.786 --> 00:11:28.586 A:middle
What's going on here?

212
00:11:30.146 --> 00:11:33.996 A:middle
Well, it turns out that
99 percent of the time,

213
00:11:33.996 --> 00:11:36.336 A:middle
these bad instructions
are used in assertions.

214
00:11:36.996 --> 00:11:40.216 A:middle
So, the code says
if something is bad,

215
00:11:40.986 --> 00:11:42.676 A:middle
if something unexpected
is happening,

216
00:11:42.926 --> 00:11:45.186 A:middle
I'm going to issue a bad
instruction to the CPU

217
00:11:45.186 --> 00:11:46.736 A:middle
and the program will stop.

218
00:11:47.466 --> 00:11:49.516 A:middle
So, when you see
EXC BAD INSTRUCTION,

219
00:11:49.906 --> 00:11:53.536 A:middle
what you should be thinking
is assertion failure.

220
00:11:53.666 --> 00:11:58.996 A:middle
Now, what we can see from this
stop reason without even looking

221
00:11:58.996 --> 00:12:01.506 A:middle
at the stack or any of the
stack frames is that we failed

222
00:12:01.506 --> 00:12:03.156 A:middle
in assertion in the
standard library.

223
00:12:04.206 --> 00:12:05.606 A:middle
Now what might cause
that to happen?

224
00:12:06.566 --> 00:12:08.126 A:middle
OK, let's move on
and have a look.

225
00:12:09.156 --> 00:12:10.786 A:middle
The next command
you're going to want

226
00:12:10.786 --> 00:12:12.916 A:middle
to use is the backtrace command.

227
00:12:13.586 --> 00:12:17.826 A:middle
The thread backtrace
command prints all the frames

228
00:12:17.826 --> 00:12:19.736 A:middle
on the stack of the
current thread

229
00:12:20.366 --> 00:12:24.186 A:middle
that is it tells you what
functions called each other

230
00:12:24.186 --> 00:12:25.666 A:middle
on the current thread to get you

231
00:12:25.666 --> 00:12:26.816 A:middle
to the point where
you're stopped.

232
00:12:27.516 --> 00:12:33.556 A:middle
In this case, we see that
just below the function

233
00:12:33.776 --> 00:12:37.976 A:middle
that was actually stopped,
you see your own code.

234
00:12:38.936 --> 00:12:42.406 A:middle
Now this top level code
function may be familiar to you

235
00:12:42.406 --> 00:12:44.796 A:middle
if you've played around with
Swift's command line tools.

236
00:12:45.566 --> 00:12:48.176 A:middle
That's the code that's
outside any function

237
00:12:48.476 --> 00:12:51.416 A:middle
in your main source file
of a command line tool.

238
00:12:52.676 --> 00:12:54.876 A:middle
So you recognize this top
level code and you say,

239
00:12:54.876 --> 00:12:56.696 A:middle
"Aha, this is my code.

240
00:12:56.696 --> 00:12:57.356 A:middle
Let's have a look."

241
00:12:58.496 --> 00:13:00.516 A:middle
Top level code is
frame number 1,

242
00:13:01.286 --> 00:13:04.826 A:middle
so that means we called directly
into the standard library

243
00:13:04.826 --> 00:13:05.726 A:middle
and an assertion failed.

244
00:13:06.226 --> 00:13:09.206 A:middle
Let's have a look at
why that happened.

245
00:13:10.396 --> 00:13:14.796 A:middle
Well, we select the first frame
and now we have information

246
00:13:14.796 --> 00:13:17.546 A:middle
about the source code
because it's your own code

247
00:13:17.546 --> 00:13:19.286 A:middle
and we have that.

248
00:13:20.126 --> 00:13:23.906 A:middle
Here we see that that we've
got an optional AnyObject

249
00:13:24.486 --> 00:13:26.956 A:middle
that we got from a source
that looks a little shady

250
00:13:27.246 --> 00:13:30.336 A:middle
and then we unwrap that
option without checking.

251
00:13:30.906 --> 00:13:35.686 A:middle
Well, turns out if you print
the value of that unwrap,

252
00:13:35.796 --> 00:13:39.236 A:middle
of that optional, you see
that optional is None.

253
00:13:39.956 --> 00:13:44.216 A:middle
Well, that's not too
difficult to fix.

254
00:13:44.576 --> 00:13:47.556 A:middle
You instead try if let
and that will let you--

255
00:13:47.556 --> 00:13:50.566 A:middle
and that will make the
unwrapping code conditional

256
00:13:50.566 --> 00:13:52.286 A:middle
and they're actually
being something in there.

257
00:13:53.176 --> 00:13:56.746 A:middle
Now let's take a little detour
before we look at more examples.

258
00:13:57.476 --> 00:14:00.936 A:middle
If you're using Xcode,
you're going to see more

259
00:14:00.936 --> 00:14:03.066 A:middle
than just the stack
that I just showed you.

260
00:14:04.476 --> 00:14:06.776 A:middle
If you're using libdispatch
in your program,

261
00:14:07.126 --> 00:14:10.546 A:middle
Xcode will additionally
show you all the functions

262
00:14:10.576 --> 00:14:12.486 A:middle
that got called in order to --

263
00:14:12.626 --> 00:14:17.576 A:middle
and enqueue your current
block onto a queue.

264
00:14:18.576 --> 00:14:21.386 A:middle
Then after that, once the queue
started running your code,

265
00:14:21.696 --> 00:14:23.986 A:middle
you see the stack frames
that your code invoked.

266
00:14:25.186 --> 00:14:27.656 A:middle
Now why is this relevant
to this talk?

267
00:14:27.656 --> 00:14:30.456 A:middle
Well, all the stack
frames that are

268
00:14:30.456 --> 00:14:34.106 A:middle
above the last block
execution, you'll be able

269
00:14:34.106 --> 00:14:35.736 A:middle
to see local variables for.

270
00:14:37.066 --> 00:14:39.406 A:middle
However, all the local variables

271
00:14:39.406 --> 00:14:42.176 A:middle
from before it got
enqueued are not going

272
00:14:42.176 --> 00:14:43.146 A:middle
to be available to you.

273
00:14:43.626 --> 00:14:46.076 A:middle
So you need some -- that's
why they're great out in Xcode

274
00:14:46.436 --> 00:14:50.386 A:middle
and you need to make sure
you know, you remember that.

275
00:14:50.386 --> 00:14:53.666 A:middle
All right, well, Grand
Central Dispatch is cool

276
00:14:53.886 --> 00:14:57.116 A:middle
but we're focusing on LLDB,
so let's get back to it.

277
00:14:57.526 --> 00:15:00.476 A:middle
Here's another case where
we've got an assertion.

278
00:15:02.226 --> 00:15:03.416 A:middle
Now, I told you earlier

279
00:15:03.656 --> 00:15:05.486 A:middle
that there's a command
called thread info

280
00:15:05.486 --> 00:15:08.606 A:middle
and that's a great way
to find the stop reason

281
00:15:08.606 --> 00:15:09.566 A:middle
for your current thread.

282
00:15:11.026 --> 00:15:14.246 A:middle
Another way to find
both the stop reason

283
00:15:14.326 --> 00:15:17.866 A:middle
and all the stack frames is just
to issue the backtrace command.

284
00:15:18.806 --> 00:15:21.726 A:middle
If you do this in this
case, we've crashed

285
00:15:21.726 --> 00:15:24.366 A:middle
in a different spot,
we see still

286
00:15:24.366 --> 00:15:27.766 A:middle
that the reason we stopped
is a bad instruction

287
00:15:28.426 --> 00:15:32.226 A:middle
and we're still stopped in
the Swift standard library.

288
00:15:32.916 --> 00:15:34.766 A:middle
In this case though,
we're stopped

289
00:15:34.766 --> 00:15:38.286 A:middle
in the getter for
an array member.

290
00:15:40.886 --> 00:15:43.236 A:middle
Well, let's look
at our own code.

291
00:15:44.396 --> 00:15:46.716 A:middle
Now this is a function
in your own program.

292
00:15:47.586 --> 00:15:50.456 A:middle
On the left hand side,
you see the main module

293
00:15:51.316 --> 00:15:54.676 A:middle
and on the right hand side
of the dot, you see the name

294
00:15:54.676 --> 00:15:56.376 A:middle
of your function, in
this case, FindElement.

295
00:15:56.406 --> 00:15:58.506 A:middle
Now what's this code doing?

296
00:15:59.296 --> 00:16:03.936 A:middle
FindElement is iterating across
an array and for every element

297
00:16:03.936 --> 00:16:07.646 A:middle
in the array, it's
applying a function to it.

298
00:16:07.896 --> 00:16:10.076 A:middle
Once that function returns true,

299
00:16:10.296 --> 00:16:12.176 A:middle
it returns that element
of the array.

300
00:16:12.216 --> 00:16:14.746 A:middle
And if that function
never returns true,

301
00:16:15.606 --> 00:16:16.946 A:middle
the function returns nil.

302
00:16:18.206 --> 00:16:19.436 A:middle
There's some problem here.

303
00:16:20.116 --> 00:16:21.896 A:middle
Maybe some of you
have figured it out.

304
00:16:22.516 --> 00:16:26.516 A:middle
But just, but the way I would
look at this is I would look

305
00:16:26.516 --> 00:16:30.636 A:middle
at the current index into the
array again using the print

306
00:16:30.636 --> 00:16:32.606 A:middle
command which is
short for expression.

307
00:16:33.306 --> 00:16:36.736 A:middle
In this case, we see
that the index is

308
00:16:36.736 --> 00:16:38.386 A:middle
at the fourth element
of the array.

309
00:16:39.076 --> 00:16:40.246 A:middle
Well, let's look at the array.

310
00:16:41.726 --> 00:16:45.756 A:middle
The count property of the array
is 3, we've walked too far.

311
00:16:46.366 --> 00:16:47.216 A:middle
Well, what happened here?

312
00:16:47.256 --> 00:16:48.476 A:middle
We used array.count, right?

313
00:16:48.706 --> 00:16:49.556 A:middle
Didn't we?

314
00:16:49.686 --> 00:16:51.636 A:middle
Oh, not quite.

315
00:16:52.736 --> 00:16:56.946 A:middle
So here we have a case of misuse
of the closed range operator.

316
00:16:58.516 --> 00:17:00.706 A:middle
We shouldn't have used
the closed range operator.

317
00:17:01.056 --> 00:17:03.566 A:middle
We should at least have only
used the half open range

318
00:17:03.566 --> 00:17:06.226 A:middle
operator because, of course,
the indexes of an array start

319
00:17:06.226 --> 00:17:09.925 A:middle
with 0, so they end at count
minus 1 instead of count.

320
00:17:11.656 --> 00:17:14.736 A:middle
But the real answer here is we
shouldn't have been using the

321
00:17:14.736 --> 00:17:15.596 A:middle
index at all.

322
00:17:15.695 --> 00:17:18.116 A:middle
We should have just been
using 4 element in array

323
00:17:18.346 --> 00:17:22.066 A:middle
and let Swift handle all the
details of the indexing for us.

324
00:17:23.955 --> 00:17:27.185 A:middle
All right, well, let's
look at another crash now

325
00:17:27.185 --> 00:17:29.386 A:middle
that we've kind of
seen the basics.

326
00:17:29.756 --> 00:17:31.326 A:middle
This crash looks a lot uglier.

327
00:17:31.326 --> 00:17:33.156 A:middle
Suddenly, there's a ton
of frames on the stack.

328
00:17:33.436 --> 00:17:35.486 A:middle
What the heck is going on and
all of this look like they're

329
00:17:35.486 --> 00:17:37.496 A:middle
in libc++abi and so forth.

330
00:17:37.496 --> 00:17:38.276 A:middle
Oh, scary.

331
00:17:39.026 --> 00:17:46.126 A:middle
So, let's use our
method and look

332
00:17:46.126 --> 00:17:47.216 A:middle
through this systematically.

333
00:17:47.786 --> 00:17:51.316 A:middle
The first thing you see is that
the stop reason is SIGABRT.

334
00:17:52.996 --> 00:17:58.566 A:middle
That means that we ran into a
situation where the kernel had

335
00:17:58.626 --> 00:18:01.476 A:middle
to put the kibosh on
us and say, "Hey, no.

336
00:18:01.476 --> 00:18:02.546 A:middle
This is going too far.

337
00:18:02.546 --> 00:18:03.186 A:middle
You're cut off.

338
00:18:03.186 --> 00:18:07.046 A:middle
Stop." Why does that happen?

339
00:18:07.876 --> 00:18:11.446 A:middle
That often happens because
an exception gets thrown.

340
00:18:12.516 --> 00:18:13.546 A:middle
Wait, a second, exceptions?

341
00:18:13.546 --> 00:18:14.616 A:middle
We're coding in Swift here.

342
00:18:15.746 --> 00:18:19.806 A:middle
All right, but they're still
there if you look on the stack.

343
00:18:20.976 --> 00:18:23.756 A:middle
In fact, an Objective-C
exception is being thrown.

344
00:18:23.756 --> 00:18:27.486 A:middle
All right, well, we've got
to track this down so we look

345
00:18:27.486 --> 00:18:28.706 A:middle
for our own code here

346
00:18:28.706 --> 00:18:32.256 A:middle
and in fact we see again a
function called FindElement.

347
00:18:33.496 --> 00:18:35.046 A:middle
This function is
causing a lot of trouble.

348
00:18:35.046 --> 00:18:37.166 A:middle
Let's have a look at it.

349
00:18:37.446 --> 00:18:40.026 A:middle
So we select that frame and
now we see our code again.

350
00:18:40.686 --> 00:18:42.926 A:middle
This time, FindElement
is looking

351
00:18:42.926 --> 00:18:46.236 A:middle
across an NSArray instead of a
Swift standard library array.

352
00:18:47.436 --> 00:18:49.256 A:middle
Again, we've got this
stupid coding error

353
00:18:49.256 --> 00:18:50.476 A:middle
with the closed range.

354
00:18:51.226 --> 00:18:53.256 A:middle
But the more interesting
thing is

355
00:18:53.536 --> 00:18:56.696 A:middle
because we were using an
NSArray, we were calling

356
00:18:56.696 --> 00:18:58.486 A:middle
into Objective-C code.

357
00:18:59.176 --> 00:19:01.946 A:middle
Now, Objective-C code
does throw exceptions.

358
00:19:04.966 --> 00:19:08.966 A:middle
Now, one, I took an
unofficial survey

359
00:19:08.966 --> 00:19:11.886 A:middle
of LLDB developers last night
when I was sitting in bed

360
00:19:12.346 --> 00:19:18.786 A:middle
and the most popular
crash by far was this one,

361
00:19:19.196 --> 00:19:23.286 A:middle
EXC BAD ACCESS at address 0.

362
00:19:25.296 --> 00:19:27.796 A:middle
This means that you were trying

363
00:19:27.796 --> 00:19:33.226 A:middle
to access memory
at a bad address.

364
00:19:33.326 --> 00:19:35.266 A:middle
Nil tends to be a bad address.

365
00:19:37.396 --> 00:19:38.456 A:middle
So what's going on here?

366
00:19:39.186 --> 00:19:40.126 A:middle
I'm coding in Swift.

367
00:19:40.366 --> 00:19:43.626 A:middle
It's supposed to be safe.

368
00:19:43.846 --> 00:19:47.186 A:middle
Well, let's have a look and
see what our top level code is

369
00:19:47.186 --> 00:19:47.666 A:middle
doing here.

370
00:19:48.266 --> 00:19:52.796 A:middle
I go to that frame
and I look at my code.

371
00:19:53.476 --> 00:19:56.916 A:middle
The code is importing Foundation
and it's getting some NSData

372
00:19:56.976 --> 00:19:59.656 A:middle
from a URL that looks
kind of suspicious.

373
00:20:00.736 --> 00:20:03.506 A:middle
And then, it looks at the
bytes property of that

374
00:20:03.506 --> 00:20:09.746 A:middle
of the resulting data and pulls
out the first element of it.

375
00:20:10.016 --> 00:20:10.936 A:middle
What's the problem here?

376
00:20:11.416 --> 00:20:12.656 A:middle
Well, let's look at chars.

377
00:20:14.136 --> 00:20:16.346 A:middle
Chars is a null UnsafePointer.

378
00:20:17.546 --> 00:20:19.896 A:middle
We're working with
Objective-C APIs.

379
00:20:21.416 --> 00:20:25.176 A:middle
Objective-C APIs can
give you UnsafePointers.

380
00:20:27.036 --> 00:20:31.316 A:middle
This is -- so, your old
friend, the null pointer,

381
00:20:31.656 --> 00:20:34.006 A:middle
is still around and
whenever you're dealing

382
00:20:34.006 --> 00:20:36.576 A:middle
with UnsafePointers,
you have to be very sure

383
00:20:36.576 --> 00:20:38.816 A:middle
that you know what you're doing.

384
00:20:39.326 --> 00:20:41.106 A:middle
All right.

385
00:20:42.236 --> 00:20:46.876 A:middle
So, the lesson here is Swift
is safe but the frameworks

386
00:20:46.876 --> 00:20:52.156 A:middle
that you're working
with may not be safe.

387
00:20:52.326 --> 00:20:53.256 A:middle
Let's sum up.

388
00:20:53.256 --> 00:20:54.966 A:middle
We've looked at a
couple of different ways

389
00:20:54.966 --> 00:20:57.326 A:middle
in which your code can
crash and we've seen

390
00:20:57.326 --> 00:21:00.566 A:middle
that the most important thing
to look at is the stop reason.

391
00:21:02.436 --> 00:21:05.406 A:middle
The next thing, once you figured
out what the stop reason is,

392
00:21:05.646 --> 00:21:07.176 A:middle
is looking at the stack to find

393
00:21:07.236 --> 00:21:09.176 A:middle
where your code fits
another picture.

394
00:21:10.726 --> 00:21:13.746 A:middle
Your code is going to
have local variables

395
00:21:14.486 --> 00:21:16.826 A:middle
and you can use the
expression command to figure

396
00:21:16.826 --> 00:21:19.936 A:middle
out what those local variables
are and how they connect

397
00:21:20.356 --> 00:21:23.886 A:middle
to the crash you're seeing.

398
00:21:24.056 --> 00:21:27.426 A:middle
Now, unfortunately, we
don't always live in a world

399
00:21:27.426 --> 00:21:30.086 A:middle
where your program stops when
it's doing something wrong.

400
00:21:30.726 --> 00:21:35.716 A:middle
For that world, there's
breakpoints and also beer.

401
00:21:36.116 --> 00:21:38.116 A:middle
[ Laughter ]

402
00:21:38.216 --> 00:21:41.636 A:middle
You can use a breakpoint if any

403
00:21:41.636 --> 00:21:43.126 A:middle
of the following
things are true.

404
00:21:44.836 --> 00:21:47.886 A:middle
The first case is when
the problem isn't a crash.

405
00:21:48.226 --> 00:21:49.956 A:middle
I've been showing
you lots of cases

406
00:21:49.956 --> 00:21:53.476 A:middle
where your program just can't
move on because it tried

407
00:21:53.536 --> 00:21:55.056 A:middle
to access something
it shouldn't have.

408
00:21:55.846 --> 00:21:58.056 A:middle
But that's not the
only kind of bug.

409
00:21:58.876 --> 00:22:04.096 A:middle
Your program might be outputting
wrong data or it might be,

410
00:22:04.536 --> 00:22:06.076 A:middle
you know, sending
something embarrassing

411
00:22:06.076 --> 00:22:09.036 A:middle
to a social networking site,
that's a little tougher

412
00:22:09.036 --> 00:22:13.176 A:middle
to set a breakpoint
on but bear with me.

413
00:22:14.086 --> 00:22:18.366 A:middle
So, and there's another reason,
you may just want to say,

414
00:22:18.766 --> 00:22:20.836 A:middle
you know, "I saw the
failing code on the stack,

415
00:22:20.836 --> 00:22:23.486 A:middle
but I'd like to stop
when that happens not

416
00:22:23.486 --> 00:22:25.966 A:middle
when the crash occurs."

417
00:22:26.286 --> 00:22:31.616 A:middle
Well, breakpoints are a great
tool for all of these cases.

418
00:22:31.746 --> 00:22:35.176 A:middle
Breakpoints have a couple of
attributes and you can edit them

419
00:22:35.176 --> 00:22:36.956 A:middle
in Xcode really easily as well.

420
00:22:38.516 --> 00:22:42.226 A:middle
The most important part of a
breakpoint is the specification.

421
00:22:42.826 --> 00:22:48.236 A:middle
When you say I want to stop
at places that look like this,

422
00:22:48.836 --> 00:22:52.536 A:middle
what that means to LLDB is,
this is a specification,

423
00:22:52.536 --> 00:22:53.556 A:middle
I need to be listening.

424
00:22:54.736 --> 00:22:59.166 A:middle
Then, LLDB goes out and looks
in the world for locations

425
00:22:59.356 --> 00:23:00.896 A:middle
that match your specification.

426
00:23:03.006 --> 00:23:07.156 A:middle
Now, LLDB is clever about
this, not only the locations

427
00:23:07.376 --> 00:23:09.086 A:middle
that are already in your program

428
00:23:09.086 --> 00:23:13.746 A:middle
when you issue the command
have matched the specification

429
00:23:14.156 --> 00:23:16.516 A:middle
but also, if you load a bundle

430
00:23:16.516 --> 00:23:18.246 A:middle
or some other framework
dynamically,

431
00:23:18.466 --> 00:23:21.316 A:middle
LLDB is still sitting there
in the background saying, "Oh,

432
00:23:21.316 --> 00:23:23.196 A:middle
is there anything that
matches my location in here?"

433
00:23:25.316 --> 00:23:28.426 A:middle
Finally, there's a couple of
optional parts to breakpoints

434
00:23:28.586 --> 00:23:30.536 A:middle
that are important and that
I'll show you in a moment.

435
00:23:31.126 --> 00:23:33.226 A:middle
The first is the
breakpoint condition.

436
00:23:33.926 --> 00:23:38.506 A:middle
The condition tells LLDB, "I
only actually want to stop here

437
00:23:39.026 --> 00:23:40.696 A:middle
when a certain predicate
is true."

438
00:23:42.266 --> 00:23:45.816 A:middle
Finally, there are actions that
you can perform without having

439
00:23:45.816 --> 00:23:48.016 A:middle
to type any commands
automatically

440
00:23:48.366 --> 00:23:50.246 A:middle
when the breakpoint gets hit.

441
00:23:50.876 --> 00:23:52.316 A:middle
So let's look at some code.

442
00:23:54.226 --> 00:23:56.156 A:middle
Here I've implemented a very,

443
00:23:56.156 --> 00:24:00.146 A:middle
very simplistic banking
application based a little bit

444
00:24:00.146 --> 00:24:01.896 A:middle
upon my own like wishes.

445
00:24:02.666 --> 00:24:09.066 A:middle
The bank account is, has a value
that's represented in cents.

446
00:24:09.626 --> 00:24:13.496 A:middle
And you have two functions,
you have a withdraw function

447
00:24:13.696 --> 00:24:15.066 A:middle
and you have a deposit function.

448
00:24:15.626 --> 00:24:19.276 A:middle
Now your withdraw function
is a little bit smart

449
00:24:19.276 --> 00:24:23.436 A:middle
and it charges an overdraft
fee when you go below,

450
00:24:23.436 --> 00:24:24.576 A:middle
when you withdraw more

451
00:24:24.576 --> 00:24:25.916 A:middle
than there's actually
in your account.

452
00:24:27.016 --> 00:24:29.886 A:middle
Now because this is
my kind of wish list,

453
00:24:30.016 --> 00:24:32.096 A:middle
this wish list account function.

454
00:24:32.466 --> 00:24:36.916 A:middle
This is actually overdraft fee
of 10 cents, but bear with me,

455
00:24:36.916 --> 00:24:39.486 A:middle
this is just an example.

456
00:24:39.896 --> 00:24:42.696 A:middle
So, you want to stop exactly

457
00:24:42.696 --> 00:24:45.026 A:middle
when an overdraft
fee is charged.

458
00:24:46.496 --> 00:24:48.626 A:middle
That's over here on line 6.

459
00:24:49.416 --> 00:24:54.406 A:middle
And in order to stop there,
you simply type breakpoint set

460
00:24:54.986 --> 00:24:57.416 A:middle
with the file set to
your current source file

461
00:24:57.506 --> 00:24:59.116 A:middle
and the line set to 6.

462
00:24:59.646 --> 00:25:02.526 A:middle
The way you were doing this
in Xcode is just click next

463
00:25:02.526 --> 00:25:08.266 A:middle
to that line and that
does the exact same thing.

464
00:25:08.606 --> 00:25:11.466 A:middle
Now, once you've set that
breakpoint, you can look

465
00:25:11.466 --> 00:25:12.646 A:middle
at the breakpoint list

466
00:25:12.836 --> 00:25:14.766 A:middle
to see all those
attributes I was talking

467
00:25:14.766 --> 00:25:15.886 A:middle
to you about earlier.

468
00:25:16.616 --> 00:25:22.246 A:middle
The first thing that's relevant
here is the specification

469
00:25:22.246 --> 00:25:22.976 A:middle
of the breakpoint.

470
00:25:23.656 --> 00:25:26.766 A:middle
LLDB will tell you that
you wanted this breakpoint

471
00:25:27.036 --> 00:25:29.176 A:middle
at a certain file
and a certain line.

472
00:25:30.686 --> 00:25:34.826 A:middle
The cool thing is LLDB also
tells you all the locations it

473
00:25:34.826 --> 00:25:36.776 A:middle
actually found for
that breakpoint.

474
00:25:37.856 --> 00:25:40.916 A:middle
Now in this case,
there's only one location

475
00:25:41.336 --> 00:25:43.716 A:middle
but there might be more.

476
00:25:43.716 --> 00:25:45.826 A:middle
Now let's have a look at a case

477
00:25:45.886 --> 00:25:47.376 A:middle
where there might
be more locations.

478
00:25:47.666 --> 00:25:51.516 A:middle
But first, let's
do a quick segue.

479
00:25:52.166 --> 00:25:54.786 A:middle
I've seen people that have
tons of breakpoint set.

480
00:25:55.716 --> 00:25:58.596 A:middle
And one thing that can be
frustrating is you've got a bug

481
00:25:58.596 --> 00:26:00.966 A:middle
you're tracking down and you've
got a bunch of breakpoints

482
00:26:00.966 --> 00:26:02.636 A:middle
that you had set
from an earlier,

483
00:26:02.696 --> 00:26:05.046 A:middle
from debugging an
earlier problem.

484
00:26:05.556 --> 00:26:08.616 A:middle
And you want to not
stop at all of those.

485
00:26:08.806 --> 00:26:11.386 A:middle
Well, we happen to have the
breakpoint disable command

486
00:26:11.586 --> 00:26:12.906 A:middle
to let you do exactly that.

487
00:26:13.446 --> 00:26:16.606 A:middle
If you disable a breakpoint, you
can obviously enable it later.

488
00:26:17.006 --> 00:26:19.916 A:middle
But for the time it's disabled,
LLDB will simply ignore it

489
00:26:19.916 --> 00:26:21.056 A:middle
and all of its locations.

490
00:26:22.936 --> 00:26:26.976 A:middle
Now, let's say we have a
little bit different code.

491
00:26:27.676 --> 00:26:29.286 A:middle
This is a simple example

492
00:26:29.526 --> 00:26:31.806 A:middle
where we implemented a
function called timestwo.

493
00:26:32.886 --> 00:26:36.226 A:middle
Timestwo applies to integers,
it applies to doubles,

494
00:26:36.476 --> 00:26:38.126 A:middle
and it also applies to strings.

495
00:26:38.126 --> 00:26:43.386 A:middle
I want to stop whenever
any of these is called.

496
00:26:44.086 --> 00:26:46.456 A:middle
But wait, they've all got
different line numbers,

497
00:26:46.456 --> 00:26:48.436 A:middle
how am I going to do that?

498
00:26:48.686 --> 00:26:51.036 A:middle
In this case, we can use
a symbolic breakpoint.

499
00:26:52.166 --> 00:26:58.676 A:middle
If I type breakpoint on
timestwo, LLDB will say, "OK.

500
00:26:58.976 --> 00:27:02.526 A:middle
You want to match all functions
that are called timestwo."

501
00:27:02.936 --> 00:27:08.406 A:middle
And it already tells you it
found 3 locations for that.

502
00:27:08.616 --> 00:27:12.146 A:middle
Now if you do a breakpoint list,
you see some more information

503
00:27:12.286 --> 00:27:13.276 A:middle
that can be very valuable.

504
00:27:13.936 --> 00:27:16.846 A:middle
The first thing of course
is your specification.

505
00:27:16.846 --> 00:27:20.826 A:middle
You said you wanted the
name to be timestwo.

506
00:27:20.886 --> 00:27:23.376 A:middle
The next part is
all the locations

507
00:27:23.376 --> 00:27:25.296 A:middle
that LLDB found for
your breakpoint.

508
00:27:26.296 --> 00:27:28.526 A:middle
In this case, it
found the location

509
00:27:28.526 --> 00:27:30.756 A:middle
where you were processing
an int and returning an int.

510
00:27:31.246 --> 00:27:33.146 A:middle
It also found the
same thing for double

511
00:27:33.146 --> 00:27:34.556 A:middle
and the same thing for string.

512
00:27:35.706 --> 00:27:38.146 A:middle
OK, that's cool, what can
I do with this information?

513
00:27:38.586 --> 00:27:40.956 A:middle
Well, let's say you
only care about the case

514
00:27:40.956 --> 00:27:43.516 A:middle
where you are handling a string.

515
00:27:44.426 --> 00:27:48.376 A:middle
In that case, you can disable
all the locations except the

516
00:27:48.376 --> 00:27:49.656 A:middle
ones you care about.

517
00:27:50.606 --> 00:27:53.656 A:middle
Now this is of course handy
when you have source code.

518
00:27:54.096 --> 00:27:56.956 A:middle
But if you don't have source
code this is even better.

519
00:27:58.446 --> 00:28:01.086 A:middle
You may be saying to yourself,
"Well, I'd really like to know

520
00:28:01.086 --> 00:28:03.996 A:middle
when I'm in this array
subscript operator

521
00:28:03.996 --> 00:28:06.486 A:middle
from the standard library."

522
00:28:07.246 --> 00:28:09.906 A:middle
Well, why not use a
symbolic breakpoint?

523
00:28:10.396 --> 00:28:11.496 A:middle
We don't need source for that.

524
00:28:11.496 --> 00:28:15.416 A:middle
And then you say, "Well,
oh I set the breakpoint

525
00:28:15.416 --> 00:28:17.556 A:middle
on the subscript operator
but there's a bunch of them."

526
00:28:18.486 --> 00:28:19.396 A:middle
Well, that's OK too.

527
00:28:19.396 --> 00:28:21.926 A:middle
Just disable the
locations you didn't want.

528
00:28:22.976 --> 00:28:26.356 A:middle
There's another cool
way of doing this

529
00:28:27.176 --> 00:28:30.446 A:middle
that uses a scale called
regular-expressions.

530
00:28:31.766 --> 00:28:34.966 A:middle
Now, some of you may have worked
with regular-expressions before,

531
00:28:34.966 --> 00:28:37.426 A:middle
and if so, you're always looking
for new ways to use them.

532
00:28:37.916 --> 00:28:44.346 A:middle
This is actually a joke from
another of my colleagues

533
00:28:44.376 --> 00:28:47.466 A:middle
who used to give the
talk, so blame him.

534
00:28:49.166 --> 00:28:55.786 A:middle
When you set this breakpoint,
you say, "I want to stop

535
00:28:55.786 --> 00:29:00.596 A:middle
at timestwo followed by any
sequence of characters as long

536
00:29:00.596 --> 00:29:02.556 A:middle
as there's the word
string in there."

537
00:29:03.356 --> 00:29:06.826 A:middle
So now, you've brokem you've
set a breakpoint specifically

538
00:29:07.276 --> 00:29:10.896 A:middle
at the Swift., at the
version of timestwo

539
00:29:10.896 --> 00:29:12.766 A:middle
that handles Swift.String.

540
00:29:13.396 --> 00:29:17.216 A:middle
All right, well we've got
regular-expression breakpoints.

541
00:29:17.216 --> 00:29:17.746 A:middle
That's really cool.

542
00:29:17.746 --> 00:29:18.716 A:middle
What else can we do?

543
00:29:19.486 --> 00:29:21.566 A:middle
Well, we can use
regular-expression breakpoints

544
00:29:21.566 --> 00:29:23.896 A:middle
for other types of
categories of functions.

545
00:29:24.336 --> 00:29:26.616 A:middle
So for example, if you
want to stop on all methods

546
00:29:26.616 --> 00:29:28.616 A:middle
of a certain class,
you say, well break set

547
00:29:28.616 --> 00:29:32.466 A:middle
on the regular-expression
Account backslash backslash dot,

548
00:29:32.466 --> 00:29:33.716 A:middle
why all these backslashes?

549
00:29:34.366 --> 00:29:37.436 A:middle
Well, the reason for that
is that we want to make,

550
00:29:37.526 --> 00:29:40.356 A:middle
we want dot to actually
be a dot here.

551
00:29:41.056 --> 00:29:42.856 A:middle
We don't want it to
mean any character.

552
00:29:42.886 --> 00:29:43.846 A:middle
In regular-expressions

553
00:29:43.846 --> 00:29:45.256 A:middle
that would normally
mean any character.

554
00:29:46.146 --> 00:29:48.356 A:middle
You can do the same thing
with functions in a module.

555
00:29:48.356 --> 00:29:50.266 A:middle
Although, watch out.

556
00:29:50.266 --> 00:29:52.316 A:middle
Once you start setting a
breakpoint on all functions

557
00:29:52.316 --> 00:29:54.226 A:middle
in a module, you're going
to find out there are a lot

558
00:29:54.226 --> 00:29:55.386 A:middle
of functions in a module,

559
00:29:56.056 --> 00:29:57.986 A:middle
including some automatically
generated ones,

560
00:29:58.146 --> 00:30:00.966 A:middle
so you want to watch
out for that.

561
00:30:02.126 --> 00:30:05.186 A:middle
There's a lot more on
regular-expression breakpoints

562
00:30:05.186 --> 00:30:08.166 A:middle
and a couple of other,
you know, topics like that

563
00:30:08.506 --> 00:30:11.816 A:middle
in the Advanced Debugging with
LLDB talk that we did last year.

564
00:30:12.826 --> 00:30:15.876 A:middle
That should all still
apply to Swift as well.

565
00:30:15.876 --> 00:30:20.406 A:middle
All right, back to our examples.

566
00:30:21.626 --> 00:30:24.556 A:middle
Now let's say you've
applied symbolic breakpoints,

567
00:30:24.556 --> 00:30:26.196 A:middle
you've set some file
and line breakpoint

568
00:30:26.196 --> 00:30:27.686 A:middle
but it gets hit all the time.

569
00:30:27.756 --> 00:30:31.236 A:middle
And you're like, "Oh man,
this is really tedious

570
00:30:31.236 --> 00:30:35.306 A:middle
to keep pressing continue,
can't there be a better way?"

571
00:30:35.616 --> 00:30:37.616 A:middle
Well, in fact there
is a better way.

572
00:30:39.116 --> 00:30:41.366 A:middle
Now let's go back to our
bank account example.

573
00:30:41.626 --> 00:30:43.746 A:middle
And let's say, we're
being extremely gracious

574
00:30:43.746 --> 00:30:45.496 A:middle
and we're not charging
an overdraft fee.

575
00:30:46.026 --> 00:30:49.206 A:middle
But we find that the users
of this bank account tend

576
00:30:49.206 --> 00:30:51.216 A:middle
to be kind of irresponsible
in their spending.

577
00:30:53.356 --> 00:30:57.506 A:middle
Again, we can set our breakpoint
on the withdraw function.

578
00:30:58.436 --> 00:31:04.166 A:middle
But now, once we've set the
breakpoint, we'd like to know

579
00:31:05.316 --> 00:31:07.396 A:middle
when would we charge
an overdraft fee,

580
00:31:07.856 --> 00:31:09.006 A:middle
if we were to charge one.

581
00:31:10.066 --> 00:31:12.446 A:middle
The way we find this out is

582
00:31:12.446 --> 00:31:15.796 A:middle
by setting a breakpoint
condition on the breakpoint.

583
00:31:16.606 --> 00:31:22.186 A:middle
Now, a condition is simply a
Swift expression that evaluates

584
00:31:22.246 --> 00:31:23.926 A:middle
to either true or false.

585
00:31:25.496 --> 00:31:27.926 A:middle
If the Swift expression
evaluates to true,

586
00:31:28.656 --> 00:31:31.126 A:middle
then LLDB stops at
that breakpoint.

587
00:31:32.016 --> 00:31:33.756 A:middle
If the condition
evaluates to false,

588
00:31:34.486 --> 00:31:38.366 A:middle
LLDB automatically continues
and you'd never see it.

589
00:31:41.256 --> 00:31:45.326 A:middle
Another thing you might want to
do is instead of just stopping

590
00:31:45.326 --> 00:31:47.196 A:middle
when you would charge
an overdraft,

591
00:31:47.606 --> 00:31:51.346 A:middle
you'd like to see what kinds of
amounts are people withdrawing

592
00:31:51.346 --> 00:31:52.356 A:middle
from their bank account?

593
00:31:52.506 --> 00:31:54.076 A:middle
What is their balances
looking like?

594
00:31:55.166 --> 00:31:56.306 A:middle
You can do that too.

595
00:31:57.556 --> 00:32:00.726 A:middle
In this case, you use a facility
called breakpoint commands.

596
00:32:01.596 --> 00:32:03.256 A:middle
Breakpoint commands
are really cool

597
00:32:03.256 --> 00:32:05.486 A:middle
because they really
minimize the number of times

598
00:32:05.486 --> 00:32:06.886 A:middle
where you have to
stop your program.

599
00:32:07.476 --> 00:32:13.216 A:middle
If you say breakpoint command
add, you can add the break,

600
00:32:13.426 --> 00:32:18.076 A:middle
add commands to the last
breakpoint that you created.

601
00:32:18.146 --> 00:32:21.246 A:middle
In this case, what we want
to do is see the local,

602
00:32:21.246 --> 00:32:23.136 A:middle
the value of the
current account in cents.

603
00:32:23.836 --> 00:32:27.836 A:middle
And then we want to continue,

604
00:32:28.056 --> 00:32:31.226 A:middle
which means that the process
just keeps running as normal.

605
00:32:32.396 --> 00:32:34.146 A:middle
Finally, once we're done typing

606
00:32:34.146 --> 00:32:36.356 A:middle
in commands we type
capital DONE.

607
00:32:36.356 --> 00:32:40.566 A:middle
And then, when you
run your program,

608
00:32:42.536 --> 00:32:45.926 A:middle
you get output each time
the breakpoint gets hit.

609
00:32:45.956 --> 00:32:47.546 A:middle
But you don't have
to touch anything.

610
00:32:48.646 --> 00:32:51.796 A:middle
This is a really cool
feature that is very useful

611
00:32:51.796 --> 00:32:53.686 A:middle
for when you've got your program
but you don't want to have

612
00:32:53.726 --> 00:32:55.786 A:middle
to recompile it to
insert print lines

613
00:32:55.786 --> 00:32:58.586 A:middle
or do something horrific
like that.

614
00:32:59.456 --> 00:33:02.936 A:middle
Now, there's a little
bit of a caveat here

615
00:33:03.236 --> 00:33:04.846 A:middle
when you're using
mixed projects.

616
00:33:07.076 --> 00:33:09.326 A:middle
Breakpoint conditions

617
00:33:09.476 --> 00:33:14.606 A:middle
and breakpoint commands both
use expressions in the language

618
00:33:14.796 --> 00:33:16.566 A:middle
where the breakpoint is located.

619
00:33:17.656 --> 00:33:20.576 A:middle
Now, if you set a
breakpoint on a symbol

620
00:33:21.426 --> 00:33:24.306 A:middle
that there might be
breakpoints match,

621
00:33:24.306 --> 00:33:26.406 A:middle
there might be locations
matching that breakpoint

622
00:33:26.506 --> 00:33:28.386 A:middle
at multiple places
in your program,

623
00:33:28.566 --> 00:33:30.446 A:middle
some of them implemented
in Objective-C,

624
00:33:30.646 --> 00:33:34.856 A:middle
some of them implemented
in Swift.

625
00:33:35.026 --> 00:33:36.736 A:middle
Now, we thought about that.

626
00:33:37.586 --> 00:33:40.866 A:middle
So we've provided the ability
to set breakpoint conditions

627
00:33:41.106 --> 00:33:43.916 A:middle
and breakpoint commands
on specific locations

628
00:33:43.916 --> 00:33:47.166 A:middle
of a breakpoint, not just
on the breakpoint as whole.

629
00:33:47.656 --> 00:33:50.896 A:middle
So, if you're stop, if you've
got a breakpoint location

630
00:33:50.896 --> 00:33:53.566 A:middle
in Swift, you can type
in a Swift condition.

631
00:33:54.406 --> 00:33:57.406 A:middle
And if you've got another
location in Objective-C,

632
00:33:57.666 --> 00:34:00.076 A:middle
you can use Objective-C
in your condition.

633
00:34:00.706 --> 00:34:04.076 A:middle
Now that raises the
question, "Well, OK,

634
00:34:04.076 --> 00:34:07.146 A:middle
I set a symbolic breakpoint and
I've got a ton of locations,

635
00:34:07.146 --> 00:34:08.126 A:middle
how do I tell them apart?

636
00:34:08.126 --> 00:34:10.315 A:middle
How do I figure out what
language they're in?"

637
00:34:11.286 --> 00:34:15.266 A:middle
Well, I'll give you a
quick overview of how

638
00:34:15.266 --> 00:34:16.906 A:middle
to read Swift symbols.

639
00:34:17.426 --> 00:34:22.235 A:middle
In this case, we're looking at
a couple of different symbols

640
00:34:22.795 --> 00:34:24.576 A:middle
in different, that
are implemented

641
00:34:24.896 --> 00:34:26.826 A:middle
in different places
in your code.

642
00:34:27.576 --> 00:34:29.036 A:middle
The first is called main.

643
00:34:30.335 --> 00:34:33.085 A:middle
If you're an Objective-C or C
programmer, you'll recognize

644
00:34:33.085 --> 00:34:36.376 A:middle
that main is the main
entry point of a C program.

645
00:34:37.545 --> 00:34:41.076 A:middle
But the more important thing
to notice here as that there,

646
00:34:41.076 --> 00:34:43.295 A:middle
it doesn't have any
argument names

647
00:34:44.136 --> 00:34:45.496 A:middle
and it doesn't have
any adornment.

648
00:34:46.516 --> 00:34:50.045 A:middle
This typically means that it's
a C or Objective-C function.

649
00:34:51.835 --> 00:34:54.505 A:middle
There's another thing
though that you have

650
00:34:54.505 --> 00:34:57.986 A:middle
to remember especially with
when you're dealing with Swift,

651
00:34:57.986 --> 00:35:00.706 A:middle
and that is the top level
code acts the same way.

652
00:35:01.446 --> 00:35:04.146 A:middle
So just remember that if
there's no adornment like this,

653
00:35:04.146 --> 00:35:05.776 A:middle
it's either Objective-C or C

654
00:35:05.776 --> 00:35:07.876 A:middle
or if it's top level
code, then it's Swift.

655
00:35:08.626 --> 00:35:13.136 A:middle
The next thing is, if you
have an Objective-C class

656
00:35:13.136 --> 00:35:16.906 A:middle
or instance method, that class
or instance method name is going

657
00:35:16.906 --> 00:35:19.616 A:middle
to have brackets and
a dash or a plus sign.

658
00:35:20.936 --> 00:35:23.636 A:middle
Finally, if you have
a Swift function,

659
00:35:24.596 --> 00:35:28.506 A:middle
then we know the return type
and we know the argument types

660
00:35:28.506 --> 00:35:30.946 A:middle
for the function, so we're
going to be very verbose

661
00:35:30.986 --> 00:35:36.456 A:middle
and tell you all that
information right up front.

662
00:35:37.526 --> 00:35:38.526 A:middle
All right.

663
00:35:38.526 --> 00:35:41.336 A:middle
So, now we've seen
how to stop an app

664
00:35:41.336 --> 00:35:43.616 A:middle
at the right time in LLDB.

665
00:35:44.146 --> 00:35:47.396 A:middle
The tool you use to do
that is breakpoints.

666
00:35:47.956 --> 00:35:50.956 A:middle
You can set breakpoints
based on all kinds of filters

667
00:35:51.586 --> 00:35:54.686 A:middle
and you can even set
conditions on your breakpoints,

668
00:35:55.046 --> 00:35:56.936 A:middle
so that once you know
where you want to stop,

669
00:35:57.186 --> 00:36:00.496 A:middle
you can also tell LLDB to some
extent when you want to stop.

670
00:36:02.036 --> 00:36:04.766 A:middle
You can even set automated
actions on your breakpoints

671
00:36:05.056 --> 00:36:06.646 A:middle
so that you don't have to stop,

672
00:36:07.306 --> 00:36:10.356 A:middle
investigate your
variables and then move on.

673
00:36:12.116 --> 00:36:15.136 A:middle
Well, now let's talk about
some of the new stuff

674
00:36:15.186 --> 00:36:16.366 A:middle
that we've added into LLDB.

675
00:36:16.366 --> 00:36:19.156 A:middle
This is the stuff
I've been having fun

676
00:36:19.156 --> 00:36:21.436 A:middle
with for the last year or so.

677
00:36:23.456 --> 00:36:24.806 A:middle
The first thing I'm
going to tell you

678
00:36:24.806 --> 00:36:27.756 A:middle
about is validating your
existing code using the

679
00:36:27.756 --> 00:36:28.516 A:middle
LLDB REPL.

680
00:36:29.946 --> 00:36:32.466 A:middle
The LLDB REPL is
really an amazing tool.

681
00:36:32.876 --> 00:36:37.136 A:middle
And these slides, while they
kind of scratch the surface

682
00:36:37.136 --> 00:36:39.956 A:middle
of all the stuff you can
do, I'm really excited

683
00:36:39.956 --> 00:36:43.016 A:middle
to see what you all
can do and what kinds

684
00:36:43.016 --> 00:36:44.486 A:middle
of workflows you're
going to discover.

685
00:36:45.826 --> 00:36:49.506 A:middle
So let's try validating some
existing code, but first,

686
00:36:49.846 --> 00:36:51.686 A:middle
let's figure out
when we can do that.

687
00:36:53.016 --> 00:36:56.506 A:middle
Well, the REPL and the
LLDB command line exist

688
00:36:56.506 --> 00:36:57.926 A:middle
in harmony with one another.

689
00:36:58.706 --> 00:37:03.346 A:middle
You can launch the REPL from a
shell with an empty target just

690
00:37:03.346 --> 00:37:05.976 A:middle
by typing xcrun swift
as I told you earlier.

691
00:37:07.976 --> 00:37:12.136 A:middle
However, also when your
program is stopped at any point,

692
00:37:12.386 --> 00:37:16.366 A:middle
you can type repl and you get
to an REPL prompt just the same.

693
00:37:17.366 --> 00:37:23.896 A:middle
Finally, you can break back into
LLDB by pressing colon enter

694
00:37:24.306 --> 00:37:28.246 A:middle
and that drops you back
into the LLDB prompt.

695
00:37:28.346 --> 00:37:30.386 A:middle
Why this weird colon
enter thing?

696
00:37:31.736 --> 00:37:34.346 A:middle
Well, there's another thing
that colon can do for you.

697
00:37:35.276 --> 00:37:41.366 A:middle
If you're stopped in the REPL,
you can use the colon prefix

698
00:37:42.186 --> 00:37:44.626 A:middle
and type an LLDB
command after it.

699
00:37:45.486 --> 00:37:48.426 A:middle
And that LLDB command
will be executed just

700
00:37:48.426 --> 00:37:50.186 A:middle
as if you typed it
at the LLDB prompt.

701
00:37:50.606 --> 00:37:54.356 A:middle
This is a really handy way
and it shows that really LLDB

702
00:37:54.486 --> 00:37:56.786 A:middle
and the REPL are living
right next to each other.

703
00:37:57.396 --> 00:38:01.356 A:middle
All right, enough
with the explanation,

704
00:38:01.356 --> 00:38:05.106 A:middle
let's go right in to the code.

705
00:38:05.286 --> 00:38:06.506 A:middle
So I've written a function here

706
00:38:07.046 --> 00:38:09.376 A:middle
and it does a partition
of an array.

707
00:38:09.376 --> 00:38:11.876 A:middle
Now you may be asking
yourself, "OK,

708
00:38:11.876 --> 00:38:14.966 A:middle
what kind of partition are
we talking about here?"

709
00:38:15.936 --> 00:38:19.436 A:middle
And maybe you have the
implementation handy

710
00:38:19.436 --> 00:38:20.266 A:middle
or maybe you don't.

711
00:38:20.266 --> 00:38:22.856 A:middle
How can we use the REPL

712
00:38:23.096 --> 00:38:24.916 A:middle
to discover more
about this function?

713
00:38:25.846 --> 00:38:29.126 A:middle
Well, with our program
stopped, we drop into the REPL.

714
00:38:29.176 --> 00:38:33.186 A:middle
And then we can call the
partition function right

715
00:38:33.186 --> 00:38:34.336 A:middle
from there.

716
00:38:34.746 --> 00:38:36.966 A:middle
If we send it the array 3, 4, 5,

717
00:38:37.696 --> 00:38:42.096 A:middle
now what we get back is the
array containing 3 paired

718
00:38:42.096 --> 00:38:44.276 A:middle
with the array containing
4 and 5.

719
00:38:46.016 --> 00:38:47.526 A:middle
All right, this looks
interesting.

720
00:38:48.276 --> 00:38:52.646 A:middle
I guess there's something about
that being the bottom part

721
00:38:52.646 --> 00:38:55.066 A:middle
of the array and the
top part of the array.

722
00:38:55.066 --> 00:38:56.416 A:middle
Let's formalize this.

723
00:38:56.416 --> 00:38:58.466 A:middle
Let's test the theory
about what's going on.

724
00:38:59.026 --> 00:39:05.346 A:middle
What I'm going to do is now
write my own code in the REPL.

725
00:39:06.506 --> 00:39:09.496 A:middle
The expression command is
really great for one liners

726
00:39:09.926 --> 00:39:14.416 A:middle
but the REPL command is
awesome for editing your code

727
00:39:15.176 --> 00:39:17.576 A:middle
and adding entirely
new functions.

728
00:39:18.366 --> 00:39:21.796 A:middle
In this case, we're going to
write an ispartition function.

729
00:39:23.086 --> 00:39:26.706 A:middle
That ispartition function
iterates across all the members

730
00:39:26.706 --> 00:39:30.856 A:middle
of the left-hand array and
checks that they're less than

731
00:39:31.236 --> 00:39:34.156 A:middle
or equal, that they're less
than or equal to the numbers

732
00:39:34.156 --> 00:39:35.016 A:middle
in the right-hand array.

733
00:39:35.696 --> 00:39:38.576 A:middle
If any of them are
greater than a member

734
00:39:38.576 --> 00:39:41.346 A:middle
of the right-hand array, it
says, "Oh, this doesn't look

735
00:39:41.346 --> 00:39:44.546 A:middle
like the kind of partition I was
expecting," and returns false.

736
00:39:46.036 --> 00:39:48.706 A:middle
Finally, once it's checked
everything it returns true.

737
00:39:49.266 --> 00:39:54.316 A:middle
You can run this ispartition
function on the result

738
00:39:54.316 --> 00:39:56.056 A:middle
of partitioning a larger array.

739
00:39:56.056 --> 00:40:00.116 A:middle
And this partition will
tell you indeed that was,

740
00:40:00.316 --> 00:40:01.856 A:middle
the result was a partition.

741
00:40:04.416 --> 00:40:06.206 A:middle
This is something fairly deep.

742
00:40:06.896 --> 00:40:10.776 A:middle
You've got a function that
exists in your code already,

743
00:40:10.906 --> 00:40:13.036 A:middle
you've compiled it using
the Swift compiler.

744
00:40:13.286 --> 00:40:15.306 A:middle
Swift isn't an interpreted
language or anything.

745
00:40:15.786 --> 00:40:18.606 A:middle
But at the same time,
you've used this REPL

746
00:40:18.806 --> 00:40:23.476 A:middle
to interactively test
by adding new code.

747
00:40:25.186 --> 00:40:29.006 A:middle
This is just one of the kinds of
interactive debugging scenarios

748
00:40:29.336 --> 00:40:33.276 A:middle
that we're hoping will change
the way you work with code.

749
00:40:34.266 --> 00:40:36.226 A:middle
Let's look at another example.

750
00:40:37.396 --> 00:40:38.986 A:middle
Using this partition function,

751
00:40:39.236 --> 00:40:42.396 A:middle
I've implemented a sorting
algorithm called mysort.

752
00:40:42.396 --> 00:40:46.316 A:middle
Now I want to validate
that mysort works.

753
00:40:47.066 --> 00:40:50.146 A:middle
Well, I can enter
the REPL again.

754
00:40:50.996 --> 00:40:55.036 A:middle
If I enter the REPL, I
can run mysort on an array

755
00:40:55.036 --> 00:40:58.676 A:middle
and the result is
that the array is --

756
00:40:59.006 --> 00:41:01.866 A:middle
the result is an
array that I can kind

757
00:41:01.866 --> 00:41:03.256 A:middle
of eyeball and see assorted.

758
00:41:03.816 --> 00:41:07.076 A:middle
All right, cool, well it fit
on the slide, it looks sorted

759
00:41:07.076 --> 00:41:09.336 A:middle
to me, this is probably
good enough.

760
00:41:10.776 --> 00:41:14.746 A:middle
But many of your real data
structures aren't going to fit

761
00:41:14.746 --> 00:41:19.756 A:middle
on a slide and you can't easily
eyeball them for correctness.

762
00:41:21.486 --> 00:41:22.866 A:middle
Let's write a function

763
00:41:22.986 --> 00:41:24.906 A:middle
that checks whether
an array is sorted.

764
00:41:26.366 --> 00:41:28.176 A:middle
In the REPL, we just type,

765
00:41:28.316 --> 00:41:30.776 A:middle
we start defining a
function called issorted.

766
00:41:31.526 --> 00:41:33.776 A:middle
The notion here is we're
going to keep track

767
00:41:33.776 --> 00:41:36.086 A:middle
of the previous element
that we saw of the array.

768
00:41:37.436 --> 00:41:40.056 A:middle
And for each element in the
array, we're going to check,

769
00:41:41.056 --> 00:41:44.016 A:middle
is it indeed greater than or
equal to the previous element?

770
00:41:44.976 --> 00:41:48.136 A:middle
If there's ever an element
of the array that is less

771
00:41:48.256 --> 00:41:50.296 A:middle
than the previous
element, then we know,

772
00:41:50.296 --> 00:41:51.406 A:middle
oh this array isn't sorted.

773
00:41:52.696 --> 00:41:56.946 A:middle
Now why are we using an optional
for the previous element?

774
00:41:57.126 --> 00:41:58.606 A:middle
Why is last an optional?

775
00:41:59.476 --> 00:42:01.116 A:middle
Well, the first element

776
00:42:01.116 --> 00:42:03.276 A:middle
of the array doesn't
have a previous element.

777
00:42:03.916 --> 00:42:10.006 A:middle
So the last element in that
case is going to be nil.

778
00:42:10.006 --> 00:42:12.136 A:middle
If I run issorted on the result

779
00:42:12.136 --> 00:42:16.056 A:middle
of using my compiled
mysort function on an array,

780
00:42:16.766 --> 00:42:19.396 A:middle
I see indeed that the mysort
function was implemented

781
00:42:19.886 --> 00:42:22.226 A:middle
correctly for this
case and returned,

782
00:42:22.406 --> 00:42:24.686 A:middle
and the issorted
function returns true.

783
00:42:24.956 --> 00:42:27.416 A:middle
This is the kind of
ad hoc unit testing

784
00:42:27.646 --> 00:42:31.996 A:middle
that I was talking about.

785
00:42:31.996 --> 00:42:33.826 A:middle
Now, let's take another example.

786
00:42:34.946 --> 00:42:38.566 A:middle
But instead of validating
existing code, we'd like to try

787
00:42:38.566 --> 00:42:40.296 A:middle
out some new code
in our program.

788
00:42:40.776 --> 00:42:44.006 A:middle
And this is a good example
to kind of review the role

789
00:42:44.006 --> 00:42:48.026 A:middle
that the expression parser and
the REPL have in your program.

790
00:42:49.366 --> 00:42:52.196 A:middle
When you're running your
program, you have two aspects

791
00:42:52.196 --> 00:42:53.206 A:middle
of your program state.

792
00:42:54.726 --> 00:42:57.016 A:middle
The one aspect is your stack.

793
00:42:57.106 --> 00:42:59.436 A:middle
That's all the functions
that your program is called,

794
00:43:00.306 --> 00:43:03.446 A:middle
all the threads that
you're currently looking at.

795
00:43:03.726 --> 00:43:05.616 A:middle
For investigating those,

796
00:43:05.826 --> 00:43:10.026 A:middle
we think the expression
command is a wonderful tool.

797
00:43:10.196 --> 00:43:14.276 A:middle
However, there's all this
code that you've written

798
00:43:14.756 --> 00:43:16.256 A:middle
that may not be currently
running,

799
00:43:16.256 --> 00:43:19.876 A:middle
you may not have a stack frame
representing it, but you'd still

800
00:43:19.876 --> 00:43:21.706 A:middle
like to play around with it.

801
00:43:22.436 --> 00:43:24.806 A:middle
That's where the
LLDB REPL comes in.

802
00:43:25.326 --> 00:43:28.556 A:middle
They're both built on the
same technology but they both,

803
00:43:28.786 --> 00:43:30.726 A:middle
but they serve distinct
purposes.

804
00:43:30.866 --> 00:43:37.506 A:middle
Let's look at an example,
dispatching on a queue.

805
00:43:39.436 --> 00:43:42.226 A:middle
In my program, I've
imported Foundation

806
00:43:42.386 --> 00:43:45.606 A:middle
and I've declared a
dispatch queue using dispatch

807
00:43:45.736 --> 00:43:46.976 A:middle
queue create.

808
00:43:47.726 --> 00:43:52.916 A:middle
This code has set up a
queue inside my program

809
00:43:53.016 --> 00:43:54.926 A:middle
and I can dispatch
blocks onto it.

810
00:43:56.086 --> 00:43:59.256 A:middle
Well, from the REPL, I
can do the same thing.

811
00:44:00.286 --> 00:44:02.916 A:middle
I stop my program,
enter the REPL,

812
00:44:02.916 --> 00:44:07.366 A:middle
and then I called
dispatch sync on the queue

813
00:44:07.916 --> 00:44:11.776 A:middle
and add a block that
prints "world".

814
00:44:14.036 --> 00:44:16.856 A:middle
Indeed, if I do that, I
get the output "world".

815
00:44:16.906 --> 00:44:20.106 A:middle
Now there's one thing
to remember here.

816
00:44:20.686 --> 00:44:25.786 A:middle
Your program is stopped when
we talk, when we do this.

817
00:44:26.076 --> 00:44:29.266 A:middle
So let's say you had a queue
that was running in your program

818
00:44:30.106 --> 00:44:31.876 A:middle
that was already running
some of your code.

819
00:44:33.116 --> 00:44:35.776 A:middle
Now, if you try to
dispatch to it,

820
00:44:36.536 --> 00:44:38.766 A:middle
that dispatch isn't going
to, that dispatch isn't going

821
00:44:38.766 --> 00:44:41.156 A:middle
to return because there's
something happening

822
00:44:41.156 --> 00:44:41.946 A:middle
on the queue already.

823
00:44:43.836 --> 00:44:47.366 A:middle
What you should do in that case
is dispatch async your block,

824
00:44:48.126 --> 00:44:53.506 A:middle
and then you can continue your
program and your code will run.

825
00:44:53.976 --> 00:44:57.086 A:middle
This is a great way to
manipulate a resource that needs

826
00:44:57.086 --> 00:44:59.546 A:middle
to be serialized on
from the debugger.

827
00:44:59.546 --> 00:45:02.536 A:middle
And actually it lets you
debug in a more safe way.

828
00:45:03.136 --> 00:45:06.016 A:middle
Let's look at another example.

829
00:45:06.616 --> 00:45:11.306 A:middle
In this example,
I've got a protocol.

830
00:45:12.326 --> 00:45:15.286 A:middle
This protocol says, "I'm a type
of thing that can be doubled."

831
00:45:15.286 --> 00:45:20.616 A:middle
And in my code, I've
implemented an extension

832
00:45:20.616 --> 00:45:24.486 A:middle
to this built-in
Swift integer class

833
00:45:24.706 --> 00:45:26.816 A:middle
that makes it be doublable.

834
00:45:27.516 --> 00:45:30.626 A:middle
So calling twice on an
integer now returns 2 times

835
00:45:30.666 --> 00:45:31.186 A:middle
that integer.

836
00:45:32.466 --> 00:45:36.596 A:middle
Using that protocol, I've
implemented a generic function

837
00:45:36.946 --> 00:45:41.086 A:middle
that knows how to get 4 times
something by doubling it twice.

838
00:45:44.256 --> 00:45:46.346 A:middle
The REPL can mess around
with this stuff too.

839
00:45:46.896 --> 00:45:54.406 A:middle
We can write an extension on
the Swift built-in string class

840
00:45:54.616 --> 00:45:57.066 A:middle
that makes it doublable
right in the REPL.

841
00:45:57.756 --> 00:46:02.346 A:middle
We can make twice concatenate
the string with itself

842
00:46:02.346 --> 00:46:04.316 A:middle
and return the result.

843
00:46:04.316 --> 00:46:09.916 A:middle
And then, we can run print,
and then we can run 4 times

844
00:46:09.996 --> 00:46:14.956 A:middle
on the result of that and 4
times works because we're able,

845
00:46:15.016 --> 00:46:17.346 A:middle
the REPL is able to
register that extension.

846
00:46:18.006 --> 00:46:27.086 A:middle
So then we see the output 3,
4 times just as we expected.

847
00:46:27.086 --> 00:46:28.736 A:middle
Now, this is just the beginning.

848
00:46:29.416 --> 00:46:33.336 A:middle
And I'm sure that next year I'm
going to be, or I am or some one

849
00:46:33.336 --> 00:46:35.336 A:middle
of my colleagues is
going to be telling you

850
00:46:35.336 --> 00:46:38.396 A:middle
about all the cool new
debugging workflows

851
00:46:38.586 --> 00:46:42.096 A:middle
that your colleagues have
found and we're going

852
00:46:42.096 --> 00:46:44.096 A:middle
to have a pretty
fantastic session next year.

853
00:46:44.606 --> 00:46:46.606 A:middle
But let's sum up and tell you

854
00:46:46.606 --> 00:46:51.406 A:middle
about what other resources
there are to help you out.

855
00:46:54.086 --> 00:46:57.636 A:middle
LLDB provides great tools to
diagnose bugs in your program.

856
00:46:57.636 --> 00:46:59.836 A:middle
I've told you about
stop reasons, the stack.

857
00:47:00.416 --> 00:47:02.316 A:middle
I've told you about
the print command

858
00:47:02.556 --> 00:47:03.876 A:middle
or expression if you like.

859
00:47:04.376 --> 00:47:05.916 A:middle
I've told you about breakpoints.

860
00:47:06.466 --> 00:47:09.516 A:middle
And I've also told you about
the great new LLDB REPL

861
00:47:09.516 --> 00:47:12.116 A:middle
that lets you debug
in an interactive way,

862
00:47:12.386 --> 00:47:14.406 A:middle
writing your own
code and interacting

863
00:47:14.706 --> 00:47:16.116 A:middle
with your program's
existing code.

864
00:47:16.736 --> 00:47:20.436 A:middle
If you want more information
on this, first of all,

865
00:47:20.436 --> 00:47:23.246 A:middle
you can contact our awesome
Developer Tools Evangelist,

866
00:47:23.306 --> 00:47:24.086 A:middle
Dave DeLong.

867
00:47:24.976 --> 00:47:27.146 A:middle
You can also check out
the Quick Start Guide

868
00:47:27.146 --> 00:47:28.306 A:middle
in our documentation.

869
00:47:28.846 --> 00:47:31.566 A:middle
The LLDB Quick Start Guide
is a fantastic document

870
00:47:31.676 --> 00:47:33.196 A:middle
and it will tell
you lots of stuff

871
00:47:33.196 --> 00:47:34.256 A:middle
that I haven't covered here.

872
00:47:35.026 --> 00:47:38.266 A:middle
Finally, you can communicate
with other developers and chat

873
00:47:38.266 --> 00:47:42.036 A:middle
about LLDB and the kinds
of workflows you discover

874
00:47:42.036 --> 00:47:43.506 A:middle
on the Apple Developer Forums.

875
00:47:44.356 --> 00:47:48.086 A:middle
But that's not all, it turns
out we have a great session

876
00:47:48.086 --> 00:47:49.396 A:middle
for you on Friday morning.

877
00:47:49.956 --> 00:47:52.366 A:middle
It's going to be just the thing
to go with your morning coffee

878
00:47:52.666 --> 00:47:54.996 A:middle
because my colleague,
Enrico Granata is going

879
00:47:54.996 --> 00:47:59.036 A:middle
to tell you some really neat
stuff that LLDB does to help you

880
00:47:59.106 --> 00:48:01.856 A:middle
under the hood in debugging
your Swift programs.

