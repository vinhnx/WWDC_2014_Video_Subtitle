

1
00:00:13.336 --> 00:00:14.186 A:middle
&gt;&gt; So welcome.

2
00:00:14.896 --> 00:00:15.736 A:middle
So, thank you.

3
00:00:21.836 --> 00:00:24.046 A:middle
So my name's Richard
Schreyer, and I've been working

4
00:00:24.046 --> 00:00:26.146 A:middle
on the design of Metal
for quite a while now.

5
00:00:26.146 --> 00:00:28.246 A:middle
And it's really exciting
to finally be able

6
00:00:28.246 --> 00:00:29.206 A:middle
to talk to all of you about.

7
00:00:29.536 --> 00:00:31.826 A:middle
So this is the Metal
fundamental session.

8
00:00:32.016 --> 00:00:35.396 A:middle
It's the second in our trio of
sessions, following concepts

9
00:00:35.466 --> 00:00:37.816 A:middle
and to be followed by
Metal advanced usage.

10
00:00:38.036 --> 00:00:42.276 A:middle
So this session is going to
be split into two major parts.

11
00:00:43.036 --> 00:00:45.306 A:middle
The first half which I'm going
to present is going to be how

12
00:00:45.306 --> 00:00:47.126 A:middle
to build a basic
Metal application.

13
00:00:48.056 --> 00:00:49.686 A:middle
I want to take all
of the concepts

14
00:00:49.686 --> 00:00:50.736 A:middle
that Jeremy just described,

15
00:00:50.876 --> 00:00:52.946 A:middle
a bunch of block
diagrams and arrows.

16
00:00:53.376 --> 00:00:54.956 A:middle
And turn those into actual code.

17
00:00:55.646 --> 00:00:57.986 A:middle
So, we'll try to make
everything more concrete.

18
00:00:59.636 --> 00:01:01.126 A:middle
During the second
half of the session,

19
00:01:01.126 --> 00:01:03.176 A:middle
I'm going to turn the stage over
to my colleague Aafi [phonetic],

20
00:01:03.176 --> 00:01:05.196 A:middle
who will take you
into a deep dive

21
00:01:05.266 --> 00:01:06.496 A:middle
into the Metal shading language.

22
00:01:07.076 --> 00:01:10.366 A:middle
Talk about, you know, the
various syntax and data types.

23
00:01:10.366 --> 00:01:12.736 A:middle
How to express vertex,
pixel and compute shaders.

24
00:01:12.996 --> 00:01:15.246 A:middle
And then a bunch of grab bag
of other interesting topics.

25
00:01:16.236 --> 00:01:19.176 A:middle
So, getting right into
building a Metal application.

26
00:01:19.176 --> 00:01:24.186 A:middle
So as I said, this is going to
be a fairly, a set of slides

27
00:01:24.716 --> 00:01:26.376 A:middle
that are fairly heavy on code.

28
00:01:26.496 --> 00:01:29.036 A:middle
That's really what I want to
try to get across is, you know,

29
00:01:29.146 --> 00:01:31.906 A:middle
what you're going to actually
want to put down in Xcode.

30
00:01:32.106 --> 00:01:33.986 A:middle
So I'm going to try and
keep this application

31
00:01:33.986 --> 00:01:34.896 A:middle
as simple as possible.

32
00:01:34.896 --> 00:01:36.946 A:middle
So it's going to be a very
hello world kind of thing.

33
00:01:37.416 --> 00:01:40.576 A:middle
So in the interest of, is it
always that way in graphics?

34
00:01:40.576 --> 00:01:41.836 A:middle
So the application I'm going

35
00:01:41.836 --> 00:01:43.616 A:middle
to build is basically
just a triangle.

36
00:01:43.616 --> 00:01:45.456 A:middle
We're going to go
through all the steps

37
00:01:45.456 --> 00:01:47.896 A:middle
to go put a single shaded
triangle on the screen.

38
00:01:48.086 --> 00:01:49.896 A:middle
I know, really exciting stuff.

39
00:01:51.476 --> 00:01:54.016 A:middle
But it's actually pretty cool
because, and we're going to go

40
00:01:54.016 --> 00:01:56.136 A:middle
through some boiler
plate and some setup.

41
00:01:56.136 --> 00:01:57.306 A:middle
But once you get through that,

42
00:01:57.306 --> 00:01:58.936 A:middle
that's really the same
foundation you need

43
00:01:58.936 --> 00:02:01.276 A:middle
to start building immediately
a much more complex content

44
00:02:01.276 --> 00:02:01.886 A:middle
on top of that.

45
00:02:02.536 --> 00:02:05.016 A:middle
So we're not going out of our
way to draw such a triangle.

46
00:02:07.226 --> 00:02:08.985 A:middle
So the first set of
things I'm going to go

47
00:02:08.985 --> 00:02:10.616 A:middle
through are just
the initialization.

48
00:02:10.616 --> 00:02:12.556 A:middle
I mean what's the
one-shot setup you'll do

49
00:02:12.646 --> 00:02:14.646 A:middle
when your application launches
or you start using Metal?

50
00:02:15.646 --> 00:02:17.686 A:middle
Then I'll get into the
contents of what, you know,

51
00:02:17.686 --> 00:02:18.996 A:middle
the actual drawing
will look like.

52
00:02:19.736 --> 00:02:22.356 A:middle
And then we'll get on to
extending the application

53
00:02:22.356 --> 00:02:23.806 A:middle
to do a little bit more stuff.

54
00:02:23.906 --> 00:02:26.256 A:middle
So these are the
steps that we'll walk

55
00:02:26.256 --> 00:02:27.346 A:middle
through in the code in order.

56
00:02:28.546 --> 00:02:30.506 A:middle
So right at the top
is getting the device.

57
00:02:31.106 --> 00:02:32.506 A:middle
So what is the device API?

58
00:02:33.286 --> 00:02:37.586 A:middle
So Metal, a device is sort of
the root object of a whole API.

59
00:02:37.586 --> 00:02:40.656 A:middle
It's your direct connection

60
00:02:40.656 --> 00:02:42.916 A:middle
to the GPU driver
and the GPU hardware.

61
00:02:43.616 --> 00:02:46.226 A:middle
Now as far as the actual API
that the device sends out,

62
00:02:46.886 --> 00:02:50.226 A:middle
what it really does directly,
it's the source that you go

63
00:02:50.226 --> 00:02:52.556 A:middle
to to create all the other
objects in the Metal API.

64
00:02:53.786 --> 00:02:56.856 A:middle
So if you want to go create
a new texture or a new buffer

65
00:02:56.856 --> 00:02:59.146 A:middle
or a new RenderPipeline,
the device is

66
00:02:59.146 --> 00:02:59.876 A:middle
where you'll find that.

67
00:03:01.006 --> 00:03:02.826 A:middle
So, we want to go
create some stuff,

68
00:03:02.826 --> 00:03:04.616 A:middle
and so we need a device
to create them on.

69
00:03:05.236 --> 00:03:05.966 A:middle
So that's really easy.

70
00:03:06.026 --> 00:03:09.016 A:middle
So our first initialization
step is to just say hey,

71
00:03:09.096 --> 00:03:12.396 A:middle
I want the default device.

72
00:03:13.196 --> 00:03:17.046 A:middle
Our second initialization step
is we need a command queue.

73
00:03:18.126 --> 00:03:20.996 A:middle
The CommandQueue is our channel
to submit work to the GPU.

74
00:03:21.726 --> 00:03:24.036 A:middle
Now we're not actually going
to do any of that until we get

75
00:03:24.036 --> 00:03:26.156 A:middle
to drawing, so I'm going to
create a CommandQueue now

76
00:03:26.446 --> 00:03:28.566 A:middle
from the device and
save it aside.

77
00:03:29.166 --> 00:03:35.086 A:middle
The third initialization step is
to go create all of my buffers

78
00:03:35.086 --> 00:03:37.536 A:middle
and textures and
other resources.

79
00:03:38.316 --> 00:03:40.576 A:middle
My application is simple enough
that I have exactly one of them.

80
00:03:40.576 --> 00:03:41.416 A:middle
I need a vertexArray.

81
00:03:41.416 --> 00:03:44.166 A:middle
And so I'm going to
go back to the device

82
00:03:44.366 --> 00:03:45.866 A:middle
yet again and say newbuffer.

83
00:03:46.646 --> 00:03:48.886 A:middle
This particular variance
will go allocate a new block

84
00:03:48.886 --> 00:03:52.256 A:middle
of CPU/GPU shared memory, copy
the provided pointer into it,

85
00:03:52.256 --> 00:03:53.916 A:middle
and give me back a
handle to that buffer.

86
00:03:55.376 --> 00:03:57.136 A:middle
So right off the bat
we've gotten through three

87
00:03:57.136 --> 00:03:58.696 A:middle
of our five initialization
steps.

88
00:03:58.696 --> 00:03:59.706 A:middle
We're making pretty good time.

89
00:04:00.586 --> 00:04:02.706 A:middle
The fourth one is going to
be quite a bit more involved.

90
00:04:02.706 --> 00:04:04.266 A:middle
We're going to spend
some time on that one.

91
00:04:04.816 --> 00:04:06.806 A:middle
And that is creating
the RenderPipeline.

92
00:04:07.416 --> 00:04:09.176 A:middle
So is all.

93
00:04:09.576 --> 00:04:11.396 A:middle
So as we saw in the
concepts session,

94
00:04:12.336 --> 00:04:14.366 A:middle
the RenderPipeline
is a collection

95
00:04:14.366 --> 00:04:15.706 A:middle
of quite a bit of stuff.

96
00:04:15.976 --> 00:04:19.096 A:middle
Most importantly, the vertex
and the fragment shaders,

97
00:04:19.896 --> 00:04:22.396 A:middle
but it also incorporates
every other piece of state

98
00:04:22.396 --> 00:04:24.006 A:middle
that the shader compiler needs

99
00:04:24.006 --> 00:04:27.346 A:middle
to generate the final
machine code for the A7.

100
00:04:27.896 --> 00:04:29.926 A:middle
That includes some
information on vertex layout,

101
00:04:30.236 --> 00:04:33.146 A:middle
some rasterizer configuration,
all of the framebuffer,

102
00:04:33.146 --> 00:04:35.226 A:middle
blend modes, and
some information

103
00:04:35.226 --> 00:04:36.846 A:middle
about the framebuffer
configuration

104
00:04:36.966 --> 00:04:37.966 A:middle
that this pipeline will draw to.

105
00:04:38.086 --> 00:04:41.486 A:middle
That's actually quite
a bit of stuff.

106
00:04:41.986 --> 00:04:43.756 A:middle
And so we've split
the RenderPipeline

107
00:04:43.756 --> 00:04:45.216 A:middle
into two separate objects.

108
00:04:45.636 --> 00:04:48.596 A:middle
The RenderPipeline
descriptor, which is your object

109
00:04:48.666 --> 00:04:50.506 A:middle
that provides all the
configuration API,

110
00:04:50.506 --> 00:04:56.036 A:middle
and the RenderPipeline
state, which is the sort

111
00:04:56.036 --> 00:04:59.186 A:middle
of baked finalized form of
that, that's just small.

112
00:04:59.186 --> 00:05:02.526 A:middle
It's compact, and they're
really cheap to switch between.

113
00:05:03.916 --> 00:05:05.706 A:middle
So let's go look at
the code to build,

114
00:05:05.706 --> 00:05:07.226 A:middle
I'm going to build
one RenderPipeline

115
00:05:07.226 --> 00:05:12.536 A:middle
in this application, so
let's go look at the code.

116
00:05:12.646 --> 00:05:15.186 A:middle
So first, I'm going to
conjure up a new descriptor.

117
00:05:16.286 --> 00:05:18.686 A:middle
And the very first things I'm
going to set on it are my vertex

118
00:05:18.686 --> 00:05:19.916 A:middle
and my fragment shaders.

119
00:05:21.736 --> 00:05:23.946 A:middle
And you'll notice that I'm not
providing any source code here.

120
00:05:24.476 --> 00:05:26.516 A:middle
So this is what the
runtime in API looks

121
00:05:26.516 --> 00:05:29.246 A:middle
like when Xcode builds your
shaders offline for you.

122
00:05:29.546 --> 00:05:32.596 A:middle
Xcode's going to package up
all of the offline belt shaders

123
00:05:33.046 --> 00:05:35.056 A:middle
into a device independent
bicode file.

124
00:05:35.866 --> 00:05:37.726 A:middle
And ship that into your
application bundle.

125
00:05:37.776 --> 00:05:40.256 A:middle
And at runtime I can
go ask the device

126
00:05:40.256 --> 00:05:41.716 A:middle
to load that default library.

127
00:05:43.266 --> 00:05:45.556 A:middle
Once I have that, I can
go start taking functions

128
00:05:45.556 --> 00:05:46.496 A:middle
out of that by name.

129
00:05:49.256 --> 00:05:51.216 A:middle
The second piece of
configuration I need

130
00:05:51.216 --> 00:05:53.726 A:middle
on the RenderPipeline is
the frame buffer format.

131
00:05:54.256 --> 00:05:58.256 A:middle
So, I'm only going to have one
color attachment I'm rendering

132
00:05:58.256 --> 00:06:00.436 A:middle
to, and so I'm going to
say hey, this is going

133
00:06:00.436 --> 00:06:01.946 A:middle
to be a BGRA render target.

134
00:06:03.086 --> 00:06:06.816 A:middle
A RenderPipeline has a whole
bunch of other stuff I can set

135
00:06:06.816 --> 00:06:08.906 A:middle
on it, but for my simple
little application,

136
00:06:09.356 --> 00:06:10.536 A:middle
that's really all I need.

137
00:06:10.946 --> 00:06:13.336 A:middle
The default values of all
the other properties are

138
00:06:13.336 --> 00:06:14.276 A:middle
already appropriate.

139
00:06:14.676 --> 00:06:19.096 A:middle
So I'm going to go ahead and
compile and ask the device

140
00:06:19.096 --> 00:06:20.656 A:middle
to compile a RenderPipeline
state.

141
00:06:20.896 --> 00:06:21.946 A:middle
I'll just go to the device

142
00:06:21.946 --> 00:06:25.426 A:middle
and call newRenderPipelineState
WithDescriptor.

143
00:06:26.706 --> 00:06:28.386 A:middle
So this is actually
the expensive API.

144
00:06:29.166 --> 00:06:31.646 A:middle
This is the API that is
going to, if necessary,

145
00:06:31.976 --> 00:06:33.466 A:middle
go call over to the
shader compiler

146
00:06:33.676 --> 00:06:37.416 A:middle
and finish the code generation,
taking into account all

147
00:06:37.416 --> 00:06:40.506 A:middle
of the other information
that you have provided.

148
00:06:40.576 --> 00:06:42.976 A:middle
Once we have this
RenderPipeline, now you,

149
00:06:43.076 --> 00:06:44.586 A:middle
you know it's all baked.

150
00:06:44.586 --> 00:06:46.466 A:middle
It's all finalized, and
we can toggle between them

151
00:06:46.466 --> 00:06:48.476 A:middle
at draw time very, very cheaply.

152
00:06:48.956 --> 00:06:51.846 A:middle
So that's our fourth
initialization step,

153
00:06:52.416 --> 00:06:53.496 A:middle
building the RenderPipeline.

154
00:06:53.916 --> 00:06:57.436 A:middle
But before I move on from that,
you know, since we're pointing

155
00:06:57.436 --> 00:06:58.946 A:middle
at our vertex and
fragment shader here,

156
00:06:59.426 --> 00:07:01.336 A:middle
I do want to take a
really quick little detour

157
00:07:01.336 --> 00:07:04.066 A:middle
and show you the vertex and
fragment shader code itself.

158
00:07:04.836 --> 00:07:08.296 A:middle
So I'm not going to explain to
you every part of the syntax,

159
00:07:08.326 --> 00:07:11.086 A:middle
because Aafi is going to
tell you all about that

160
00:07:11.086 --> 00:07:12.126 A:middle
in just a few minutes.

161
00:07:12.876 --> 00:07:15.486 A:middle
But I'm going to show you
just, I'm going to focus

162
00:07:15.486 --> 00:07:18.696 A:middle
on just the dataflow from the
vertexArray through the vertex

163
00:07:18.696 --> 00:07:20.896 A:middle
and fragment shader and
into the frame buffer.

164
00:07:21.616 --> 00:07:24.826 A:middle
So, I split this
up into two slides.

165
00:07:24.826 --> 00:07:26.686 A:middle
My first slide are
a couple structures

166
00:07:26.976 --> 00:07:29.276 A:middle
that describe the input and
output of the vertex shader.

167
00:07:30.156 --> 00:07:34.066 A:middle
The vertex structure defines
how my vertexArray is laid

168
00:07:34.066 --> 00:07:34.586 A:middle
out in memory.

169
00:07:34.956 --> 00:07:39.186 A:middle
Position followed by a color.

170
00:07:39.376 --> 00:07:40.366 A:middle
My vertex shader is going

171
00:07:40.366 --> 00:07:42.086 A:middle
to be a really simple
pass-through shader.

172
00:07:42.086 --> 00:07:44.666 A:middle
I'm going to read my position
color from the vertexArray

173
00:07:44.666 --> 00:07:47.226 A:middle
and pass them right out
down the pipeline unchanged.

174
00:07:47.556 --> 00:07:51.656 A:middle
So, unsurprisingly, my
vertex out-struct looks,

175
00:07:51.886 --> 00:07:52.826 A:middle
well, just like it.

176
00:07:53.376 --> 00:07:56.766 A:middle
The only difference is that
the rasterizer needs to know

177
00:07:56.766 --> 00:07:58.266 A:middle
which of the outputs
is the position,

178
00:07:58.266 --> 00:07:59.966 A:middle
so we have to use an attribute

179
00:08:00.096 --> 00:08:03.126 A:middle
to identify that
to the compiler.

180
00:08:03.206 --> 00:08:05.556 A:middle
All of the other outputs
will get interpolated

181
00:08:05.556 --> 00:08:06.766 A:middle
across the triangle as usual.

182
00:08:06.766 --> 00:08:12.996 A:middle
So on to the body of
the vertex shader.

183
00:08:13.226 --> 00:08:15.866 A:middle
So here's my simple
pass-through VertexShader.

184
00:08:16.766 --> 00:08:21.226 A:middle
So we have a sort a
C-style declaration

185
00:08:21.256 --> 00:08:22.606 A:middle
with some extra key
words and attributes.

186
00:08:22.606 --> 00:08:23.906 A:middle
We'll go into more
detail into later.

187
00:08:24.806 --> 00:08:27.316 A:middle
But I'm getting a
pointer to my vertexArray

188
00:08:28.076 --> 00:08:31.036 A:middle
into my VertexShader, along
with a vertex ID that tells me

189
00:08:31.296 --> 00:08:32.246 A:middle
which of the three vertexes

190
00:08:32.246 --> 00:08:33.686 A:middle
that this thread is
going to be processing.

191
00:08:36.416 --> 00:08:38.645 A:middle
From those I'm going to
read from the vertexArray,

192
00:08:39.035 --> 00:08:44.456 A:middle
copy to the output struct, and
I'm going to return an instance

193
00:08:44.456 --> 00:08:45.636 A:middle
of the vertex out-struct.

194
00:08:45.636 --> 00:08:50.406 A:middle
So this is sort of in comparison
to GLSL where all of the inputs

195
00:08:50.406 --> 00:08:52.016 A:middle
and outputs are specified
as global scope.

196
00:08:52.076 --> 00:08:55.036 A:middle
In the Metal shading language,
all of your inputs come

197
00:08:55.036 --> 00:08:56.146 A:middle
in via function arguments.

198
00:08:56.296 --> 00:08:59.206 A:middle
All of your outputs are
returned via the C return pipe.

199
00:08:59.856 --> 00:09:02.496 A:middle
Okay. This guy likes that.

200
00:09:04.326 --> 00:09:07.236 A:middle
So now the FragmentShader
is of course even easier.

201
00:09:07.956 --> 00:09:12.246 A:middle
The input to my FragmentShader
is again, a single argument.

202
00:09:12.666 --> 00:09:14.776 A:middle
In this case the same
VertexOut structs,

203
00:09:14.776 --> 00:09:16.066 A:middle
the VertexShader just returned.

204
00:09:16.976 --> 00:09:19.226 A:middle
Except now it contains
an interpolated position

205
00:09:19.776 --> 00:09:21.016 A:middle
and an interpolated color.

206
00:09:21.016 --> 00:09:23.136 A:middle
So I'm going to go
read my color.

207
00:09:23.136 --> 00:09:25.886 A:middle
And I'm going to return a
float4, which will write

208
00:09:25.886 --> 00:09:26.646 A:middle
into the frame buffer.

209
00:09:27.426 --> 00:09:29.556 A:middle
And because we told
them to put it

210
00:09:29.556 --> 00:09:31.446 A:middle
in the pipeline state what
the frame buffer for it is,

211
00:09:31.826 --> 00:09:33.706 A:middle
the compiler knows how it
needs to pack this down

212
00:09:33.706 --> 00:09:35.956 A:middle
and compress it to the
actual frame buffer format.

213
00:09:36.516 --> 00:09:39.786 A:middle
So that's the vertex
and frag pass

214
00:09:40.016 --> 00:09:41.346 A:middle
through vertex and
FragmentShaders.

215
00:09:41.816 --> 00:09:44.646 A:middle
And that's really the end of
how to build a RenderPipeline.

216
00:09:45.026 --> 00:09:47.766 A:middle
The one last bit are just the
function names themselves,

217
00:09:47.826 --> 00:09:49.976 A:middle
which are the strings that are
used to pull up these functions

218
00:09:49.976 --> 00:09:51.336 A:middle
up when building
another pipeline.

219
00:09:51.916 --> 00:09:59.946 A:middle
So our fifth and final step to
initialize is creating the view.

220
00:10:00.346 --> 00:10:03.136 A:middle
So if you've been working
on iOS for a while,

221
00:10:03.136 --> 00:10:05.576 A:middle
you're probably aware that
if you want to get anything

222
00:10:05.726 --> 00:10:08.316 A:middle
on the screen, it
basically needs to be part

223
00:10:08.316 --> 00:10:09.646 A:middle
of a core animation layer tree.

224
00:10:10.546 --> 00:10:13.566 A:middle
So, iOS 8 provides
a new subclass

225
00:10:13.566 --> 00:10:15.606 A:middle
of CA layer called CAMetalLayer.

226
00:10:16.796 --> 00:10:18.436 A:middle
And that class is
really interesting

227
00:10:18.476 --> 00:10:20.746 A:middle
because it can vend
out textures.

228
00:10:20.746 --> 00:10:23.266 A:middle
It will manage a swap chain
of typically three textures,

229
00:10:23.266 --> 00:10:24.756 A:middle
and you can ask for the
next one in the chain.

230
00:10:25.276 --> 00:10:27.576 A:middle
And I can say give me a
texture, render into it,

231
00:10:27.576 --> 00:10:29.626 A:middle
and when I'm done
I can push it back

232
00:10:29.626 --> 00:10:30.816 A:middle
to be swapped on to the display.

233
00:10:32.116 --> 00:10:34.046 A:middle
To create a layer,

234
00:10:34.126 --> 00:10:36.676 A:middle
that's typically owned
by a UIView subclass.

235
00:10:37.306 --> 00:10:38.806 A:middle
I'm going to show you a very,

236
00:10:38.886 --> 00:10:41.826 A:middle
very bare bones UIView
subclass on the next slide.

237
00:10:42.216 --> 00:10:44.156 A:middle
And you can find a much
more complete implementation

238
00:10:44.156 --> 00:10:46.146 A:middle
with a bunch of functionality
in our sample code.

239
00:10:46.816 --> 00:10:50.066 A:middle
And then because this is
iOS, and this is you know,

240
00:10:50.206 --> 00:10:52.676 A:middle
entirely typical, your view
is then typically owned

241
00:10:52.676 --> 00:10:54.946 A:middle
by UIViewController, which is
usually typically completely

242
00:10:54.946 --> 00:10:56.066 A:middle
custom to your application.

243
00:10:56.526 --> 00:10:59.726 A:middle
So let's go look at our
really bare bones view.

244
00:11:01.406 --> 00:11:03.696 A:middle
So really this is all
you really need to do.

245
00:11:03.826 --> 00:11:05.226 A:middle
I need to subclass UIView,

246
00:11:05.596 --> 00:11:07.376 A:middle
and I need to override
the layer class method

247
00:11:07.376 --> 00:11:11.046 A:middle
and say I want this view to
own a Metal layer as opposed

248
00:11:11.046 --> 00:11:12.906 A:middle
to any other kind of layer.

249
00:11:13.636 --> 00:11:16.356 A:middle
There is some other
configuration we could do

250
00:11:16.456 --> 00:11:17.586 A:middle
on this view in this layer,

251
00:11:18.026 --> 00:11:20.546 A:middle
primarily for efficient
compositing.

252
00:11:20.856 --> 00:11:22.756 A:middle
But this is really the
bare minimum that you need

253
00:11:22.756 --> 00:11:23.866 A:middle
to get something
on to the screen.

254
00:11:24.416 --> 00:11:27.976 A:middle
So with that, we've been
through all five our

255
00:11:27.976 --> 00:11:28.996 A:middle
initialization steps.

256
00:11:29.636 --> 00:11:34.556 A:middle
We breezed through getting the
device, getting a command queue,

257
00:11:34.816 --> 00:11:36.546 A:middle
and creating a resource.

258
00:11:37.056 --> 00:11:40.256 A:middle
Spent a little bit of time on
the RenderPipeline descriptor

259
00:11:40.556 --> 00:11:41.636 A:middle
and RenderPipelineState.

260
00:11:42.636 --> 00:11:43.856 A:middle
Also looked at the shaders.

261
00:11:43.856 --> 00:11:46.166 A:middle
And then we created a view.

262
00:11:46.246 --> 00:11:50.216 A:middle
So with that we can
actually even draw something.

263
00:11:50.756 --> 00:11:52.786 A:middle
And that has a few more steps.

264
00:11:52.786 --> 00:11:58.856 A:middle
So, we need to get a command
buffer, since all of our work

265
00:11:58.856 --> 00:12:02.056 A:middle
that goes to the GPU will be
enqueued into a command buffer.

266
00:12:02.796 --> 00:12:04.826 A:middle
We're going to encode a
render to texture pass

267
00:12:05.096 --> 00:12:06.046 A:middle
into that command buffer.

268
00:12:06.046 --> 00:12:08.216 A:middle
We're going to put some stuff
in that render texture pass.

269
00:12:08.926 --> 00:12:10.596 A:middle
And then finally we're going
to send that CommandBuffer

270
00:12:10.746 --> 00:12:12.306 A:middle
to the GPU hardware
to be executed.

271
00:12:13.516 --> 00:12:15.266 A:middle
So, step 1, getting
the CommandBuffer.

272
00:12:16.176 --> 00:12:17.116 A:middle
That's another one-liner.

273
00:12:18.166 --> 00:12:19.566 A:middle
You can simply go
to the command queue

274
00:12:19.886 --> 00:12:22.246 A:middle
and say give me the next
available CommandBuffer.

275
00:12:22.896 --> 00:12:28.736 A:middle
The second step is setting
up my render to texture pass.

276
00:12:29.726 --> 00:12:33.056 A:middle
One thing that sets Metal apart
from other graphic APIs is

277
00:12:33.056 --> 00:12:35.806 A:middle
that we have a sort of
very rigorous definition

278
00:12:35.806 --> 00:12:38.846 A:middle
of when a rendered texture
pass begins and when it ends.

279
00:12:39.436 --> 00:12:41.336 A:middle
And when you start a
render to texture pass,

280
00:12:41.906 --> 00:12:43.586 A:middle
we require that you tell us all

281
00:12:43.586 --> 00:12:45.456 A:middle
of the frame buffer
configuration right up front

282
00:12:45.776 --> 00:12:47.206 A:middle
so we know how to
configure the hardware.

283
00:12:48.506 --> 00:12:52.696 A:middle
And most of what goes into
that configuration looks a lot

284
00:12:52.696 --> 00:12:54.506 A:middle
like a frame buffer
object in open GL.

285
00:12:55.226 --> 00:12:58.066 A:middle
There's, you know, what color
textures am I rendering too?

286
00:12:58.266 --> 00:12:59.056 A:middle
Up to four of those.

287
00:12:59.056 --> 00:12:59.846 A:middle
What depth texture?

288
00:12:59.846 --> 00:13:00.786 A:middle
What stencil texture?

289
00:13:00.786 --> 00:13:04.466 A:middle
Which bitmap levels that, the
load actions and store actions

290
00:13:04.466 --> 00:13:05.806 A:middle
that you saw in Jeremy's
presentation.

291
00:13:06.426 --> 00:13:10.396 A:middle
So given that there's so much
configuration that happens here,

292
00:13:11.406 --> 00:13:14.416 A:middle
we've again taken that
and packaged it all

293
00:13:14.416 --> 00:13:17.246 A:middle
up into a descriptor to do
convenient configuration on.

294
00:13:18.056 --> 00:13:20.136 A:middle
And then once you have
the descriptor configured,

295
00:13:20.416 --> 00:13:23.766 A:middle
you can then create the
render to texture pass.

296
00:13:23.966 --> 00:13:25.216 A:middle
So, putting that into code.

297
00:13:25.706 --> 00:13:29.916 A:middle
Right at the top we need to
know what texture we're going

298
00:13:29.916 --> 00:13:30.666 A:middle
to render into.

299
00:13:30.786 --> 00:13:33.286 A:middle
So we're actually going to
go back to our CA MetalLayer

300
00:13:33.286 --> 00:13:35.736 A:middle
and say give me the
next available drawable.

301
00:13:35.736 --> 00:13:39.176 A:middle
And a drawable is pretty
much just a wraparound

302
00:13:39.176 --> 00:13:41.346 A:middle
to texture plus a little
bit of extra bookkeeping.

303
00:13:42.876 --> 00:13:45.956 A:middle
This is one of the very
few API calls in Metal

304
00:13:45.956 --> 00:13:47.486 A:middle
that will actually
block your application

305
00:13:47.806 --> 00:13:49.396 A:middle
if there's no more
available textures

306
00:13:49.396 --> 00:13:51.256 A:middle
in the swap chain,
if they're all busy.

307
00:13:51.976 --> 00:13:53.466 A:middle
So this could block
and wait awhile,

308
00:13:53.466 --> 00:13:54.646 A:middle
especially if you're GPU bound.

309
00:13:55.006 --> 00:14:00.256 A:middle
Next, I want to set up
my RenderPass Descriptor.

310
00:14:01.206 --> 00:14:02.906 A:middle
I'm going to point
color attachment zero

311
00:14:02.906 --> 00:14:04.276 A:middle
at my drawables texture.

312
00:14:04.436 --> 00:14:06.516 A:middle
I'm going to configure
the RenderPass

313
00:14:06.856 --> 00:14:09.246 A:middle
such that it will clear
that texture at the start

314
00:14:09.246 --> 00:14:12.076 A:middle
of the pass, preventing
the existing contents

315
00:14:12.076 --> 00:14:14.496 A:middle
of that texture from being
loaded into the GPU tiles cache.

316
00:14:14.796 --> 00:14:16.616 A:middle
And then I'm going to
then actually, you know,

317
00:14:16.616 --> 00:14:20.216 A:middle
I'm going to choose some really
boring array to clear it to.

318
00:14:20.886 --> 00:14:23.546 A:middle
So again, if I had a
more complex frame buffer

319
00:14:23.546 --> 00:14:25.826 A:middle
configuration, there would be a
bunch more similar stuff here.

320
00:14:25.896 --> 00:14:27.386 A:middle
But again, that's
all I really need

321
00:14:27.386 --> 00:14:29.386 A:middle
for my hello world application.

322
00:14:29.806 --> 00:14:32.656 A:middle
So now I can go to the
CommandBuffer, and I can say,

323
00:14:32.876 --> 00:14:34.926 A:middle
the next thing on
this CommandBuffer is

324
00:14:34.986 --> 00:14:35.846 A:middle
a renderCommand.

325
00:14:36.686 --> 00:14:37.536 A:middle
Here's the descriptor.

326
00:14:37.886 --> 00:14:40.056 A:middle
Give me back the interface
I can use to encode.

327
00:14:40.906 --> 00:14:43.996 A:middle
And this renderCommand encoder
you're getting back is the

328
00:14:43.996 --> 00:14:45.046 A:middle
object that has most

329
00:14:45.046 --> 00:14:47.976 A:middle
of the traditional 3D graphics
API you're expecting to find.

330
00:14:48.346 --> 00:14:50.016 A:middle
Things like setting
the depth stencil state

331
00:14:50.226 --> 00:14:53.176 A:middle
and binding textures and
colNodes and all that stuff.

332
00:14:54.346 --> 00:14:58.586 A:middle
So let's go actually
draw our triangle out.

333
00:14:58.856 --> 00:15:01.946 A:middle
So previously I created
my RenderPipeline,

334
00:15:01.946 --> 00:15:03.316 A:middle
and I created my vertexArray.

335
00:15:03.516 --> 00:15:04.596 A:middle
So I want to set them both here.

336
00:15:04.996 --> 00:15:06.276 A:middle
Which RenderPipeline
we're going to use.

337
00:15:06.506 --> 00:15:07.526 A:middle
And I'm going to say, I'm going

338
00:15:07.526 --> 00:15:08.796 A:middle
to point right at
the vertexArray.

339
00:15:09.056 --> 00:15:10.706 A:middle
And I can finally
encode the command

340
00:15:10.806 --> 00:15:12.106 A:middle
to draw my simple triangle.

341
00:15:13.556 --> 00:15:16.446 A:middle
So now we've gotten
through our third step

342
00:15:16.446 --> 00:15:17.356 A:middle
of drawing a triangle.

343
00:15:17.456 --> 00:15:19.056 A:middle
And now we get to the final one,

344
00:15:19.306 --> 00:15:20.786 A:middle
committing the CommandBuffer
to the GPU.

345
00:15:21.436 --> 00:15:26.066 A:middle
At this point we have basically
a fully formed CommandBuffer

346
00:15:26.066 --> 00:15:27.426 A:middle
just sitting in memory idle.

347
00:15:27.426 --> 00:15:30.766 A:middle
It's not going, GPU
will not start executing

348
00:15:30.806 --> 00:15:31.566 A:middle
until you've committed.

349
00:15:32.566 --> 00:15:35.346 A:middle
So before we do that
though, we actually want

350
00:15:35.346 --> 00:15:38.336 A:middle
to do one more thing
and tell CoreAnimation

351
00:15:38.696 --> 00:15:40.376 A:middle
when you actually want
to present this texture.

352
00:15:40.866 --> 00:15:43.586 A:middle
Because we got a texture from
CoreAnimation, and now we need

353
00:15:43.586 --> 00:15:46.716 A:middle
to tell CA when we can
display that texture safely.

354
00:15:47.646 --> 00:15:48.936 A:middle
Because we haven't
rendered anything yet,

355
00:15:49.116 --> 00:15:49.926 A:middle
now's not the time.

356
00:15:50.866 --> 00:15:54.836 A:middle
So we want to be able to, and
so this API addPresent will set

357
00:15:54.836 --> 00:15:58.086 A:middle
up an automatic notification
from Metal to CoreAnimation

358
00:15:58.536 --> 00:16:02.206 A:middle
that when this rendering is
complete, it will cross call

359
00:16:02.206 --> 00:16:03.596 A:middle
into CoreAnimation and say,

360
00:16:03.996 --> 00:16:05.386 A:middle
it's time to put this
on the display now.

361
00:16:06.046 --> 00:16:09.476 A:middle
And then finally we
have the big red button.

362
00:16:10.216 --> 00:16:13.096 A:middle
You call commit, and this
CommandBuffer gets encoded,

363
00:16:13.096 --> 00:16:15.026 A:middle
gets enqueued into the
end of the command queue,

364
00:16:15.386 --> 00:16:17.266 A:middle
and it will execute
on the GPU hardware.

365
00:16:17.896 --> 00:16:23.836 A:middle
So that is all of the steps to
go and draw my single triangle.

366
00:16:24.676 --> 00:16:28.676 A:middle
We needed to get a command
buffer, configure a render pass

367
00:16:28.676 --> 00:16:30.936 A:middle
with one target texture that
we got from CoreAnimation,

368
00:16:32.256 --> 00:16:34.286 A:middle
draw my triangle
with the vertexArray

369
00:16:34.286 --> 00:16:35.116 A:middle
and a pipeline state.

370
00:16:35.396 --> 00:16:38.706 A:middle
And commit the command encoder.

371
00:16:40.636 --> 00:16:42.326 A:middle
So that's my triangle.

372
00:16:42.546 --> 00:16:43.906 A:middle
That's pretty much all
the codes you need.

373
00:16:44.406 --> 00:16:51.466 A:middle
Go do it. So it's kind
of a boring application.

374
00:16:51.706 --> 00:16:54.446 A:middle
So let's add at least
one little thing more

375
00:16:54.476 --> 00:16:56.646 A:middle
that every single
application is going to need

376
00:16:56.946 --> 00:16:59.026 A:middle
because I imagine
you're all not going

377
00:16:59.026 --> 00:17:02.966 A:middle
to be happy drawing exactly the
same thing over and over again.

378
00:17:02.996 --> 00:17:06.616 A:middle
We need to load some shader
uniforms because, you know,

379
00:17:06.846 --> 00:17:09.816 A:middle
we actually want to make things
move over time or what have you.

380
00:17:10.156 --> 00:17:12.445 A:middle
So, this is going
to take the form of,

381
00:17:12.445 --> 00:17:15.826 A:middle
so I want to use this
opportunity to show you how

382
00:17:15.826 --> 00:17:19.076 A:middle
to load shader uniforms,
also known as constants.

383
00:17:21.205 --> 00:17:24.536 A:middle
So, in Metal, shader constants
come in through buffers.

384
00:17:24.616 --> 00:17:26.455 A:middle
Just like vertexArrays
or anything else.

385
00:17:27.616 --> 00:17:30.536 A:middle
So back to my vertex
shader code.

386
00:17:31.336 --> 00:17:33.376 A:middle
I have declared a new struct,

387
00:17:33.376 --> 00:17:36.826 A:middle
which describes a compiler
how my uniforms are laid you

388
00:17:36.966 --> 00:17:37.416 A:middle
in memory.

389
00:17:37.976 --> 00:17:40.306 A:middle
In this case it's just
a general 4x4 matrix.

390
00:17:43.106 --> 00:17:45.626 A:middle
And I've added a second
argument to my function.

391
00:17:45.626 --> 00:17:47.026 A:middle
I'm going to read from
a different buffer.

392
00:17:47.026 --> 00:17:48.716 A:middle
Now I'm going to read
from buffer location 1,

393
00:17:49.396 --> 00:17:52.146 A:middle
and that's where the compiler is
going to expect to find a buffer

394
00:17:52.146 --> 00:17:55.246 A:middle
that it's going to actually
load that struct from.

395
00:17:55.246 --> 00:17:58.816 A:middle
So that's the extent
of the shader changes.

396
00:17:59.376 --> 00:18:05.206 A:middle
On the API side, I've
allocated a second buffer

397
00:18:05.206 --> 00:18:06.556 A:middle
to sort of hold my uniforms.

398
00:18:06.556 --> 00:18:08.446 A:middle
And I'm going to call
the contents property,

399
00:18:08.446 --> 00:18:10.536 A:middle
and that's just going to
return to me a void start.

400
00:18:10.826 --> 00:18:14.636 A:middle
And like I said, these are
CPU/GPU shared CommandBuffers,

401
00:18:14.636 --> 00:18:15.606 A:middle
or shared, not Command Buffers.

402
00:18:15.606 --> 00:18:16.956 A:middle
These are CPU/GPU shared memory.

403
00:18:17.446 --> 00:18:19.226 A:middle
The GPU is reading from
exactly the same memory

404
00:18:19.226 --> 00:18:19.996 A:middle
that GPU's writing.

405
00:18:20.316 --> 00:18:22.386 A:middle
There's no lock or
unlock API calls

406
00:18:22.386 --> 00:18:23.446 A:middle
or flushing or any of that.

407
00:18:24.006 --> 00:18:26.116 A:middle
You can get a pointer,
[inaudible] it to a type

408
00:18:26.116 --> 00:18:27.426 A:middle
of your choosing
and start writing.

409
00:18:28.206 --> 00:18:33.096 A:middle
And then finally, I'm going to
set a second buffer argument

410
00:18:33.186 --> 00:18:36.626 A:middle
to the vertex stage to point
the hardware at uniformBuffer.

411
00:18:37.556 --> 00:18:40.346 A:middle
This is almost okay
but not quite.

412
00:18:40.346 --> 00:18:43.266 A:middle
Because we actually have
a race condition here.

413
00:18:45.176 --> 00:18:49.456 A:middle
So your application encodes
a frame and also writes

414
00:18:49.456 --> 00:18:50.856 A:middle
to a uniform buffer
at the same time.

415
00:18:50.896 --> 00:18:53.656 A:middle
And then we ship that off
to the GPU to be executed.

416
00:18:55.436 --> 00:18:57.976 A:middle
The execution is going to take
some amount of time depending

417
00:18:57.976 --> 00:19:01.636 A:middle
on the complexity of your seam.

418
00:19:02.486 --> 00:19:04.556 A:middle
So if you have like a
conventional game loop,

419
00:19:04.556 --> 00:19:05.946 A:middle
you're probably going
to turn around

420
00:19:05.946 --> 00:19:07.786 A:middle
and immediately check back
up to the top of your loop

421
00:19:08.126 --> 00:19:09.966 A:middle
and start encoding the
next frame right away.

422
00:19:10.606 --> 00:19:14.076 A:middle
Of course the GPU being an
[inaudible] device is still

423
00:19:14.076 --> 00:19:15.906 A:middle
executing the previous
command buffer.

424
00:19:16.886 --> 00:19:19.786 A:middle
So if I have a right to that
unit, I have a new frame.

425
00:19:20.066 --> 00:19:20.886 A:middle
It's a new time stamp.

426
00:19:21.096 --> 00:19:22.316 A:middle
It's a new model view matrix.

427
00:19:22.726 --> 00:19:24.516 A:middle
But if I write that into
my buffer right now,

428
00:19:24.516 --> 00:19:28.216 A:middle
I'm writing into the same memory
that the GPU is reading from.

429
00:19:28.356 --> 00:19:29.636 A:middle
And I've created
a race condition.

430
00:19:30.246 --> 00:19:32.926 A:middle
At that point what the GPU
reads is completely undefined.

431
00:19:34.766 --> 00:19:37.726 A:middle
So, the easy thing to do is
write to a different buffer.

432
00:19:38.646 --> 00:19:39.746 A:middle
So there's no conflict here.

433
00:19:40.256 --> 00:19:44.576 A:middle
Then I come down here to my
third frame and so forth.

434
00:19:44.576 --> 00:19:46.926 A:middle
But there comes a point where
you just, where you, you know,

435
00:19:47.096 --> 00:19:48.666 A:middle
you can't allocate
new buffers forever.

436
00:19:48.746 --> 00:19:51.206 A:middle
There comes a point where
you're going to want to recycle

437
00:19:51.326 --> 00:19:52.446 A:middle
and existing buffer again.

438
00:19:53.216 --> 00:19:57.536 A:middle
And the problem here is that,
a CPU can get sometimes,

439
00:19:57.536 --> 00:19:59.306 A:middle
depending on how you
structure you're application,

440
00:19:59.606 --> 00:20:01.266 A:middle
several frames ahead of the GPU.

441
00:20:01.776 --> 00:20:04.346 A:middle
And the GPU might still
be working on that frame

442
00:20:04.556 --> 00:20:05.866 A:middle
that you submitted
two frames ago.

443
00:20:06.396 --> 00:20:08.526 A:middle
And we still have
a race condition.

444
00:20:10.216 --> 00:20:13.636 A:middle
So the final step to resolving
this is that we need to wait.

445
00:20:13.806 --> 00:20:16.486 A:middle
That your application needs
to not write to that buffer

446
00:20:16.746 --> 00:20:18.686 A:middle
until you know that your code

447
00:20:18.686 --> 00:20:21.606 A:middle
on the GPU is no
longer reading from it.

448
00:20:21.846 --> 00:20:23.406 A:middle
Fortunately, that's pretty easy.

449
00:20:23.546 --> 00:20:24.866 A:middle
It takes about four
lines of code.

450
00:20:24.866 --> 00:20:28.266 A:middle
So I'm going to show
you that now.

451
00:20:29.146 --> 00:20:32.176 A:middle
So I'm going to do this
with dispatch semaphores,

452
00:20:32.856 --> 00:20:36.696 A:middle
you know a common low-level
synchronization primitive

453
00:20:36.696 --> 00:20:37.266 A:middle
on iOS.

454
00:20:38.176 --> 00:20:39.606 A:middle
So for this example,
I'm going to have a pool

455
00:20:39.606 --> 00:20:41.346 A:middle
of three uniform
buffers I've created.

456
00:20:41.346 --> 00:20:43.456 A:middle
So I'm going to create
a dispatch semaphore

457
00:20:43.456 --> 00:20:44.316 A:middle
with a count of 3.

458
00:20:45.316 --> 00:20:48.146 A:middle
I'm going to add my
common CommandBuffer loop.

459
00:20:48.146 --> 00:20:49.356 A:middle
I'm going to build
a Command Buffer.

460
00:20:49.356 --> 00:20:50.476 A:middle
And I'm going to
send it to the GPU.

461
00:20:51.556 --> 00:20:54.856 A:middle
But right at the top, before
I write to any shared memory

462
00:20:54.856 --> 00:20:57.386 A:middle
that I'm recycling, that the
GPU is potentially still reading

463
00:20:57.386 --> 00:20:58.696 A:middle
from, I'm going to wait.

464
00:20:58.696 --> 00:20:59.726 A:middle
And I'm going to make sure

465
00:21:00.056 --> 00:21:03.436 A:middle
that the GPU has actually
finished executing

466
00:21:03.436 --> 00:21:05.986 A:middle
that previous CommandBuffer
before I reuse the memory.

467
00:21:06.296 --> 00:21:10.006 A:middle
So this is the second place
apart from next [inaudible]

468
00:21:10.006 --> 00:21:13.286 A:middle
where you probably see
an application block

469
00:21:13.386 --> 00:21:14.056 A:middle
when using Metal.

470
00:21:14.546 --> 00:21:19.076 A:middle
Now the other side of this is
we need to signal the semaphore

471
00:21:19.076 --> 00:21:21.016 A:middle
when it is safe for the
application to proceed.

472
00:21:22.016 --> 00:21:24.966 A:middle
So, in Metal, you can
add a completion handler

473
00:21:25.086 --> 00:21:25.906 A:middle
to a CommandBuffer.

474
00:21:26.576 --> 00:21:29.156 A:middle
When the GPU finishes
executing this CommandBuffer,

475
00:21:30.446 --> 00:21:33.066 A:middle
the OS will invoke the
block that you provide,

476
00:21:33.126 --> 00:21:34.646 A:middle
and you can do whatever
you want in there.

477
00:21:35.306 --> 00:21:37.906 A:middle
In this case, I'm going to
signal the semaphore and say,

478
00:21:38.556 --> 00:21:39.866 A:middle
hey a CommandBuffer finished.

479
00:21:40.216 --> 00:21:41.536 A:middle
There's a uniform
buffer available.

480
00:21:42.266 --> 00:21:43.036 A:middle
Start writing to it.

481
00:21:43.036 --> 00:21:43.586 A:middle
Have a blast.

482
00:21:43.786 --> 00:21:46.246 A:middle
And that's really it.

483
00:21:46.976 --> 00:21:50.256 A:middle
So that's really the
basic walk-through

484
00:21:50.256 --> 00:21:53.356 A:middle
through a simple hello world
application with some animation.

485
00:21:53.356 --> 00:21:54.466 A:middle
It does shader constants.

486
00:21:54.726 --> 00:21:58.516 A:middle
Does vertexArrays, and
we still have a 3D state.

487
00:22:00.096 --> 00:22:02.336 A:middle
Went through some basic
initialization process.

488
00:22:03.036 --> 00:22:06.146 A:middle
We showed how to set up
basic CommandBuffer draw.

489
00:22:06.146 --> 00:22:09.266 A:middle
And we said hey, the moment
you produce any CPU dynamically

490
00:22:09.266 --> 00:22:12.106 A:middle
produced data, we saw how you
have to synchronize access

491
00:22:12.106 --> 00:22:14.456 A:middle
to that because we're just
giving you the raw memory

492
00:22:14.456 --> 00:22:16.476 A:middle
pointers now.

493
00:22:18.356 --> 00:22:22.766 A:middle
So, that thing, these design
patterns actually go really far.

494
00:22:22.766 --> 00:22:26.186 A:middle
For example, that same pattern
of synchronizing with semaphores

495
00:22:26.186 --> 00:22:28.906 A:middle
or any other permit of your
choice, and the callbacks,

496
00:22:29.416 --> 00:22:31.996 A:middle
for example, are just as
useful for dynamic vertex data,

497
00:22:32.436 --> 00:22:34.626 A:middle
for streaming image
updates, texture updates,

498
00:22:34.626 --> 00:22:36.746 A:middle
if you have a large open
world kind of scene.

499
00:22:37.456 --> 00:22:39.056 A:middle
Or even if you're going
the other direction

500
00:22:39.096 --> 00:22:40.456 A:middle
and having the GPU produce data,

501
00:22:41.256 --> 00:22:43.386 A:middle
you know that the CPU
can read it as soon

502
00:22:43.386 --> 00:22:44.716 A:middle
as that callback fires.

503
00:22:46.076 --> 00:22:48.036 A:middle
So that's really
your introduction

504
00:22:48.036 --> 00:22:50.686 A:middle
to a really simple
hello world application.

505
00:22:50.836 --> 00:22:51.966 A:middle
We made a spinning triangle.

506
00:22:52.146 --> 00:22:56.376 A:middle
Hooray. So, with that,
that wraps up this.

507
00:22:56.376 --> 00:22:58.356 A:middle
And so I'm going to turn the
stage over to my colleague Aafi,

508
00:22:58.686 --> 00:23:01.436 A:middle
to talk to you in detail about
the Metal shading language.

509
00:23:01.786 --> 00:23:02.216 A:middle
So thank you.

510
00:23:03.766 --> 00:23:06.996 A:middle
&gt;&gt; All right.

511
00:23:07.426 --> 00:23:08.066 A:middle
Thanks Richard.

512
00:23:08.766 --> 00:23:13.416 A:middle
All right, so we're going to
talk about the shading language.

513
00:23:13.626 --> 00:23:16.456 A:middle
And so Jeremy mentioned
in the first presentation

514
00:23:16.456 --> 00:23:20.986 A:middle
that this language is based
on C++, so a lot of you,

515
00:23:21.156 --> 00:23:23.656 A:middle
most of you are familiar
with writing C++ code.

516
00:23:23.656 --> 00:23:26.336 A:middle
What we're going to talk
about is how we extended this

517
00:23:26.686 --> 00:23:29.406 A:middle
to be able to write
shaders in Metal.

518
00:23:30.626 --> 00:23:33.936 A:middle
So the things, the things
we're going to cover

519
00:23:33.936 --> 00:23:36.946 A:middle
in this session is
how to write shaders.

520
00:23:36.946 --> 00:23:39.326 A:middle
We're going to take a simple
vertex in the fragment shader

521
00:23:39.326 --> 00:23:41.916 A:middle
and see how we can take
C++ code and make it

522
00:23:41.916 --> 00:23:43.166 A:middle
into a vertex fragment shader.

523
00:23:43.586 --> 00:23:46.466 A:middle
We will talk about data
types that Metal supports.

524
00:23:46.466 --> 00:23:50.896 A:middle
We will talk about, you know,
while shaders need inputs

525
00:23:50.896 --> 00:23:53.746 A:middle
and outputs, so how do
you specify that in Metal.

526
00:23:54.226 --> 00:23:55.936 A:middle
And, you know, if I'm
going to use them,

527
00:23:55.936 --> 00:23:58.216 A:middle
because in the RenderPipeline,
I need a vertex shader

528
00:23:58.216 --> 00:24:01.126 A:middle
and a fragment shader, well
how do I make sure I pair these

529
00:24:01.166 --> 00:24:01.856 A:middle
things together?

530
00:24:02.416 --> 00:24:04.896 A:middle
And then we'll talk
about math, okay.

531
00:24:05.436 --> 00:24:09.236 A:middle
All right, so how to
write shaders in Metal.

532
00:24:09.236 --> 00:24:13.126 A:middle
So let's take this in
a pseudo C code here.

533
00:24:13.596 --> 00:24:17.526 A:middle
So what you see here in
this function is it takes

534
00:24:17.596 --> 00:24:18.416 A:middle
three arguments.

535
00:24:18.416 --> 00:24:21.526 A:middle
The first two are some
pointers to some structures

536
00:24:21.956 --> 00:24:24.376 A:middle
and the returns this
vertex output struct

537
00:24:24.376 --> 00:24:25.806 A:middle
which you declared it.

538
00:24:26.276 --> 00:24:30.266 A:middle
And what I want to happen here
is remember the vertex shader is

539
00:24:30.266 --> 00:24:34.296 A:middle
executing for each vertex,
so if I have N vertices

540
00:24:34.296 --> 00:24:35.706 A:middle
in my primitive I want,

541
00:24:36.026 --> 00:24:38.256 A:middle
there may be multiple threads
executing these vertices

542
00:24:38.256 --> 00:24:39.616 A:middle
in parallel.

543
00:24:39.876 --> 00:24:43.616 A:middle
So what I want to be
able to do is read

544
00:24:43.616 --> 00:24:45.426 A:middle
in that thread that's
executing this vertex shader,

545
00:24:45.426 --> 00:24:49.096 A:middle
which vertex am I actually
accessing so I can go

546
00:24:49.096 --> 00:24:50.716 A:middle
and get the right index.

547
00:24:50.786 --> 00:24:53.746 A:middle
Use that index to access
the right vertex data.

548
00:24:54.156 --> 00:24:56.536 A:middle
So, just you know,
imagine, just imagine

549
00:24:56.536 --> 00:24:59.056 A:middle
that this is that ID, okay.

550
00:24:59.146 --> 00:25:01.716 A:middle
So in this code, what we see
is here is going to use this ID

551
00:25:02.046 --> 00:25:04.936 A:middle
and reference into
the input arguments.

552
00:25:04.936 --> 00:25:07.106 A:middle
This is the vertex
data and UV data.

553
00:25:07.106 --> 00:25:08.866 A:middle
Arguments have passed
to this function.

554
00:25:09.106 --> 00:25:11.316 A:middle
And you would typically
probably do some computations.

555
00:25:11.316 --> 00:25:12.616 A:middle
In this case I'm not doing much.

556
00:25:12.616 --> 00:25:14.406 A:middle
I'm just going to copy
them and return them back.

557
00:25:15.016 --> 00:25:17.986 A:middle
Well okay, how do I make this
into a Metal vertex shader?

558
00:25:18.146 --> 00:25:21.896 A:middle
Well the first thing,
note that we don't,

559
00:25:21.946 --> 00:25:24.916 A:middle
and Metal doesn't support
the C++ standard library.

560
00:25:24.916 --> 00:25:27.116 A:middle
Instead Metal has its
own standard library

561
00:25:27.506 --> 00:25:30.156 A:middle
that has been optimized
for the GPU.

562
00:25:30.156 --> 00:25:31.366 A:middle
For the graphics and compute.

563
00:25:32.066 --> 00:25:33.846 A:middle
In addition to that, so
I want to include that.

564
00:25:33.936 --> 00:25:37.016 A:middle
In addition to that, you know,
types and functions defined

565
00:25:37.016 --> 00:25:39.276 A:middle
by Metal actually out in
the Metal's namespace.

566
00:25:39.356 --> 00:25:40.886 A:middle
So I'm just being lazy.

567
00:25:40.886 --> 00:25:43.426 A:middle
Instead of explicitly calling
them, I'm just saying I'm going

568
00:25:43.426 --> 00:25:45.336 A:middle
to use the Metal
namespace in my shader here.

569
00:25:45.676 --> 00:25:47.776 A:middle
The next thing I'm
going to do is I'm going

570
00:25:47.776 --> 00:25:48.876 A:middle
to tell the compiler hey,

571
00:25:48.876 --> 00:25:50.436 A:middle
that this function
is a vertex function.

572
00:25:50.666 --> 00:25:53.316 A:middle
Okay, so that's what
I'm going to do.

573
00:25:53.316 --> 00:25:57.966 A:middle
And then Jeremy showed you
that any resource that's passed

574
00:25:57.966 --> 00:25:59.466 A:middle
as arguments to your functions,

575
00:25:59.826 --> 00:26:01.786 A:middle
you need to have the
argument indices.

576
00:26:01.786 --> 00:26:03.206 A:middle
So in this case, you know,

577
00:26:03.206 --> 00:26:05.086 A:middle
anything that's a pointer
is actually a buffer.

578
00:26:05.086 --> 00:26:07.366 A:middle
So I'm going to assign
buffer indices.

579
00:26:07.666 --> 00:26:10.306 A:middle
And there's this global
thing that I have added here.

580
00:26:10.306 --> 00:26:12.066 A:middle
So just ignore that for now.

581
00:26:12.066 --> 00:26:13.926 A:middle
I'll cover what that
is in a few slides.

582
00:26:14.196 --> 00:26:16.496 A:middle
So almost there.

583
00:26:16.946 --> 00:26:18.576 A:middle
And I need to tell the compiler

584
00:26:18.576 --> 00:26:21.126 A:middle
that that ID is actually
the vertex ID.

585
00:26:21.126 --> 00:26:22.936 A:middle
So it can generate
the right code for me.

586
00:26:23.196 --> 00:26:23.696 A:middle
And that's it.

587
00:26:23.866 --> 00:26:26.476 A:middle
That's a Metal vertex
shader, okay.

588
00:26:27.296 --> 00:26:33.666 A:middle
What, nobody's going to clap?

589
00:26:33.666 --> 00:26:36.796 A:middle
All right, and you know
a fragment shader is just

590
00:26:36.796 --> 00:26:37.766 A:middle
very similar.

591
00:26:38.026 --> 00:26:41.526 A:middle
So I need to tell the compiler
it's a fragment function,

592
00:26:41.526 --> 00:26:43.436 A:middle
so I use the fragment qualifier.

593
00:26:43.856 --> 00:26:47.986 A:middle
Now note, remember the fragment
shader typically takes inputs

594
00:26:48.036 --> 00:26:51.146 A:middle
that are generated
by the vertex shader.

595
00:26:51.146 --> 00:26:53.386 A:middle
The output of the vertex
shader goes to the rasterizer

596
00:26:53.386 --> 00:26:55.806 A:middle
and becomes inputs to
the fragment shader.

597
00:26:56.216 --> 00:26:59.236 A:middle
So in this case, the vertex
shader returns, VertexOutput,

598
00:26:59.236 --> 00:27:00.936 A:middle
and I want to use
that as an input.

599
00:27:01.116 --> 00:27:05.776 A:middle
No this is some struct
that you have compared.

600
00:27:05.816 --> 00:27:07.536 A:middle
So the compiler needs to know

601
00:27:07.806 --> 00:27:09.956 A:middle
that this is a per
instance input.

602
00:27:10.006 --> 00:27:14.636 A:middle
So anything that's user defined
and input to a vertex shader

603
00:27:14.636 --> 00:27:17.466 A:middle
or fragment shader that needs
to be [inaudible] and unique

604
00:27:17.466 --> 00:27:20.016 A:middle
for instance, has
to be qualified.

605
00:27:20.066 --> 00:27:22.376 A:middle
And so in Metal you do
that by declaring that with

606
00:27:22.376 --> 00:27:24.176 A:middle
that stage and attribute, okay.

607
00:27:24.876 --> 00:27:27.596 A:middle
So what I'm doing is in this
shader I'm going to look

608
00:27:27.596 --> 00:27:30.966 A:middle
at the texture coordinate per
fragment and use that example

609
00:27:31.366 --> 00:27:33.096 A:middle
into a texture that'll
return the color value.

610
00:27:33.096 --> 00:27:34.226 A:middle
So pretty straight forward.

611
00:27:34.226 --> 00:27:34.776 A:middle
So that's it.

612
00:27:34.906 --> 00:27:37.196 A:middle
It's really, you're going
to find the writing shaders

613
00:27:37.196 --> 00:27:38.896 A:middle
in Metal is really, really easy.

614
00:27:39.086 --> 00:27:42.516 A:middle
All right so let's
talk about data types.

615
00:27:42.876 --> 00:27:46.666 A:middle
All right, so I've broken data
types into two categories.

616
00:27:47.166 --> 00:27:48.506 A:middle
One I call the basic types.

617
00:27:48.766 --> 00:27:50.646 A:middle
And then we have
resources and data objects.

618
00:27:51.046 --> 00:27:55.466 A:middle
Note that one thing you
see is that all the inputs

619
00:27:55.466 --> 00:27:57.296 A:middle
to a shader are passed
as arguments.

620
00:27:57.336 --> 00:27:58.196 A:middle
There are no globals.

621
00:27:58.196 --> 00:28:00.226 A:middle
So you declare everything
as arguments,

622
00:28:00.576 --> 00:28:03.096 A:middle
and then if these are
resources are data objects,

623
00:28:03.576 --> 00:28:06.966 A:middle
then you specify the indices
that the runtime will use

624
00:28:06.966 --> 00:28:08.416 A:middle
to set the right resources too.

625
00:28:08.726 --> 00:28:10.136 A:middle
Okay, so let's talk
about the base types.

626
00:28:10.136 --> 00:28:10.856 A:middle
What are these?

627
00:28:10.856 --> 00:28:13.766 A:middle
These are scalars, vectors,
matrices and atomics.

628
00:28:13.766 --> 00:28:16.866 A:middle
So the scalar is
pretty straight forward.

629
00:28:16.936 --> 00:28:18.656 A:middle
I mean it don't usually
tell much.

630
00:28:18.826 --> 00:28:21.466 A:middle
We support the C++11
scalar types.

631
00:28:22.376 --> 00:28:25.926 A:middle
In addition to that,
we have the half type.

632
00:28:26.366 --> 00:28:31.636 A:middle
Okay. All right so
the half type.

633
00:28:32.616 --> 00:28:36.026 A:middle
So this is the i64 [inaudible]
16 bit floating point type.

634
00:28:36.026 --> 00:28:38.786 A:middle
And so any operation
you could do with Float,

635
00:28:38.786 --> 00:28:40.246 A:middle
at half of the first
class citizens.

636
00:28:40.246 --> 00:28:42.226 A:middle
So anything you can do with
Float, you can do with Half.

637
00:28:42.456 --> 00:28:44.556 A:middle
In fact, we really
want you to use half

638
00:28:44.556 --> 00:28:46.236 A:middle
because they are
both performance

639
00:28:46.236 --> 00:28:50.076 A:middle
and power optimizations that you
can share and take advantage of.

640
00:28:50.586 --> 00:28:52.386 A:middle
Vectors, very similar.

641
00:28:52.626 --> 00:28:55.976 A:middle
So you have you know, two, three
and four component vector types.

642
00:28:56.046 --> 00:29:00.696 A:middle
So for example, a half2 is a
two component 16 bit floating

643
00:29:00.696 --> 00:29:01.286 A:middle
plan vector.

644
00:29:01.786 --> 00:29:06.186 A:middle
Matrices we have floating point
matrices, and they're stored

645
00:29:06.186 --> 00:29:09.056 A:middle
in column major order,
just like they are in GL.

646
00:29:09.426 --> 00:29:12.726 A:middle
The constructors and
operators, the things you can do

647
00:29:12.726 --> 00:29:14.716 A:middle
on them are very similar
to what you would find

648
00:29:14.716 --> 00:29:15.786 A:middle
in other shading languages,

649
00:29:15.976 --> 00:29:19.376 A:middle
so I'm not really
going to cover that.

650
00:29:19.586 --> 00:29:21.016 A:middle
But here's the thing
I want to talk about.

651
00:29:21.136 --> 00:29:22.856 A:middle
So, remember your path.

652
00:29:22.856 --> 00:29:23.996 A:middle
You're declaring a struct.

653
00:29:23.996 --> 00:29:25.696 A:middle
You're passing a
pointer to that struct

654
00:29:26.066 --> 00:29:27.716 A:middle
as argument to your shader.

655
00:29:27.716 --> 00:29:31.096 A:middle
So what you want to be able
to do is declare these,

656
00:29:31.306 --> 00:29:33.976 A:middle
let's say in a header file
and then use them both

657
00:29:33.976 --> 00:29:35.336 A:middle
on the host guard
because you're going

658
00:29:35.336 --> 00:29:36.886 A:middle
to build this data
structure on the host.

659
00:29:37.366 --> 00:29:40.276 A:middle
And then use this header
file also in your shader.

660
00:29:41.056 --> 00:29:43.456 A:middle
Well you can do that
because these types,

661
00:29:44.206 --> 00:29:48.426 A:middle
so in iOS 8 we have
the SIMD math library,

662
00:29:48.426 --> 00:29:51.296 A:middle
and so these define the
vector and matrix types.

663
00:29:51.296 --> 00:29:53.716 A:middle
And Metal uses the
exact same types.

664
00:29:53.716 --> 00:29:56.936 A:middle
So, what that means is that
if you include the SIMD header

665
00:29:57.036 --> 00:29:59.926 A:middle
in a host guard and you
can build the structures,

666
00:30:00.046 --> 00:30:00.916 A:middle
you can share them.

667
00:30:01.356 --> 00:30:02.726 A:middle
You don't have to
do anything special.

668
00:30:02.726 --> 00:30:04.176 A:middle
It just works, okay.

669
00:30:05.566 --> 00:30:09.976 A:middle
Not every slide, no
clapping every slide.

670
00:30:10.496 --> 00:30:13.716 A:middle
Again, just like I said
previously, use the half vector

671
00:30:13.716 --> 00:30:16.376 A:middle
and matrix types
whenever you can, okay.

672
00:30:16.906 --> 00:30:20.896 A:middle
All right, so the last, oh, so
one more point on vector types.

673
00:30:21.186 --> 00:30:23.276 A:middle
So they are aligned
at vector length.

674
00:30:23.476 --> 00:30:24.226 A:middle
So what does that mean?

675
00:30:24.226 --> 00:30:28.216 A:middle
So if I look at the struct, what
that means is that a float2,

676
00:30:28.386 --> 00:30:30.896 A:middle
which is what bs is going
to be aligned on 8 bytes.

677
00:30:31.156 --> 00:30:34.096 A:middle
And similarly c is going to
be aligned with 16 bytes.

678
00:30:34.406 --> 00:30:37.666 A:middle
But if you notice, b is
actually at an offset of 4.

679
00:30:38.626 --> 00:30:39.746 A:middle
So that's a problem.

680
00:30:39.856 --> 00:30:41.716 A:middle
So what the compiler
will do is going

681
00:30:41.776 --> 00:30:43.976 A:middle
to generate a pairing variable.

682
00:30:44.196 --> 00:30:45.626 A:middle
Okay, so when you
do sizeof(Foo),

683
00:30:45.626 --> 00:30:47.046 A:middle
you're only going
to get 32 bytes.

684
00:30:47.046 --> 00:30:51.256 A:middle
So depending on how big your
data structure is and what kind

685
00:30:51.256 --> 00:30:52.746 A:middle
of scalars and vectors you use,

686
00:30:53.086 --> 00:30:54.516 A:middle
the compiler may
potentially have

687
00:30:54.516 --> 00:30:55.636 A:middle
to generate lots of pairing.

688
00:30:55.636 --> 00:30:58.816 A:middle
And if you're going to declare
an array of these trucks, then,

689
00:30:58.816 --> 00:31:00.866 A:middle
you know, it has
potential implications

690
00:31:00.866 --> 00:31:04.416 A:middle
to your allocation size
and even memory boundary

691
00:31:04.416 --> 00:31:06.926 A:middle
when you access these data
structures in a shader code.

692
00:31:07.326 --> 00:31:12.326 A:middle
So, you may want to be smart
and say wow, let me declare them

693
00:31:12.326 --> 00:31:14.126 A:middle
in order of decreasing size.

694
00:31:14.176 --> 00:31:15.906 A:middle
All of my biggest
data types first,

695
00:31:16.326 --> 00:31:17.836 A:middle
and then the smaller types.

696
00:31:18.586 --> 00:31:20.826 A:middle
Well if you try to do
a sizeof(Foo) on that,

697
00:31:21.136 --> 00:31:22.496 A:middle
you're still going
to get 32 bytes.

698
00:31:22.786 --> 00:31:24.376 A:middle
And you're like, why is that.

699
00:31:24.926 --> 00:31:28.356 A:middle
The reason for that is the
compiler still has to guarantee

700
00:31:28.766 --> 00:31:31.626 A:middle
that each struct is
aligned to the site

701
00:31:31.626 --> 00:31:33.836 A:middle
of the largest data
type in that struct.

702
00:31:34.446 --> 00:31:37.136 A:middle
Because if you were to
use an array of these,

703
00:31:37.136 --> 00:31:40.126 A:middle
if you type index C at index 1,

704
00:31:40.506 --> 00:31:42.386 A:middle
you have to make sure
it's the line on 16 bytes.

705
00:31:42.676 --> 00:31:43.456 A:middle
So that doesn't work.

706
00:31:44.026 --> 00:31:47.626 A:middle
So what if I wanted to tightly
pack all my data structures?

707
00:31:48.126 --> 00:31:48.966 A:middle
You can do that.

708
00:31:48.966 --> 00:31:51.056 A:middle
And we have packed
vector types for that.

709
00:31:51.796 --> 00:31:54.046 A:middle
So they are just like
the aligned vector types.

710
00:31:54.096 --> 00:31:56.796 A:middle
There declared with this
packed underscore prefix.

711
00:31:57.746 --> 00:32:01.896 A:middle
You can do all of the operations
on these types as you can

712
00:32:01.966 --> 00:32:03.246 A:middle
on the aligned vector types.

713
00:32:04.076 --> 00:32:07.436 A:middle
The only benefit is that a
line is scalar type length.

714
00:32:07.606 --> 00:32:11.756 A:middle
So if I declare the same struct
now, but use the packed types,

715
00:32:12.376 --> 00:32:14.066 A:middle
then these are aligned
correctly.

716
00:32:14.066 --> 00:32:16.466 A:middle
And so the size of Foo
is going to be 28 bytes.

717
00:32:16.786 --> 00:32:19.976 A:middle
So then you are asked, well why
shouldn't I always use these

718
00:32:19.976 --> 00:32:20.586 A:middle
packed types?

719
00:32:21.486 --> 00:32:23.406 A:middle
And the reason, the
answer to that depends

720
00:32:23.406 --> 00:32:26.186 A:middle
on how you are going to
use these on the host.

721
00:32:26.186 --> 00:32:31.426 A:middle
Because the CPU, these types
are not a good fit for the CPU.

722
00:32:31.426 --> 00:32:33.786 A:middle
But the CPU likes vector
types to be aligned.

723
00:32:33.786 --> 00:32:35.766 A:middle
So if you're just
building a data structure,

724
00:32:36.106 --> 00:32:38.696 A:middle
and just filling it
out and going to pass

725
00:32:38.696 --> 00:32:41.776 A:middle
that to the shader, and
most of your computations

726
00:32:41.776 --> 00:32:43.686 A:middle
on these data types are going
to happen in the shader,

727
00:32:43.936 --> 00:32:45.186 A:middle
then you can use the pack types.

728
00:32:45.626 --> 00:32:48.436 A:middle
But if you're going to perform
computations with these types

729
00:32:49.336 --> 00:32:51.916 A:middle
in host code, then you should
use the aligned vector types.

730
00:32:52.256 --> 00:32:55.816 A:middle
So use that to determine like
which types you need to use.

731
00:32:56.116 --> 00:32:58.796 A:middle
All right, so the last
of the basic types,

732
00:32:58.796 --> 00:32:59.986 A:middle
and these are the atomic types.

733
00:33:00.476 --> 00:33:04.346 A:middle
And so we support a subset
of the C++11 atomic types.

734
00:33:04.936 --> 00:33:07.686 A:middle
And the question is why
should I use atomic types?

735
00:33:07.796 --> 00:33:11.416 A:middle
Well, the operations on
these types are race-free.

736
00:33:11.516 --> 00:33:12.886 A:middle
So, let's take an example.

737
00:33:12.886 --> 00:33:15.206 A:middle
Let's say I'm generating
a histogram for an image.

738
00:33:15.616 --> 00:33:17.016 A:middle
And so I have 8 bits
per channel.

739
00:33:17.016 --> 00:33:20.026 A:middle
So I have 256 bins for
each color channel.

740
00:33:20.526 --> 00:33:22.196 A:middle
So I want to update a bin.

741
00:33:22.456 --> 00:33:23.666 A:middle
So I'm going to read
the current value.

742
00:33:23.726 --> 00:33:25.826 A:middle
I'm going to increment
it, and then write it out.

743
00:33:25.826 --> 00:33:28.936 A:middle
So what I want to make sure
is that after I've read

744
00:33:29.076 --> 00:33:31.826 A:middle
but before I've written, nobody
else comes and changes it.

745
00:33:31.976 --> 00:33:34.706 A:middle
And that's what these
atomic operations guarantee.

746
00:33:35.226 --> 00:33:38.326 A:middle
Okay. All right, so that
covers the basic types.

747
00:33:38.896 --> 00:33:42.136 A:middle
So let's talk about resource and
state objects that you can pass

748
00:33:42.606 --> 00:33:43.796 A:middle
as data types to your shader.

749
00:33:45.826 --> 00:33:49.156 A:middle
All right, so we support the
traditional texture types

750
00:33:49.156 --> 00:33:51.806 A:middle
like 1d, 1dArray, 2d, 2dArray,

751
00:33:52.096 --> 00:33:54.006 A:middle
but how do you declare
these in Metal?

752
00:33:54.096 --> 00:33:58.556 A:middle
So these are declared
as a template.

753
00:33:58.926 --> 00:34:00.256 A:middle
He likes it, all right.

754
00:34:00.376 --> 00:34:03.416 A:middle
So the template takes
two parameters.

755
00:34:03.416 --> 00:34:04.616 A:middle
One is the color type.

756
00:34:04.616 --> 00:34:07.656 A:middle
And this indicates if
you're going to sample

757
00:34:07.656 --> 00:34:10.356 A:middle
from a texture the vector
type you're going to return,

758
00:34:10.856 --> 00:34:13.676 A:middle
or as a color value, or
if you're going to write

759
00:34:13.916 --> 00:34:15.346 A:middle
to the texture, what
is the vector type

760
00:34:15.696 --> 00:34:17.206 A:middle
that would represent
the color value?

761
00:34:17.416 --> 00:34:18.335 A:middle
And the access mode.

762
00:34:18.565 --> 00:34:21.275 A:middle
And this tells the compiler
whether you're going

763
00:34:21.275 --> 00:34:24.886 A:middle
to be sampling from a
texture or reading or writing.

764
00:34:25.005 --> 00:34:27.216 A:middle
Reading is just saying hey,

765
00:34:27.216 --> 00:34:31.496 A:middle
go read this specific
location pixel in my texture

766
00:34:31.545 --> 00:34:33.866 A:middle
or in write this color value

767
00:34:33.866 --> 00:34:35.636 A:middle
to this specific
location in the texture.

768
00:34:36.255 --> 00:34:38.356 A:middle
You can sample and
read or write.

769
00:34:38.505 --> 00:34:41.936 A:middle
You cannot do both to the
same texture within a shader.

770
00:34:42.436 --> 00:34:44.896 A:middle
And that textures is
of a different type

771
00:34:44.896 --> 00:34:47.656 A:middle
because the GPU actually
optimizes them differently.

772
00:34:47.656 --> 00:34:48.565 A:middle
And so we need to know

773
00:34:48.565 --> 00:34:50.815 A:middle
that you're actually
working with a depth texture.

774
00:34:51.656 --> 00:34:53.446 A:middle
So let's look at some examples.

775
00:34:54.246 --> 00:34:56.726 A:middle
So in this first one
we have a 2d texture,

776
00:34:56.946 --> 00:34:58.416 A:middle
and it's this color
type, this float.

777
00:34:58.416 --> 00:34:59.796 A:middle
So if you sample from
this, you're going

778
00:34:59.796 --> 00:35:00.816 A:middle
to return the float forward.

779
00:35:01.176 --> 00:35:02.596 A:middle
Notice I didn't specify
the access [inaudible]

780
00:35:02.596 --> 00:35:05.526 A:middle
because it has a
default which is sample.

781
00:35:05.946 --> 00:35:11.326 A:middle
So the next one is a 2d texture
again which uses the half type

782
00:35:11.326 --> 00:35:13.196 A:middle
and its mode is right.

783
00:35:13.196 --> 00:35:16.286 A:middle
So if I try to read from
this texture in my shader,

784
00:35:16.286 --> 00:35:17.576 A:middle
the compiler will
throw an error.

785
00:35:17.766 --> 00:35:20.986 A:middle
And finally we have a
depth texture, okay.

786
00:35:22.016 --> 00:35:24.546 A:middle
Samplers are separate
from textures.

787
00:35:24.836 --> 00:35:26.656 A:middle
So, what does that mean?

788
00:35:26.656 --> 00:35:29.966 A:middle
That means I can u se the same
sampler with multiple textures.

789
00:35:29.966 --> 00:35:31.946 A:middle
Or I can use multiple samplers

790
00:35:31.946 --> 00:35:33.346 A:middle
of the same thing
with one texture.

791
00:35:33.926 --> 00:35:34.706 A:middle
You have the freedom.

792
00:35:35.206 --> 00:35:36.206 A:middle
How do I pass these?

793
00:35:36.426 --> 00:35:39.326 A:middle
Well, like I said, everything
is passed as an argument,

794
00:35:39.326 --> 00:35:41.636 A:middle
so you can pass them as an
argument to your shader.

795
00:35:41.636 --> 00:35:44.646 A:middle
In addition though, you
can actually declare them

796
00:35:44.646 --> 00:35:45.356 A:middle
in your source.

797
00:35:45.876 --> 00:35:47.856 A:middle
So it depends.

798
00:35:47.856 --> 00:35:49.076 A:middle
So like in a lot of cases,

799
00:35:49.076 --> 00:35:52.206 A:middle
especially if you're doing
an image processing filters.

800
00:35:52.296 --> 00:35:53.896 A:middle
You know you just need
a hand full of samplers

801
00:35:53.926 --> 00:35:55.606 A:middle
that you're going to use.

802
00:35:56.106 --> 00:35:57.916 A:middle
And data declared is
a variadic template.

803
00:35:57.916 --> 00:36:00.296 A:middle
And the reason for that
is samples have a number

804
00:36:00.296 --> 00:36:02.926 A:middle
of properties like the filter
mode, the aggressing mode,

805
00:36:03.416 --> 00:36:05.706 A:middle
whether the coordinates I'm
going to use are normalized

806
00:36:05.706 --> 00:36:07.626 A:middle
or pixel and a bunch
of other things.

807
00:36:07.716 --> 00:36:11.496 A:middle
I don't want to have to set
them explicitly every time.

808
00:36:11.716 --> 00:36:13.106 A:middle
All of these have defaults.

809
00:36:13.396 --> 00:36:15.186 A:middle
So you only change
the one you want to,

810
00:36:15.186 --> 00:36:16.656 A:middle
you are changing
from the defaults.

811
00:36:16.656 --> 00:36:19.066 A:middle
So in this example, I'm
changing the address more

812
00:36:19.066 --> 00:36:20.516 A:middle
from [inaudible] to zero,

813
00:36:20.846 --> 00:36:23.716 A:middle
and the other properties
take the default.

814
00:36:24.276 --> 00:36:26.796 A:middle
So you can choose to
pass them as an argument,

815
00:36:26.796 --> 00:36:28.746 A:middle
or you can choose them to
declare them the source,

816
00:36:28.746 --> 00:36:29.656 A:middle
depending on your needs.

817
00:36:30.966 --> 00:36:32.296 A:middle
All right, so last of the types.

818
00:36:32.566 --> 00:36:37.356 A:middle
All right, so buffers is just as
Jeremy mentioned a bag of bytes.

819
00:36:37.486 --> 00:36:40.856 A:middle
And so you just pass a pointer
or a reference to this type.

820
00:36:41.086 --> 00:36:43.616 A:middle
And notice in the first slide
I have this global qualifier.

821
00:36:43.616 --> 00:36:45.226 A:middle
Well let's talk about that now.

822
00:36:45.526 --> 00:36:48.366 A:middle
See anything that's passed
as a pointer or a reference

823
00:36:48.366 --> 00:36:51.356 A:middle
to some memory, you need to say
its memory region comes from.

824
00:36:51.866 --> 00:36:53.636 A:middle
And that's because GPU's
actually implement the

825
00:36:53.636 --> 00:36:54.476 A:middle
member hierarchy.

826
00:36:55.126 --> 00:36:57.206 A:middle
With compute, you got an
additional memory region.

827
00:36:57.206 --> 00:36:58.876 A:middle
But if you're just writing
vertex and fragment shaders,

828
00:36:58.916 --> 00:37:02.436 A:middle
the two memory regions we
call them address spaces.

829
00:37:02.436 --> 00:37:04.756 A:middle
You need to worry about
our global and constant.

830
00:37:04.866 --> 00:37:07.096 A:middle
So the question is, well
when should I use which?

831
00:37:07.976 --> 00:37:11.246 A:middle
All right, so if you are
writing a vertex shader,

832
00:37:11.676 --> 00:37:14.666 A:middle
your past pointers to
some buffers, you're going

833
00:37:14.666 --> 00:37:16.796 A:middle
to use your vertex
ID to index into it.

834
00:37:16.986 --> 00:37:20.926 A:middle
That means for each, if the
vertex shader is being executed

835
00:37:20.926 --> 00:37:24.596 A:middle
over n vertices, all
of these instances

836
00:37:24.596 --> 00:37:26.136 A:middle
that are executing the
vertex shader are going

837
00:37:26.136 --> 00:37:27.566 A:middle
to be unique locations.

838
00:37:27.746 --> 00:37:30.916 A:middle
So when you see that data
pattern, you want to use global.

839
00:37:32.196 --> 00:37:33.576 A:middle
Okay, and the same
thing for compute.

840
00:37:33.626 --> 00:37:35.496 A:middle
You will find that
out when we talk

841
00:37:35.496 --> 00:37:36.636 A:middle
about computing in
the next session.

842
00:37:37.486 --> 00:37:41.906 A:middle
However, you will also find
in your shader that you may,

843
00:37:42.136 --> 00:37:45.066 A:middle
you are actually accessing
some data structures where all

844
00:37:45.066 --> 00:37:48.656 A:middle
of these instances actually
access the same location.

845
00:37:48.856 --> 00:37:51.986 A:middle
For example, if you
have a light descriptor.

846
00:37:52.296 --> 00:37:53.416 A:middle
Or if you're doing skinning.

847
00:37:53.416 --> 00:37:54.406 A:middle
Or if you're doing filtering.

848
00:37:55.046 --> 00:37:56.356 A:middle
So in this case you will find

849
00:37:56.356 --> 00:38:00.876 A:middle
that all these instances
executing your vertex shader go

850
00:38:00.876 --> 00:38:02.536 A:middle
refer to the same
light descriptor.

851
00:38:02.756 --> 00:38:04.416 A:middle
All of the same skinning matrix.

852
00:38:04.736 --> 00:38:05.826 A:middle
So let's look at an example.

853
00:38:06.336 --> 00:38:08.746 A:middle
One more thing here is
that when you use constant,

854
00:38:08.986 --> 00:38:10.566 A:middle
we really want you
to pass by reference.

855
00:38:11.006 --> 00:38:12.816 A:middle
Because that tells
us what the size it

856
00:38:12.816 --> 00:38:15.186 A:middle
and we can actually optimize
by prefetching the data.

857
00:38:15.246 --> 00:38:18.606 A:middle
And that can have a significant
impact to improvement

858
00:38:18.606 --> 00:38:19.596 A:middle
of performance of the shader.

859
00:38:19.706 --> 00:38:23.146 A:middle
So definitely take
advantage of that.

860
00:38:23.146 --> 00:38:24.346 A:middle
Okay, so let's take an example.

861
00:38:24.846 --> 00:38:26.466 A:middle
Here I have four arguments,

862
00:38:26.696 --> 00:38:29.386 A:middle
passing three buffers
and my vertex ID.

863
00:38:29.386 --> 00:38:30.976 A:middle
So let's look at the
first data pattern.

864
00:38:31.516 --> 00:38:33.136 A:middle
Look at normal data
and position data.

865
00:38:33.136 --> 00:38:35.876 A:middle
I'm actually accessing
using my vertex ID,

866
00:38:35.876 --> 00:38:38.886 A:middle
so which address space
should these belong in?

867
00:38:40.176 --> 00:38:42.376 A:middle
Global. But if you look

868
00:38:42.376 --> 00:38:46.786 A:middle
at the other three data
pattern accesses and matrices,

869
00:38:46.786 --> 00:38:50.596 A:middle
you notice that if in a multiple
vertices root exiting this

870
00:38:50.596 --> 00:38:53.246 A:middle
function across multiple
vertices, they're going to defer

871
00:38:53.246 --> 00:38:56.536 A:middle
to the same normal matrix,
the same projection matrix.

872
00:38:57.026 --> 00:38:59.696 A:middle
So, therefore, I
should declare these

873
00:38:59.696 --> 00:39:00.826 A:middle
in a constant address space.

874
00:39:00.826 --> 00:39:02.886 A:middle
So hopefully this gives
you an idea of how

875
00:39:02.886 --> 00:39:05.326 A:middle
to declare your buffers
in which address space.

876
00:39:05.446 --> 00:39:06.786 A:middle
You don't have to do
that for textures.

877
00:39:07.206 --> 00:39:11.056 A:middle
All right, so let's talk
about inputs and outputs.

878
00:39:11.056 --> 00:39:14.526 A:middle
So that was a very high-level
overview of the data types.

879
00:39:14.526 --> 00:39:17.736 A:middle
So, how do you pass input
through your vertex shader?

880
00:39:17.886 --> 00:39:18.886 A:middle
Well there are two ways.

881
00:39:19.346 --> 00:39:21.026 A:middle
The first one we've
actually shown you, right.

882
00:39:21.026 --> 00:39:24.186 A:middle
In all of the examples I have
shown you, you pass the input

883
00:39:24.296 --> 00:39:27.276 A:middle
by passing a point to
a struct, you declare,

884
00:39:27.276 --> 00:39:29.276 A:middle
and then you use your
vertex ID to index into it.

885
00:39:29.626 --> 00:39:32.486 A:middle
So that means is you
actually know the data layout

886
00:39:33.146 --> 00:39:34.726 A:middle
of your vertex inputting
in a shader.

887
00:39:34.796 --> 00:39:38.056 A:middle
So if you do, this is
the way to do it, okay.

888
00:39:38.056 --> 00:39:40.506 A:middle
So in addition to your vertex
ID you can also use your

889
00:39:40.506 --> 00:39:41.206 A:middle
instance ID.

890
00:39:42.246 --> 00:39:45.076 A:middle
Like in this example, I
have two inputs I'm passing

891
00:39:45.076 --> 00:39:49.736 A:middle
in as buffers, and I'm using
the vertex ID and instance ID.

892
00:39:50.046 --> 00:39:52.946 A:middle
But there is also the
traditional approach.

893
00:39:53.486 --> 00:39:57.216 A:middle
So in this approach, you
don't know the data layout

894
00:39:57.456 --> 00:39:58.076 A:middle
in your shader.

895
00:39:58.546 --> 00:40:01.656 A:middle
And so if you want it all,
you may want to decouple.

896
00:40:01.886 --> 00:40:04.446 A:middle
You may want to declare in your
vertex shader you have other

897
00:40:04.446 --> 00:40:07.056 A:middle
data types you want to
use for your vertex inputs

898
00:40:07.056 --> 00:40:09.106 A:middle
because of the computations
you're doing in your shader.

899
00:40:09.606 --> 00:40:13.056 A:middle
And have the flexibility to be
able to declare the actual input

900
00:40:13.296 --> 00:40:15.146 A:middle
at runtime in the
buffers your showing

901
00:40:15.146 --> 00:40:15.976 A:middle
and they may be different.

902
00:40:16.486 --> 00:40:20.376 A:middle
So, this is more like the
OpenGL's Vertex Array API.

903
00:40:20.376 --> 00:40:25.006 A:middle
And so this, this approach in
Metal is actually a good match.

904
00:40:25.096 --> 00:40:26.936 A:middle
And let me talk about
how it works.

905
00:40:27.346 --> 00:40:28.176 A:middle
So the thing you'll do

906
00:40:28.176 --> 00:40:30.586 A:middle
in the runtime is you will
create a vertex descriptor.

907
00:40:30.656 --> 00:40:32.906 A:middle
So in this descriptor for
each input, you're going

908
00:40:32.906 --> 00:40:36.546 A:middle
to specify the buffer it comes
from, where inside the buffer,

909
00:40:37.566 --> 00:40:39.936 A:middle
what is the format,
things like that.

910
00:40:40.376 --> 00:40:43.106 A:middle
And you may have one or more
buffers for your inputs.

911
00:40:43.346 --> 00:40:46.826 A:middle
In the shader, everything
that is an input, you're going

912
00:40:46.826 --> 00:40:47.916 A:middle
to declare them in the struct.

913
00:40:47.916 --> 00:40:51.456 A:middle
And remember I said, anything
that is user defined information

914
00:40:51.456 --> 00:40:53.186 A:middle
that you want to
generate per instance,

915
00:40:53.936 --> 00:40:55.066 A:middle
you have to use stage
underscore in.

916
00:40:55.066 --> 00:40:55.936 A:middle
So that's how you declare it.

917
00:40:56.616 --> 00:40:58.506 A:middle
So let's look at a code example.

918
00:40:59.986 --> 00:41:02.986 A:middle
Before that, so I declared
my struct and my shader,

919
00:41:03.196 --> 00:41:06.186 A:middle
and I declared my vertex
descriptor, all my inputs

920
00:41:06.186 --> 00:41:07.776 A:middle
and my vertex descriptor,
I need to be able

921
00:41:07.776 --> 00:41:08.926 A:middle
to say hey, this will work.

922
00:41:08.926 --> 00:41:11.246 A:middle
I need to be able to
map one to the other.

923
00:41:11.346 --> 00:41:12.876 A:middle
And the way I do that is

924
00:41:12.876 --> 00:41:15.376 A:middle
by specifying an
attributing index, okay.

925
00:41:15.466 --> 00:41:16.396 A:middle
So let's look at an example.

926
00:41:16.396 --> 00:41:19.236 A:middle
Let's say I want to
pass four inputs.

927
00:41:19.406 --> 00:41:21.906 A:middle
The first one is going to be
positioned, and it's going

928
00:41:21.906 --> 00:41:25.306 A:middle
to be an index 0,
and 12 bytes in size.

929
00:41:25.376 --> 00:41:26.706 A:middle
The next one is normal.

930
00:41:27.186 --> 00:41:29.656 A:middle
It's also at offset 12
and 12 bytes in size.

931
00:41:29.656 --> 00:41:31.356 A:middle
In fact, all four
inputs are going

932
00:41:31.356 --> 00:41:32.426 A:middle
to come from the same buffer.

933
00:41:32.816 --> 00:41:36.486 A:middle
And so the next one is color
at index 2, 4 bytes in size.

934
00:41:36.486 --> 00:41:39.606 A:middle
And then third is texture
coordinate at index 3,

935
00:41:39.606 --> 00:41:40.926 A:middle
4 bytes in size, okay.

936
00:41:41.366 --> 00:41:43.026 A:middle
All right, so how do I
declare this in the shader?

937
00:41:43.516 --> 00:41:44.526 A:middle
So I have a struct.

938
00:41:44.526 --> 00:41:47.716 A:middle
I have defined the data
types I want to use.

939
00:41:48.146 --> 00:41:50.326 A:middle
And the attribute indices
they're going to use.

940
00:41:50.326 --> 00:41:53.226 A:middle
And notice that I've declared
them with the stage a qualifier

941
00:41:53.226 --> 00:41:54.966 A:middle
because this is going
to be per instance.

942
00:41:55.436 --> 00:41:57.376 A:middle
For every instance it
executes as a vertex shader.

943
00:41:57.476 --> 00:41:59.276 A:middle
Okay, so let's look at the API.

944
00:41:59.776 --> 00:42:00.696 A:middle
So the first thing I'm going

945
00:42:00.696 --> 00:42:02.776 A:middle
to do is create the
vertex descriptor.

946
00:42:03.536 --> 00:42:06.496 A:middle
So the first imput
was my position.

947
00:42:06.576 --> 00:42:08.906 A:middle
So I'm going to say
float3 is 12 bytes.

948
00:42:08.906 --> 00:42:11.296 A:middle
It's going to start us off at 0.

949
00:42:11.926 --> 00:42:15.996 A:middle
And notice I had a single
buffer for all of the input.

950
00:42:15.996 --> 00:42:18.406 A:middle
So my buffer index for all
of these is going to be 0.

951
00:42:19.226 --> 00:42:20.446 A:middle
The attribute index is 0.

952
00:42:21.196 --> 00:42:24.696 A:middle
The next I set the
normal, so at index1.

953
00:42:24.696 --> 00:42:27.736 A:middle
The next I set color, at index2.

954
00:42:27.736 --> 00:42:29.346 A:middle
Actual coordinate.

955
00:42:30.156 --> 00:42:33.796 A:middle
And for each buffer that I'm
using could declare my vertex

956
00:42:33.796 --> 00:42:36.776 A:middle
inputs and my descriptor,
I have to say the stride,

957
00:42:37.116 --> 00:42:39.376 A:middle
what is the stride so I can
fetch the right vertex data.

958
00:42:40.066 --> 00:42:41.476 A:middle
So in this case it's 32 bytes.

959
00:42:41.626 --> 00:42:42.366 A:middle
So I did that.

960
00:42:43.276 --> 00:42:44.826 A:middle
Then I put this vertex
descriptor

961
00:42:45.376 --> 00:42:47.076 A:middle
to in my pipeline descriptor.

962
00:42:47.226 --> 00:42:49.536 A:middle
And then I create
my pipeline object,

963
00:42:49.606 --> 00:42:50.736 A:middle
my RenderPipeline object.

964
00:42:51.026 --> 00:42:55.206 A:middle
And at that point in time,
Metal will go figure out how

965
00:42:55.206 --> 00:42:57.016 A:middle
to generate the code
to go fetch your input.

966
00:42:57.226 --> 00:42:58.576 A:middle
So, you have both
options available.

967
00:42:58.576 --> 00:43:02.216 A:middle
Use which works best
for your problem.

968
00:43:02.606 --> 00:43:06.606 A:middle
All right, outputs, well there
are two ways of writing inputs,

969
00:43:06.606 --> 00:43:08.516 A:middle
so we wanted to make
sure you get two ways

970
00:43:08.516 --> 00:43:09.506 A:middle
of writing outputs too.

971
00:43:10.466 --> 00:43:13.576 A:middle
So, typically what you
would do is the output

972
00:43:13.576 --> 00:43:15.906 A:middle
of your vertex shader will go
that rasterizer because you want

973
00:43:15.906 --> 00:43:17.446 A:middle
to show something on the screen,

974
00:43:17.446 --> 00:43:18.796 A:middle
so you want to rasterize
triangles.

975
00:43:19.276 --> 00:43:22.856 A:middle
So anything that you
return from the return type

976
00:43:22.856 --> 00:43:25.306 A:middle
of your vertex shader is what's
going to go to that rasterizer.

977
00:43:25.566 --> 00:43:26.416 A:middle
So what can I return?

978
00:43:26.626 --> 00:43:27.786 A:middle
I can return a float4.

979
00:43:27.996 --> 00:43:30.996 A:middle
At a minimum I must return a
float4, and I'll tell you why.

980
00:43:31.416 --> 00:43:33.106 A:middle
Or you can have a
user-defined struct.

981
00:43:33.606 --> 00:43:35.106 A:middle
What can be I this struct?

982
00:43:35.316 --> 00:43:38.736 A:middle
So there can be a scalar,
a vector or a matrix.

983
00:43:38.736 --> 00:43:39.966 A:middle
You can even have
arrays of these.

984
00:43:40.776 --> 00:43:42.476 A:middle
There's some special
variables we need to know

985
00:43:42.476 --> 00:43:44.876 A:middle
about like position, point size

986
00:43:44.876 --> 00:43:47.096 A:middle
if you're rendering a point
sprite or clip distance.

987
00:43:47.586 --> 00:43:49.946 A:middle
You must return a float4
because the position must always

988
00:43:49.946 --> 00:43:50.376 A:middle
be returned.

989
00:43:50.376 --> 00:43:51.616 A:middle
It's kind of hard
for the rasterizer

990
00:43:51.616 --> 00:43:54.306 A:middle
to generate rasterized triangles
for that [inaudible] position.

991
00:43:54.816 --> 00:43:55.376 A:middle
So that's why.

992
00:43:57.336 --> 00:43:58.946 A:middle
All right, so here's an example.

993
00:43:59.926 --> 00:44:01.076 A:middle
I'm returning four things.

994
00:44:01.686 --> 00:44:05.766 A:middle
And I use the built-in variables
attributes to identify things

995
00:44:05.766 --> 00:44:07.146 A:middle
as position and point size.

996
00:44:07.226 --> 00:44:08.806 A:middle
This is really pretty
straight forward.

997
00:44:08.806 --> 00:44:09.636 A:middle
Declare your struct.

998
00:44:10.086 --> 00:44:11.596 A:middle
Declare some attributes
and you're done.

999
00:44:12.606 --> 00:44:14.146 A:middle
Okay. So it's great.

1000
00:44:14.936 --> 00:44:17.826 A:middle
I can generate output,
pass it to the rasterizer.

1001
00:44:17.986 --> 00:44:18.976 A:middle
But I want to do more.

1002
00:44:20.256 --> 00:44:22.966 A:middle
I want to be able to
write some buffer,

1003
00:44:23.066 --> 00:44:24.336 A:middle
maybe more than one buffer.

1004
00:44:24.336 --> 00:44:26.416 A:middle
I don't want to send
anything to the rasterizer.

1005
00:44:26.616 --> 00:44:27.776 A:middle
Or maybe I want to do both.

1006
00:44:28.236 --> 00:44:28.826 A:middle
Can I do that?

1007
00:44:29.116 --> 00:44:34.216 A:middle
The answer is we
are here to please.

1008
00:44:36.396 --> 00:44:39.386 A:middle
So remember the vertex ID
you can use that to input.

1009
00:44:39.386 --> 00:44:40.496 A:middle
Well guess what?

1010
00:44:40.496 --> 00:44:42.726 A:middle
You can use that to output too.

1011
00:44:42.856 --> 00:44:45.226 A:middle
So here is the structure
I want to write out.

1012
00:44:45.256 --> 00:44:49.546 A:middle
I want to pass that as, declare

1013
00:44:49.546 --> 00:44:52.356 A:middle
that as a struct
to create a buffer.

1014
00:44:52.356 --> 00:44:54.206 A:middle
Pass that as an argument
to my shader.

1015
00:44:55.036 --> 00:44:57.716 A:middle
And output to it
using the vertex ID.

1016
00:44:58.236 --> 00:45:05.636 A:middle
In fact, I can pass up to 31
buffers if one is not enough.

1017
00:45:05.636 --> 00:45:08.056 A:middle
You notice I'm not
returning anything here

1018
00:45:08.056 --> 00:45:09.086 A:middle
because the return type.

1019
00:45:11.186 --> 00:45:13.226 A:middle
But I could have returned
the same struct here,

1020
00:45:13.396 --> 00:45:15.366 A:middle
or I could return something
completely different.

1021
00:45:15.656 --> 00:45:18.336 A:middle
So you have a lot
of flexibility here.

1022
00:45:18.666 --> 00:45:19.006 A:middle
All right.

1023
00:45:19.846 --> 00:45:21.706 A:middle
So that's per vertex
inputs/outputs.

1024
00:45:21.926 --> 00:45:23.566 A:middle
Per-fragments are a lot simpler.

1025
00:45:23.696 --> 00:45:25.146 A:middle
There's only one way
of doing things here.

1026
00:45:25.696 --> 00:45:31.786 A:middle
So, the inputs to a fragment
shader are typically the outputs

1027
00:45:31.786 --> 00:45:33.906 A:middle
of the vertex shader because
they go to the rasterizer

1028
00:45:34.016 --> 00:45:36.526 A:middle
and they generate fragments
and that's the inputs.

1029
00:45:36.996 --> 00:45:39.926 A:middle
So what can I, must be declared
in with this stage in qualifier.

1030
00:45:41.776 --> 00:45:44.666 A:middle
Sometimes the raster also
generates information

1031
00:45:44.666 --> 00:45:46.226 A:middle
that you may actually
want to know about,

1032
00:45:46.226 --> 00:45:48.066 A:middle
like is my triangle
front-facing?

1033
00:45:48.616 --> 00:45:50.176 A:middle
Or if I'm doing multi-sampling,

1034
00:45:51.226 --> 00:45:53.186 A:middle
so things like that
you can use attributes

1035
00:45:53.726 --> 00:45:55.646 A:middle
to identify these inputs.

1036
00:45:55.736 --> 00:45:57.896 A:middle
And if you wanted to
program a blending,

1037
00:45:58.216 --> 00:45:59.996 A:middle
you want to read the
frame buffer color value.

1038
00:46:00.276 --> 00:46:02.926 A:middle
So, you can, so let's
talk about how I do that.

1039
00:46:03.136 --> 00:46:04.276 A:middle
So here's an example.

1040
00:46:05.136 --> 00:46:08.716 A:middle
In this case, my fragment
input was the output

1041
00:46:08.716 --> 00:46:09.636 A:middle
of the vertex shader.

1042
00:46:09.926 --> 00:46:12.136 A:middle
So I used the staging
qualifier to say

1043
00:46:12.136 --> 00:46:13.676 A:middle
that this is a per-fragment
input.

1044
00:46:14.686 --> 00:46:18.106 A:middle
I want to read whether the
triangle is front facing or not.

1045
00:46:18.106 --> 00:46:20.696 A:middle
So I use this attribute
to identify

1046
00:46:20.696 --> 00:46:22.986 A:middle
that this front face is
a front-facing variable.

1047
00:46:23.056 --> 00:46:25.386 A:middle
And I also want to do
blending in my shader.

1048
00:46:25.646 --> 00:46:28.066 A:middle
So I'm going to read
front color attachment 0.

1049
00:46:29.856 --> 00:46:31.936 A:middle
Though I passed as a
separate arguments here,

1050
00:46:31.936 --> 00:46:32.866 A:middle
they don't have to be.

1051
00:46:32.866 --> 00:46:37.406 A:middle
I could have declared them
in the struct itself, okay.

1052
00:46:38.126 --> 00:46:40.166 A:middle
Outputs from a fragment
shader work just

1053
00:46:40.166 --> 00:46:41.906 A:middle
like outputs from
a vertex shader.

1054
00:46:42.226 --> 00:46:43.256 A:middle
You can't write the
memory though.

1055
00:46:43.356 --> 00:46:44.176 A:middle
Only the first one.

1056
00:46:44.176 --> 00:46:45.106 A:middle
So you only return type.

1057
00:46:45.106 --> 00:46:49.016 A:middle
And you get in return a scalar,
vector or user-defined struct.

1058
00:46:49.016 --> 00:46:50.146 A:middle
A lot of flexibility here.

1059
00:46:50.476 --> 00:46:53.316 A:middle
But the only you can return in
a fragment shader is a color,

1060
00:46:53.316 --> 00:46:55.536 A:middle
a depth or a sample mask.

1061
00:46:55.796 --> 00:46:57.676 A:middle
And we need to know so you have

1062
00:46:57.676 --> 00:46:59.546 A:middle
to four color attachments,
one depth.

1063
00:46:59.966 --> 00:47:00.856 A:middle
And sample mass.

1064
00:47:00.856 --> 00:47:02.126 A:middle
We need to know what
you're writing to.

1065
00:47:02.186 --> 00:47:05.156 A:middle
And so you identify them
with attributes, okay.

1066
00:47:06.036 --> 00:47:10.696 A:middle
So in this example, I'm
just returning a single

1067
00:47:10.696 --> 00:47:11.836 A:middle
and a color value back.

1068
00:47:11.836 --> 00:47:13.826 A:middle
This is going to be returned
to color attachment zero.

1069
00:47:14.676 --> 00:47:17.646 A:middle
Here's another example where I'm
returning more than one color.

1070
00:47:17.946 --> 00:47:20.726 A:middle
And notice here that the color
attachments don't have to be

1071
00:47:20.726 --> 00:47:22.356 A:middle
in the right order, okay.

1072
00:47:22.426 --> 00:47:23.396 A:middle
They can be sparse.

1073
00:47:24.836 --> 00:47:27.166 A:middle
All right, you guys ready
for some matchmaking?

1074
00:47:28.436 --> 00:47:33.176 A:middle
All right, so I've written,
you've written a vertex shader

1075
00:47:33.176 --> 00:47:34.086 A:middle
and a fragment shader.

1076
00:47:34.516 --> 00:47:36.986 A:middle
I want to pair them because
I can't do the RenderPipeline

1077
00:47:36.986 --> 00:47:37.496 A:middle
without it.

1078
00:47:37.496 --> 00:47:38.496 A:middle
So how do I pair?

1079
00:47:38.786 --> 00:47:39.516 A:middle
What are the rules?

1080
00:47:39.976 --> 00:47:41.916 A:middle
The simplest rule
is the types match.

1081
00:47:42.776 --> 00:47:46.536 A:middle
That means to return type of
the vertex share is the input

1082
00:47:46.756 --> 00:47:47.556 A:middle
to the fragment sharer.

1083
00:47:47.626 --> 00:47:49.406 A:middle
In this example,
that's what it is.

1084
00:47:50.356 --> 00:47:52.576 A:middle
And this will always pair, okay.

1085
00:47:53.386 --> 00:47:54.586 A:middle
But that's boring.

1086
00:47:54.736 --> 00:47:59.856 A:middle
I want to just, I want
to declare my own struct

1087
00:47:59.946 --> 00:48:01.626 A:middle
as my input to my
fragment shader,

1088
00:48:01.626 --> 00:48:03.976 A:middle
and that can be a subset.

1089
00:48:03.976 --> 00:48:05.606 A:middle
In fact, that's typically
very common

1090
00:48:05.636 --> 00:48:08.696 A:middle
if I use one vertex shader with
many, many fragment shaders.

1091
00:48:08.696 --> 00:48:09.936 A:middle
So where's the rule here then?

1092
00:48:09.936 --> 00:48:10.566 A:middle
How do I pair?

1093
00:48:10.566 --> 00:48:11.906 A:middle
The rule is really simple.

1094
00:48:12.036 --> 00:48:14.556 A:middle
For anything that's an
input to the fragment,

1095
00:48:15.696 --> 00:48:20.726 A:middle
it's attribute name and type
must exist in the vertex output.

1096
00:48:20.916 --> 00:48:26.326 A:middle
So in this example, you know,
I have position is a float4

1097
00:48:26.326 --> 00:48:29.066 A:middle
in my fragment input, but it
exists, and it's the same.

1098
00:48:29.766 --> 00:48:32.386 A:middle
Same thing for this
attribute, user(T).

1099
00:48:32.386 --> 00:48:35.406 A:middle
So anything that's not
a variable, you can come

1100
00:48:35.616 --> 00:48:36.766 A:middle
up with your own name.

1101
00:48:37.006 --> 00:48:40.636 A:middle
It just needs to use the user
parenthesis, a basis index.

1102
00:48:41.096 --> 00:48:42.546 A:middle
So that's the same thing here.

1103
00:48:43.806 --> 00:48:46.726 A:middle
And so if I create a vertex
shader and a fragment shader

1104
00:48:46.896 --> 00:48:48.876 A:middle
that uses these types,
they will pair.

1105
00:48:49.516 --> 00:48:50.956 A:middle
Note that there is
no requirement

1106
00:48:50.956 --> 00:48:52.666 A:middle
that all the elements I have

1107
00:48:52.666 --> 00:48:55.266 A:middle
in my fragment input must
occur in the same order.

1108
00:48:55.446 --> 00:48:57.976 A:middle
They can occur in any order,
they just need to occur.

1109
00:48:58.276 --> 00:48:58.586 A:middle
That's it.

1110
00:48:58.626 --> 00:49:00.926 A:middle
All right so that's
matchmaking for you guys.

1111
00:49:01.806 --> 00:49:04.026 A:middle
Okay. All right my
favorite topic, math.

1112
00:49:04.836 --> 00:49:08.776 A:middle
Is anyone interested in math?

1113
00:49:08.866 --> 00:49:13.876 A:middle
But why? Well because the two
common operations you guys are

1114
00:49:13.876 --> 00:49:15.816 A:middle
going to do are loads
and stores.

1115
00:49:16.136 --> 00:49:18.026 A:middle
And the rest is math.

1116
00:49:19.346 --> 00:49:21.776 A:middle
By default, all operation
math operations

1117
00:49:21.776 --> 00:49:23.876 A:middle
in Metal are in fast math mode.

1118
00:49:23.876 --> 00:49:27.016 A:middle
So want to make sure you get
the absolute fastest experience

1119
00:49:27.016 --> 00:49:28.366 A:middle
of shaders running on the GPU.

1120
00:49:28.746 --> 00:49:31.656 A:middle
Did anyone say, well, do you
want to give me fast mode,

1121
00:49:31.656 --> 00:49:33.656 A:middle
why do I care about
precise mode.

1122
00:49:34.316 --> 00:49:36.286 A:middle
Well because you
don't fast modes comes

1123
00:49:36.286 --> 00:49:38.206 A:middle
with some caveats, it's fast.

1124
00:49:39.116 --> 00:49:42.746 A:middle
So, sometimes like in fast
mode we tell you behavior

1125
00:49:42.746 --> 00:49:44.666 A:middle
of nans is NaNs is not defined.

1126
00:49:44.666 --> 00:49:45.756 A:middle
So NaN is not a number.

1127
00:49:46.486 --> 00:49:47.556 A:middle
Well then why do
I care about that?

1128
00:49:47.556 --> 00:49:48.146 A:middle
It's not a number.

1129
00:49:48.146 --> 00:49:50.066 A:middle
I'm not going to do
math on a not a number.

1130
00:49:50.066 --> 00:49:51.806 A:middle
You're like well
sometimes you do.

1131
00:49:52.346 --> 00:49:55.626 A:middle
So for example, if I'm clamping
an input with some minimum

1132
00:49:55.626 --> 00:49:59.996 A:middle
and a maximum, if I pass
an input that's NaN,

1133
00:49:59.996 --> 00:50:02.646 A:middle
in fast mode we're
going to say ah,

1134
00:50:02.646 --> 00:50:03.976 A:middle
we don't know what the
answer is going to be.

1135
00:50:04.446 --> 00:50:06.736 A:middle
But if you actually
follow iTripoli54 rules,

1136
00:50:06.736 --> 00:50:08.246 A:middle
there's guaranteed
defined behavior.

1137
00:50:08.246 --> 00:50:09.656 A:middle
And you may actually
care about that.

1138
00:50:10.426 --> 00:50:12.716 A:middle
Or, let's say you're using
trigonometric functions

1139
00:50:12.716 --> 00:50:13.336 A:middle
in your shader.

1140
00:50:13.806 --> 00:50:16.936 A:middle
In fast mode, they work
great over a small range.

1141
00:50:17.556 --> 00:50:20.006 A:middle
If your inputs go above
and beyond that range,

1142
00:50:20.326 --> 00:50:21.446 A:middle
behavior is undefined.

1143
00:50:22.046 --> 00:50:25.126 A:middle
So, let's say you want
correct behavior for those.

1144
00:50:26.216 --> 00:50:28.516 A:middle
Then you want to
use precise mode.

1145
00:50:29.036 --> 00:50:32.576 A:middle
So one option is you're going
to say I want my entire shader

1146
00:50:32.576 --> 00:50:33.616 A:middle
to run in precise mode.

1147
00:50:33.816 --> 00:50:34.666 A:middle
You can do that.

1148
00:50:34.666 --> 00:50:36.016 A:middle
You can set the compiler option.

1149
00:50:36.196 --> 00:50:38.706 A:middle
But that may actually,

1150
00:50:38.706 --> 00:50:40.776 A:middle
so you need to really know what
you're doing before you set

1151
00:50:40.776 --> 00:50:41.436 A:middle
that option.

1152
00:50:41.556 --> 00:50:43.296 A:middle
So, but that option does exist.

1153
00:50:43.406 --> 00:50:47.296 A:middle
All right, I think the more
common scenario is, you know,

1154
00:50:47.296 --> 00:50:49.936 A:middle
you're going to do most of
your stuff in fast mode.

1155
00:50:50.416 --> 00:50:55.156 A:middle
There may be some functions you
want to run in precise mode.

1156
00:50:55.296 --> 00:50:56.776 A:middle
So, you can do that in Metal.

1157
00:50:57.586 --> 00:50:59.896 A:middle
Because guess what, these
functions actually occur

1158
00:50:59.896 --> 00:51:00.916 A:middle
in nested name spaces.

1159
00:51:02.256 --> 00:51:09.266 A:middle
So by default, you get
the fast name space.

1160
00:51:09.566 --> 00:51:13.456 A:middle
But you can call the precise
math function explicitly, okay.

1161
00:51:14.296 --> 00:51:15.616 A:middle
So that's it.

1162
00:51:17.026 --> 00:51:18.536 A:middle
Ah Metal standard library.

1163
00:51:18.646 --> 00:51:20.346 A:middle
So we don't do the
C++ standard library.

1164
00:51:20.676 --> 00:51:21.446 A:middle
We do our own.

1165
00:51:21.776 --> 00:51:23.976 A:middle
And it is really
optimized for the GPU.

1166
00:51:23.976 --> 00:51:25.776 A:middle
And I think you guys
are going to love it.

1167
00:51:25.776 --> 00:51:27.326 A:middle
I think it has a nice
list of functions.

1168
00:51:28.036 --> 00:51:30.066 A:middle
It's all described
in the documentation.

1169
00:51:30.486 --> 00:51:33.366 A:middle
I'm going to cover
details of these functions,

1170
00:51:33.366 --> 00:51:34.986 A:middle
but please refer
to the specs of,

1171
00:51:34.986 --> 00:51:36.016 A:middle
these are some of the functions.

1172
00:51:36.556 --> 00:51:38.486 A:middle
There's quite a few, okay.

1173
00:51:39.186 --> 00:51:42.276 A:middle
All right, so what did we do?

1174
00:51:43.226 --> 00:51:45.016 A:middle
We covered, Richard talked

1175
00:51:45.016 --> 00:51:46.936 A:middle
about how you build
a Metal application.

1176
00:51:47.156 --> 00:51:49.306 A:middle
And he showed you how to
draw a simple triangle.

1177
00:51:49.306 --> 00:51:51.626 A:middle
But then he took
it even further.

1178
00:51:51.866 --> 00:51:56.656 A:middle
He showed you how to do
stream uniforms, okay,

1179
00:51:57.056 --> 00:51:59.616 A:middle
with multiple buffers and how
to synchronize them efficiently.

1180
00:52:00.186 --> 00:52:02.096 A:middle
Then I talked to you guys
about the shading language.

1181
00:52:02.096 --> 00:52:02.896 A:middle
We went on a tour.

1182
00:52:03.256 --> 00:52:06.496 A:middle
We didn't go much deeper,
but a very high level tour.

1183
00:52:06.806 --> 00:52:09.626 A:middle
We talked about how to write
shaders, given that it's based

1184
00:52:09.626 --> 00:52:12.496 A:middle
on C++, it's actually going to
be really, really easy for you

1185
00:52:12.496 --> 00:52:13.726 A:middle
to write these shaders.

1186
00:52:14.246 --> 00:52:16.046 A:middle
We talked about data
types Metal supports.

1187
00:52:16.526 --> 00:52:18.806 A:middle
We talked about inputs
and outputs to shaders.

1188
00:52:18.996 --> 00:52:20.566 A:middle
We talked about how
to match them.

1189
00:52:21.016 --> 00:52:22.146 A:middle
We talked about math.

1190
00:52:23.986 --> 00:52:25.636 A:middle
So really, now it's your turn.

1191
00:52:26.326 --> 00:52:29.026 A:middle
I'm excited about how the
amazing ways you guys are going

1192
00:52:29.026 --> 00:52:29.636 A:middle
to use Metal.

1193
00:52:30.316 --> 00:52:32.096 A:middle
And we want to hear from you.

1194
00:52:32.236 --> 00:52:34.106 A:middle
We want to know how we can
improve this even better.

1195
00:52:34.106 --> 00:52:37.156 A:middle
So, please come talk to us.

1196
00:52:38.166 --> 00:52:42.136 A:middle
So, for more information,
please Filip Iliescu

1197
00:52:42.136 --> 00:52:43.556 A:middle
and Allan Schaffer
are evangelists.

1198
00:52:43.636 --> 00:52:45.086 A:middle
Their email addresses are here,

1199
00:52:45.286 --> 00:52:47.826 A:middle
so bug them as much
as you can, okay.

1200
00:52:48.666 --> 00:52:50.266 A:middle
And Jeremy talked
about documentation.

1201
00:52:50.266 --> 00:52:52.456 A:middle
All documentation
for both the API

1202
00:52:52.456 --> 00:52:54.876 A:middle
and the language
are on our website.

1203
00:52:55.376 --> 00:52:58.456 A:middle
Please, you can use the
forums to ask questions.

1204
00:52:58.966 --> 00:53:01.946 A:middle
But actually, there's
one more session.

