

1
00:00:13.236 --> 00:00:14.526 A:middle
&gt;&gt; Olivier Bonnet: My
name is Olivier Bonnet.

2
00:00:14.526 --> 00:00:18.266 A:middle
I'm the Interim Manager for the
CloudKit on the client side.

3
00:00:20.536 --> 00:00:25.976 A:middle
So up until today, Apple had
many iCloud technologies,

4
00:00:25.976 --> 00:00:28.266 A:middle
and they looked like
this to you.

5
00:00:28.426 --> 00:00:31.666 A:middle
We had iCloud Drive, iCloud
CoreData, iCloud Photo Library.

6
00:00:31.976 --> 00:00:36.446 A:middle
And how they interacted with
the Apple iCloud server was kind

7
00:00:36.486 --> 00:00:36.996 A:middle
of a mystery.

8
00:00:37.286 --> 00:00:42.276 A:middle
So today we're lifting
some of the mystery

9
00:00:42.276 --> 00:00:43.576 A:middle
in introducing CloudKit.

10
00:00:45.056 --> 00:00:47.336 A:middle
So let's look at
what we're going

11
00:00:47.336 --> 00:00:49.016 A:middle
to cover here in this session.

12
00:00:49.306 --> 00:00:53.686 A:middle
So first, we're going to
start with "What is CloudKit?"

13
00:00:55.566 --> 00:00:58.996 A:middle
We're going to walk you through
the couple of steps you need

14
00:00:58.996 --> 00:01:01.466 A:middle
to enable CloudKit in your
application and start using it;

15
00:01:02.806 --> 00:01:05.996 A:middle
we're going to do a walkthrough
of the different APIs;

16
00:01:06.676 --> 00:01:10.266 A:middle
we're going to talk about
how CloudKit interacts

17
00:01:10.266 --> 00:01:15.406 A:middle
with the Apple, the iCloud
user accounts; and last

18
00:01:15.406 --> 00:01:18.246 A:middle
but not least, we'll cover
when to use CloudKit,

19
00:01:18.246 --> 00:01:22.516 A:middle
as opposed to other existing
iCloud APIs we already have

20
00:01:22.516 --> 00:01:23.426 A:middle
on the platforms.

21
00:01:25.356 --> 00:01:26.416 A:middle
So let's start.

22
00:01:26.416 --> 00:01:27.286 A:middle
What is CloudKit?

23
00:01:28.576 --> 00:01:31.686 A:middle
You'll notice the new badge,
but the whole session is new.

24
00:01:31.786 --> 00:01:33.626 A:middle
So it's here only on that slide.

25
00:01:35.566 --> 00:01:39.396 A:middle
CloudKit is a way to give
you access to iCloud servers,

26
00:01:39.816 --> 00:01:42.396 A:middle
and we really mean it.

27
00:01:42.806 --> 00:01:46.206 A:middle
CloudKit is the foundation
for both iCloud Drive

28
00:01:46.466 --> 00:01:47.736 A:middle
and iCloud Photo Library.

29
00:01:48.346 --> 00:01:51.586 A:middle
Both features were written from
scratch on top of CloudKit.

30
00:01:52.936 --> 00:01:55.936 A:middle
CloudKit is supported
on both OS X and iOS.

31
00:01:56.006 --> 00:01:58.966 A:middle
It's a new public
framework- CloudKit.framework.

32
00:01:59.436 --> 00:02:01.326 A:middle
Check it out in the SDK.

33
00:02:02.596 --> 00:02:05.826 A:middle
CloudKit uses the iCloud
account's infrastructure.

34
00:02:05.826 --> 00:02:10.376 A:middle
That means that if there's
a logged-in iCloud account

35
00:02:10.376 --> 00:02:14.656 A:middle
on the device, we'll use
that to identify the user;

36
00:02:15.196 --> 00:02:18.766 A:middle
if there's not, we'll provide
read-only anonymous access.

37
00:02:20.006 --> 00:02:24.116 A:middle
CloudKit supports both a concept
of public and private databases.

38
00:02:24.116 --> 00:02:26.776 A:middle
You can see public
databases as a soup

39
00:02:26.776 --> 00:02:30.126 A:middle
of data-that's all your
user can access to;

40
00:02:30.986 --> 00:02:36.796 A:middle
private databases are meant
to store the actual data just

41
00:02:36.796 --> 00:02:38.296 A:middle
on behalf of a specific user.

42
00:02:41.136 --> 00:02:43.946 A:middle
CloudKits support both
structured and bulk data.

43
00:02:44.366 --> 00:02:48.646 A:middle
You can use it to store large
files on the iCloud servers,

44
00:02:48.646 --> 00:02:52.186 A:middle
and we'll take care of the
transmitting them efficiently up

45
00:02:52.186 --> 00:02:54.646 A:middle
and from the iCloud servers.

46
00:02:55.926 --> 00:02:59.546 A:middle
Importantly, CloudKit is
a transport technology.

47
00:02:59.776 --> 00:03:02.356 A:middle
It doesn't provide
any local persistence.

48
00:03:02.476 --> 00:03:06.946 A:middle
It enables you to send and
receive data from the servers.

49
00:03:08.766 --> 00:03:09.506 A:middle
So let's start.

50
00:03:09.696 --> 00:03:12.526 A:middle
How do you enable CloudKit
in your application?

51
00:03:12.766 --> 00:03:14.966 A:middle
So first, you'll want

52
00:03:14.966 --> 00:03:18.006 A:middle
to navigate your application's
Capabilities pane in Xcode.

53
00:03:18.236 --> 00:03:21.056 A:middle
See that big iCloud off switch?

54
00:03:21.056 --> 00:03:22.086 A:middle
You want to turn it on.

55
00:03:22.946 --> 00:03:28.056 A:middle
And you want to check the
CloudKit checkbox here.

56
00:03:28.746 --> 00:03:29.806 A:middle
At that point, you're ready.

57
00:03:30.026 --> 00:03:30.986 A:middle
There's no fourth step.

58
00:03:32.646 --> 00:03:35.166 A:middle
Your app is ready to
read and write data

59
00:03:35.206 --> 00:03:36.976 A:middle
to Apple's iCloud server.

60
00:03:37.436 --> 00:03:40.406 A:middle
And to walk you through
the API on how to do this,

61
00:03:40.456 --> 00:03:43.656 A:middle
I'm going to hand over
to Paul to chat about it.

62
00:03:43.656 --> 00:03:44.476 A:middle
&gt;&gt; All right.

63
00:03:44.736 --> 00:03:45.866 A:middle
Thank you, Olivier.

64
00:03:46.516 --> 00:03:49.996 A:middle
[ Applause ]

65
00:03:50.496 --> 00:03:52.156 A:middle
So, as Olivier said,
my name is Paul.

66
00:03:52.156 --> 00:03:54.156 A:middle
I work on the CloudKit
client framework.

67
00:03:54.156 --> 00:03:57.276 A:middle
And I'm very excited to talk to
you guys today about CloudKit.

68
00:03:57.276 --> 00:03:58.666 A:middle
And we're going to start off.

69
00:03:58.666 --> 00:03:59.446 A:middle
We're going to start talking

70
00:03:59.446 --> 00:04:01.746 A:middle
about the Fundamental
CloudKit Objects.

71
00:04:01.796 --> 00:04:03.206 A:middle
These are going to
be the set of objects

72
00:04:03.206 --> 00:04:05.336 A:middle
that you're initially
exposed to when you open up

73
00:04:05.336 --> 00:04:06.986 A:middle
and start playing with
the CloudKit framework.

74
00:04:07.976 --> 00:04:09.446 A:middle
Just running through
a quick list of them,

75
00:04:09.446 --> 00:04:11.466 A:middle
we're going to talk about
containers; and we're going

76
00:04:11.466 --> 00:04:14.416 A:middle
to talk about databases; we're
going to talk about records;

77
00:04:14.886 --> 00:04:19.706 A:middle
we're going to talk about record
zones and record identifiers;

78
00:04:20.196 --> 00:04:21.555 A:middle
we're going to talk
about references;

79
00:04:21.555 --> 00:04:23.126 A:middle
and we're going to
talk about assets.

80
00:04:23.126 --> 00:04:23.766 A:middle
It's quite a list.

81
00:04:23.766 --> 00:04:26.886 A:middle
This is going to be a really fun
and really jam-packed session.

82
00:04:27.226 --> 00:04:28.836 A:middle
So let's get started.

83
00:04:28.836 --> 00:04:31.046 A:middle
And we're going to
talk about containers.

84
00:04:31.786 --> 00:04:33.876 A:middle
This is sort of the
idealized model

85
00:04:34.106 --> 00:04:36.656 A:middle
of your application
talking to iCloud.

86
00:04:36.656 --> 00:04:39.706 A:middle
Now, you guys are
application developers,

87
00:04:39.706 --> 00:04:41.046 A:middle
you guys are client developers.

88
00:04:41.406 --> 00:04:44.406 A:middle
And you know that your
application running on a client,

89
00:04:44.666 --> 00:04:47.596 A:middle
whether that client is an iPhone
or whether it be a MacBook,

90
00:04:48.186 --> 00:04:50.446 A:middle
yours is not the only process
running on that client;

91
00:04:50.876 --> 00:04:52.106 A:middle
rather, yours is one of many.

92
00:04:52.906 --> 00:04:56.486 A:middle
Now, on your client, your
process is going to be siloed,

93
00:04:56.486 --> 00:04:57.926 A:middle
sandboxed in some ways.

94
00:04:58.616 --> 00:05:02.206 A:middle
In some cases, it's
a literal sandbox.

95
00:05:02.236 --> 00:05:03.166 A:middle
Certainly in others,
you're running

96
00:05:03.166 --> 00:05:04.326 A:middle
in your own memory space.

97
00:05:05.006 --> 00:05:06.926 A:middle
This concept of taking
your client

98
00:05:06.926 --> 00:05:08.666 A:middle
and actually running
it separated

99
00:05:08.666 --> 00:05:11.346 A:middle
from other clients is pretty
powerful and has got a couple

100
00:05:11.346 --> 00:05:14.216 A:middle
of advantages: It
helps with security,

101
00:05:14.216 --> 00:05:16.646 A:middle
it helps with stability,
and it helps with privacy.

102
00:05:17.506 --> 00:05:20.536 A:middle
So as we were figuring out how
we wanted to build CloudKit,

103
00:05:20.586 --> 00:05:21.496 A:middle
we thought to ourselves,

104
00:05:21.496 --> 00:05:23.456 A:middle
"How can we take
these three advantages

105
00:05:23.846 --> 00:05:25.356 A:middle
and replicate them
up in the server?"

106
00:05:25.896 --> 00:05:28.026 A:middle
And so here's what we did.

107
00:05:28.026 --> 00:05:30.836 A:middle
Just as your client is
one of many-I'm sorry,

108
00:05:30.936 --> 00:05:33.826 A:middle
your application is one of
many-running on the client, so,

109
00:05:33.826 --> 00:05:35.806 A:middle
too, the part of iCloud
that you're talking

110
00:05:35.806 --> 00:05:39.056 A:middle
to is one of many up on iCloud.

111
00:05:39.096 --> 00:05:41.016 A:middle
We call these different
silos "containers."

112
00:05:41.646 --> 00:05:43.966 A:middle
So containers.

113
00:05:44.456 --> 00:05:46.566 A:middle
Containers are exposed
in the CloudKit framework

114
00:05:46.566 --> 00:05:48.556 A:middle
as the CKContainerClass.

115
00:05:48.556 --> 00:05:51.326 A:middle
CK is our prefix; you're going
to see this all over the place.

116
00:05:51.466 --> 00:05:54.146 A:middle
By default, one application
talks to one container.

117
00:05:55.546 --> 00:05:58.336 A:middle
Containers afford us the
ability to segregate data.

118
00:05:58.866 --> 00:06:01.306 A:middle
That means that your application
can read and write data

119
00:06:01.306 --> 00:06:03.856 A:middle
to iCloud, another application
can read and write data

120
00:06:03.856 --> 00:06:05.586 A:middle
to iCloud, and the two datasets

121
00:06:05.586 --> 00:06:07.326 A:middle
up on the server will
not be intermingled.

122
00:06:08.896 --> 00:06:11.986 A:middle
In addition to data segregation,
this containerization

123
00:06:11.986 --> 00:06:15.876 A:middle
of iCloud storage allows us to
encapsulate user information.

124
00:06:16.626 --> 00:06:17.876 A:middle
Now, as Olivier mentioned,

125
00:06:18.226 --> 00:06:21.776 A:middle
CloudKit involves using the
iCloud account infrastructure.

126
00:06:22.266 --> 00:06:24.496 A:middle
And we want to give
you some limited access

127
00:06:24.556 --> 00:06:26.896 A:middle
to that iCloud account,
and we want to make sure

128
00:06:26.896 --> 00:06:29.816 A:middle
that we're doing so in a
privacy-conscientious manner.

129
00:06:30.436 --> 00:06:33.486 A:middle
So in order to do that, we
encapsulate user information.

130
00:06:33.946 --> 00:06:36.406 A:middle
User information available
to your application is going

131
00:06:36.406 --> 00:06:38.516 A:middle
to be container-scoped
and therefore different

132
00:06:38.696 --> 00:06:41.416 A:middle
than the view of
user information seen

133
00:06:41.416 --> 00:06:42.456 A:middle
by another application.

134
00:06:43.896 --> 00:06:46.076 A:middle
Containers are managed
by you, the developer.

135
00:06:46.076 --> 00:06:49.256 A:middle
You're going to be managing
them via the WWDR portal.

136
00:06:50.186 --> 00:06:52.796 A:middle
It's important to note
that the namespace

137
00:06:52.796 --> 00:06:55.616 A:middle
of containers is global
to all developers.

138
00:06:55.966 --> 00:06:57.626 A:middle
So when you're choosing a
name for your container,

139
00:06:57.626 --> 00:07:01.706 A:middle
make sure that you're
using a reverse DNS name.

140
00:07:02.986 --> 00:07:06.266 A:middle
Now, right up there, just
like a little while ago,

141
00:07:06.266 --> 00:07:08.876 A:middle
I said that by default
there is one container

142
00:07:08.876 --> 00:07:10.736 A:middle
to one application,
a one-to-one mapping.

143
00:07:11.406 --> 00:07:12.876 A:middle
We think that this is
going to be successful

144
00:07:12.876 --> 00:07:14.486 A:middle
for 99 percent of use cases.

145
00:07:14.756 --> 00:07:16.886 A:middle
And certainly as you go
start using CloudKit,

146
00:07:16.886 --> 00:07:18.896 A:middle
it's going to be great as you
start exploring the framework.

147
00:07:19.216 --> 00:07:21.566 A:middle
But we recognized that
there are some scenarios

148
00:07:21.566 --> 00:07:23.386 A:middle
where you need a
more complex mapping.

149
00:07:23.716 --> 00:07:25.426 A:middle
So we support a many-to-many
model.

150
00:07:25.526 --> 00:07:29.166 A:middle
What we mean is that multiple
applications can coordinate

151
00:07:29.166 --> 00:07:31.026 A:middle
on the same iCloud container.

152
00:07:32.046 --> 00:07:34.006 A:middle
Also, a single application
can talk

153
00:07:34.006 --> 00:07:35.496 A:middle
to multiple iCloud containers.

154
00:07:38.306 --> 00:07:39.266 A:middle
On to databases.

155
00:07:40.226 --> 00:07:42.686 A:middle
One of the chief purposes
of CloudKit is the ability

156
00:07:42.686 --> 00:07:45.516 A:middle
to take your object model in
your application and replicate

157
00:07:45.516 --> 00:07:46.356 A:middle
that up to the server.

158
00:07:47.226 --> 00:07:49.206 A:middle
And so when we started
thinking about how we want

159
00:07:49.206 --> 00:07:52.056 A:middle
to present this modeling to
you, we thought to ourselves,

160
00:07:52.056 --> 00:07:54.486 A:middle
"How can we divide up
application objects?"

161
00:07:54.486 --> 00:07:55.706 A:middle
Obviously, all objects

162
00:07:55.706 --> 00:07:57.776 A:middle
in my application are
not treated equally.

163
00:07:58.076 --> 00:08:00.236 A:middle
And one of the first
things that we noticed was

164
00:08:00.236 --> 00:08:01.596 A:middle
that there's a fundamental
difference

165
00:08:01.636 --> 00:08:03.796 A:middle
in the audience of data.

166
00:08:04.576 --> 00:08:08.246 A:middle
Some data is intended to be used
by the user that created it.

167
00:08:08.736 --> 00:08:11.136 A:middle
If you imagine an application
where I'm writing up notes

168
00:08:11.136 --> 00:08:13.236 A:middle
and I want to see my notes
everywhere else, that's my data.

169
00:08:13.276 --> 00:08:15.576 A:middle
I create it, I consume it.

170
00:08:15.956 --> 00:08:19.386 A:middle
On the other hand, there's use
for what we call "public data."

171
00:08:19.816 --> 00:08:23.026 A:middle
This is data that can be
A, created by the user

172
00:08:23.026 --> 00:08:25.346 A:middle
for the benefit of a
community-think, perhaps,

173
00:08:25.346 --> 00:08:28.826 A:middle
a review on a restaurant-or it
could be information that you,

174
00:08:28.826 --> 00:08:30.386 A:middle
the developer, has
uploaded to iCloud

175
00:08:30.386 --> 00:08:32.265 A:middle
because it's useful
to your application.

176
00:08:33.025 --> 00:08:35.736 A:middle
In either case, the audience
is not just a single user

177
00:08:35.736 --> 00:08:36.686 A:middle
but a community of people.

178
00:08:37.395 --> 00:08:38.895 A:middle
So how did we solve the fact

179
00:08:38.895 --> 00:08:40.756 A:middle
that we've got these
different types of data?

180
00:08:41.346 --> 00:08:43.306 A:middle
Let's break open a container
and have a look inside.

181
00:08:44.186 --> 00:08:46.596 A:middle
Inside of a container
you're going to notice first

182
00:08:46.596 --> 00:08:48.026 A:middle
and foremost the
public database.

183
00:08:48.026 --> 00:08:48.916 A:middle
This is the soup.

184
00:08:48.916 --> 00:08:50.236 A:middle
This is where all of the public

185
00:08:50.236 --> 00:08:52.886 A:middle
and communal data
co-lives, comingles.

186
00:08:53.946 --> 00:08:55.036 A:middle
Additionally, you're
going to notice

187
00:08:55.036 --> 00:08:56.456 A:middle
that there's private databases.

188
00:08:56.566 --> 00:08:57.356 A:middle
And you're going to find

189
00:08:57.356 --> 00:08:59.076 A:middle
that there is an
individual private database

190
00:08:59.076 --> 00:09:00.716 A:middle
for each user of
your application.

191
00:09:01.436 --> 00:09:03.836 A:middle
Now, this is sort of
the 50,000-foot overview

192
00:09:03.836 --> 00:09:05.466 A:middle
of what the iCloud
infrastructure looks like.

193
00:09:05.606 --> 00:09:07.866 A:middle
But, you know, how much do
you guys care about that?

194
00:09:08.186 --> 00:09:09.806 A:middle
What you guys are
interested in is,

195
00:09:09.976 --> 00:09:12.206 A:middle
"What does this infrastructure
look like to me, the client,

196
00:09:12.366 --> 00:09:13.726 A:middle
running on a phone
or running on a Mac?"

197
00:09:14.736 --> 00:09:16.196 A:middle
Obviously, you're only
going to have access

198
00:09:16.196 --> 00:09:18.026 A:middle
to the currently
logged-in iCloud user.

199
00:09:18.216 --> 00:09:20.246 A:middle
So rather than seeing
a public database

200
00:09:20.246 --> 00:09:22.926 A:middle
and a gajillion private
databases, your view is going

201
00:09:22.926 --> 00:09:24.116 A:middle
to look a little
bit more like this.

202
00:09:24.256 --> 00:09:26.196 A:middle
You're going to have a choice
between the public database

203
00:09:26.656 --> 00:09:28.486 A:middle
or the private database
that is correlated

204
00:09:28.486 --> 00:09:30.006 A:middle
to the currently
logged-in iCloud user.

205
00:09:31.096 --> 00:09:32.556 A:middle
So databases.

206
00:09:33.096 --> 00:09:36.606 A:middle
Databases are exposed in our
API as a CKDatabase class.

207
00:09:37.176 --> 00:09:38.566 A:middle
Every application
has access to two

208
00:09:38.566 --> 00:09:40.516 A:middle
of them-the public
and the private.

209
00:09:41.376 --> 00:09:44.266 A:middle
Let's have a look at
a little bit of code.

210
00:09:44.556 --> 00:09:47.206 A:middle
The container is the initial
entry point into CloudKit.

211
00:09:47.726 --> 00:09:49.726 A:middle
Here we see that I'm talking
to my default container

212
00:09:50.066 --> 00:09:51.496 A:middle
and getting its public database.

213
00:09:51.876 --> 00:09:53.276 A:middle
I can also talk to
the default container

214
00:09:53.276 --> 00:09:54.476 A:middle
and get its private database.

215
00:09:55.186 --> 00:09:56.296 A:middle
Let's have a look
at the differences

216
00:09:56.296 --> 00:09:57.646 A:middle
between these two databases.

217
00:09:58.396 --> 00:10:01.166 A:middle
As we mentioned, the
desired audience is going

218
00:10:01.166 --> 00:10:02.906 A:middle
to be different between
the public database

219
00:10:02.906 --> 00:10:03.796 A:middle
and the private database.

220
00:10:03.836 --> 00:10:06.476 A:middle
The public DB is for shared
data; the private DB is

221
00:10:06.476 --> 00:10:07.386 A:middle
for the user's own data.

222
00:10:08.586 --> 00:10:11.116 A:middle
As such, we have different
requirements for whether

223
00:10:11.116 --> 00:10:13.756 A:middle
or not an iCloud account
needs to exist on the client.

224
00:10:14.566 --> 00:10:16.766 A:middle
In the private database-since
I'm reading

225
00:10:16.766 --> 00:10:19.566 A:middle
and writing a user's data-if
we have no notion of the user,

226
00:10:19.696 --> 00:10:22.146 A:middle
that is, if we don't have
a logged-in iCloud account,

227
00:10:22.616 --> 00:10:24.806 A:middle
there's really no utility
in moving this information

228
00:10:24.806 --> 00:10:26.336 A:middle
to and from the server.

229
00:10:26.656 --> 00:10:28.846 A:middle
So we require an iCloud
account to be logged

230
00:10:28.846 --> 00:10:30.446 A:middle
in if you want use
the private database.

231
00:10:30.996 --> 00:10:33.446 A:middle
In the public database, since
the audience is more communal,

232
00:10:33.686 --> 00:10:36.976 A:middle
we allow you read-only anonymous
access to the public database.

233
00:10:40.466 --> 00:10:42.796 A:middle
You'll recall from
yesterday's talk

234
00:10:42.876 --> 00:10:45.476 A:middle
that CloudKit is
free with limits.

235
00:10:45.846 --> 00:10:48.816 A:middle
So we've got some
pretty aggressive quotas.

236
00:10:49.266 --> 00:10:50.826 A:middle
That being said, we
still need to account

237
00:10:50.886 --> 00:10:53.846 A:middle
for where data's being used
so that we can talk to you

238
00:10:53.846 --> 00:10:55.516 A:middle
when we start approaching
those limits.

239
00:10:56.086 --> 00:10:59.086 A:middle
Data stored in the public
database is accounted

240
00:10:59.086 --> 00:11:00.196 A:middle
for on the developer's quota;

241
00:11:00.416 --> 00:11:02.226 A:middle
data stored in the private
database is accounted

242
00:11:02.226 --> 00:11:03.126 A:middle
for on the user's quota.

243
00:11:04.256 --> 00:11:06.066 A:middle
By default, data written

244
00:11:06.066 --> 00:11:08.986 A:middle
into the public database is
world-readable; data written

245
00:11:08.986 --> 00:11:10.796 A:middle
into the private
database is user-readable.

246
00:11:10.986 --> 00:11:13.656 A:middle
Again, it's the user's own data,
so they're really the only ones

247
00:11:13.656 --> 00:11:15.586 A:middle
that have access to it
in the private database.

248
00:11:16.756 --> 00:11:20.816 A:middle
We recognize that world-readable
is not an appropriate permission

249
00:11:20.816 --> 00:11:22.606 A:middle
for a lot of data in
the public database,

250
00:11:22.926 --> 00:11:25.416 A:middle
so we give you the ability
to edit these permissions

251
00:11:25.416 --> 00:11:27.456 A:middle
on a record-class level.

252
00:11:28.306 --> 00:11:31.126 A:middle
The mechanism by which you edit
these permissions is something

253
00:11:31.126 --> 00:11:33.376 A:middle
that we call the
iCloud Dashboard Roles.

254
00:11:33.946 --> 00:11:36.286 A:middle
iCloud Dashboard is the
administrative interface

255
00:11:36.346 --> 00:11:37.306 A:middle
into CloudKit.

256
00:11:37.926 --> 00:11:39.696 A:middle
I invite you guys to
come back on Thursday

257
00:11:39.746 --> 00:11:40.536 A:middle
for the advanced talk.

258
00:11:40.536 --> 00:11:43.246 A:middle
We're going to go into a lot
of detail about the Dashboard.

259
00:11:43.926 --> 00:11:46.446 A:middle
Suffice it to say, there's
an ability to set ACLs

260
00:11:46.726 --> 00:11:48.926 A:middle
so that a user is
a member of a role,

261
00:11:49.376 --> 00:11:52.356 A:middle
and a role can have
certain enlarged access

262
00:11:52.356 --> 00:11:53.436 A:middle
to a class of records.

263
00:11:54.246 --> 00:11:57.136 A:middle
In the private database
things start out lockdown.

264
00:11:57.216 --> 00:11:58.136 A:middle
There's no need to edit them.

265
00:11:58.236 --> 00:12:00.036 A:middle
The user is the only
one to create data,

266
00:12:00.036 --> 00:12:01.966 A:middle
and the user is the only one
to be able to read that data.

267
00:12:02.516 --> 00:12:04.856 A:middle
And when I say that the user is
the only one to be able to read

268
00:12:04.856 --> 00:12:06.136 A:middle
that data, I really mean it.

269
00:12:06.226 --> 00:12:08.836 A:middle
You as the developer
do not have access

270
00:12:08.836 --> 00:12:10.456 A:middle
into somebody else's
private database.

271
00:12:10.606 --> 00:12:11.536 A:middle
Their data is their own.

272
00:12:11.536 --> 00:12:12.446 A:middle
All right.

273
00:12:13.016 --> 00:12:14.546 A:middle
So those are databases.

274
00:12:14.906 --> 00:12:15.896 A:middle
Let's talk about records.

275
00:12:17.376 --> 00:12:19.946 A:middle
So here's our model
that we have so far.

276
00:12:19.946 --> 00:12:20.776 A:middle
We've got a container.

277
00:12:20.846 --> 00:12:22.246 A:middle
Within containers are databases.

278
00:12:22.246 --> 00:12:24.696 A:middle
Let's keep going down the rabbit
hole and crack open a database.

279
00:12:25.096 --> 00:12:27.326 A:middle
Inside the database we see
that it's full of records.

280
00:12:29.086 --> 00:12:32.056 A:middle
Records are exposed in our
framework as the CKRecord class.

281
00:12:32.196 --> 00:12:35.156 A:middle
They are the mechanism by
which you move structured data

282
00:12:35.226 --> 00:12:36.406 A:middle
to and from CloudKit.

283
00:12:37.816 --> 00:12:41.536 A:middle
CKRecords wrap key/value pairs.

284
00:12:41.626 --> 00:12:44.316 A:middle
Lest you think that a CKRecord
is just a glorified dictionary,

285
00:12:44.316 --> 00:12:45.486 A:middle
there are some additional
attributes

286
00:12:45.486 --> 00:12:47.816 A:middle
that make it worthwhile
of being its own class.

287
00:12:47.866 --> 00:12:49.916 A:middle
To start off with,
records have a record type.

288
00:12:50.726 --> 00:12:53.276 A:middle
If CloudKit is the mechanism by
which you take your object wrap

289
00:12:53.276 --> 00:12:55.406 A:middle
from your application and
move it into CloudKit,

290
00:12:55.816 --> 00:12:57.126 A:middle
then let's continue
with that analogy.

291
00:12:57.586 --> 00:13:00.416 A:middle
An instance of an object in
your application is equivalent

292
00:13:00.466 --> 00:13:02.386 A:middle
to an instance of a CKRecord.

293
00:13:02.946 --> 00:13:05.006 A:middle
Similarly, the class
of the object

294
00:13:05.006 --> 00:13:07.076 A:middle
in your application
is equivalent

295
00:13:07.076 --> 00:13:08.886 A:middle
to the record type
of the CKRecord.

296
00:13:11.286 --> 00:13:12.976 A:middle
Records have a just-in-time
schema.

297
00:13:13.196 --> 00:13:16.726 A:middle
You do not need to tell CloudKit
about what your data looks

298
00:13:16.826 --> 00:13:18.866 A:middle
like before you hand
CloudKit your data.

299
00:13:19.686 --> 00:13:23.076 A:middle
Hand us your data;
we'll figure it out.

300
00:13:23.966 --> 00:13:28.086 A:middle
CloudKit-excuse me, CKRecord
also support a raft of metadata.

301
00:13:28.466 --> 00:13:31.486 A:middle
For example, a record
understands when it was created

302
00:13:31.486 --> 00:13:33.646 A:middle
and who created it;
it understands

303
00:13:33.646 --> 00:13:36.626 A:middle
when a record was last modified
and who last modified it;

304
00:13:36.876 --> 00:13:40.016 A:middle
and lastly, a record contains
the notion of a change tag.

305
00:13:40.016 --> 00:13:42.596 A:middle
A change tag is a
version of a record.

306
00:13:42.596 --> 00:13:45.246 A:middle
It represents a specific
revision of this record.

307
00:13:45.686 --> 00:13:47.836 A:middle
And it's used so that we
can have a lightweight way

308
00:13:47.836 --> 00:13:49.266 A:middle
of determining whether
or not a client

309
00:13:49.266 --> 00:13:51.106 A:middle
and a server had the
same version of a record.

310
00:13:51.746 --> 00:13:55.756 A:middle
Let's talk a little bit
about record values.

311
00:13:55.756 --> 00:13:57.406 A:middle
CKRecords wrap key/value pairs.

312
00:13:57.806 --> 00:13:59.596 A:middle
What are the acceptable
value types

313
00:13:59.596 --> 00:14:01.046 A:middle
that you can put
into a CKRecord?

314
00:14:01.736 --> 00:14:03.606 A:middle
Well, we've got your
usual suspects.

315
00:14:03.606 --> 00:14:05.736 A:middle
Your P-list types-your
strings, your numbers,

316
00:14:05.736 --> 00:14:07.646 A:middle
your datas, and your dates.

317
00:14:07.716 --> 00:14:09.476 A:middle
We think that-especially

318
00:14:09.476 --> 00:14:11.636 A:middle
in the public database
domain-location is an

319
00:14:11.636 --> 00:14:12.466 A:middle
interesting scenario.

320
00:14:12.736 --> 00:14:16.246 A:middle
So CLLocation is a native type
that you can set on a CKRecord.

321
00:14:17.686 --> 00:14:19.956 A:middle
You can set CKReferences
and CKAssets.

322
00:14:19.956 --> 00:14:21.596 A:middle
We're going to go over what
those are in just a moment.

323
00:14:22.306 --> 00:14:25.206 A:middle
And lastly, any value
can be a single instance.

324
00:14:25.206 --> 00:14:26.826 A:middle
I can have a string or a date,

325
00:14:27.406 --> 00:14:29.006 A:middle
or it can be a homogeneous
array.

326
00:14:29.256 --> 00:14:32.536 A:middle
I can have an array of numbers
or an array of CKAssets.

327
00:14:32.536 --> 00:14:37.686 A:middle
Let's have a look at
a little bit of code.

328
00:14:38.206 --> 00:14:39.746 A:middle
Here we see a CKRecord.

329
00:14:39.826 --> 00:14:41.676 A:middle
The CKRecord initializer
takes a record type

330
00:14:41.676 --> 00:14:44.256 A:middle
because that's a invaluable and
necessary piece of a record.

331
00:14:44.976 --> 00:14:47.806 A:middle
You can set objects
and get objects

332
00:14:47.806 --> 00:14:49.506 A:middle
from a record using
a dictionary syntax

333
00:14:49.696 --> 00:14:51.836 A:middle
or a keyed subscripting syntax.

334
00:14:52.486 --> 00:14:55.026 A:middle
We also give you the ability to
enumerate all keys on a record

335
00:14:55.336 --> 00:14:57.976 A:middle
so that you can dump the
entire key/value pair.

336
00:14:59.276 --> 00:15:00.886 A:middle
Let's have a look at
a specific example.

337
00:15:01.596 --> 00:15:03.326 A:middle
Now, throughout this
talk, my example is going

338
00:15:03.326 --> 00:15:05.806 A:middle
to be an application that I've
created for me and my friends.

339
00:15:05.996 --> 00:15:09.016 A:middle
This application allows us to
create parties, and we're going

340
00:15:09.016 --> 00:15:11.546 A:middle
to stick party records
in the public database.

341
00:15:11.546 --> 00:15:13.776 A:middle
A party might be a
structured data-it's going

342
00:15:13.776 --> 00:15:15.536 A:middle
to have a summary, a
start date, an end date.

343
00:15:15.536 --> 00:15:17.846 A:middle
And it might also have
additional metadata

344
00:15:17.846 --> 00:15:20.166 A:middle
that we associate with
it-pictures of the party,

345
00:15:20.166 --> 00:15:23.716 A:middle
etc. So how do I
create a party record?

346
00:15:24.246 --> 00:15:26.016 A:middle
Well, I create one, just
as you might imagine,

347
00:15:26.016 --> 00:15:28.176 A:middle
with a party record type.

348
00:15:28.896 --> 00:15:31.276 A:middle
I can now set values on
it, and I can read values

349
00:15:31.276 --> 00:15:32.736 A:middle
from it using either
the dictionary

350
00:15:32.736 --> 00:15:34.536 A:middle
or key subscripting syntax.

351
00:15:35.226 --> 00:15:35.986 A:middle
Those are records.

352
00:15:36.756 --> 00:15:38.156 A:middle
Let's talk about record zones.

353
00:15:38.596 --> 00:15:40.406 A:middle
So this is the model that
we've just presented.

354
00:15:40.406 --> 00:15:44.466 A:middle
And it was kind of a lie, but
it was a useful lie at the time.

355
00:15:45.276 --> 00:15:51.236 A:middle
So, records don't exist by
themselves, just as objects

356
00:15:51.236 --> 00:15:52.946 A:middle
in your application don't
exist by themselves.

357
00:15:52.946 --> 00:15:54.756 A:middle
There's going to be a
natural grouping of objects

358
00:15:54.756 --> 00:15:55.656 A:middle
within your application.

359
00:15:56.046 --> 00:15:58.516 A:middle
Similarly, we want a way

360
00:15:58.516 --> 00:16:00.576 A:middle
to express this grouping
in CloudKit.

361
00:16:00.756 --> 00:16:03.926 A:middle
Fundamentally we're trying
via CloudKit to take as much

362
00:16:03.926 --> 00:16:06.336 A:middle
of your knowledge about your
object graph and reflect

363
00:16:06.336 --> 00:16:07.096 A:middle
that up to the server.

364
00:16:08.066 --> 00:16:10.466 A:middle
So the way that we group
records is via something

365
00:16:10.466 --> 00:16:11.646 A:middle
that we call a "record zone."

366
00:16:12.566 --> 00:16:14.606 A:middle
There can be multiple
records within a record zone,

367
00:16:15.246 --> 00:16:17.916 A:middle
and there can be multiple
record zones within a database.

368
00:16:18.666 --> 00:16:21.046 A:middle
Every database has a
default record zone.

369
00:16:21.366 --> 00:16:24.486 A:middle
Some databases support
additional custom record zones.

370
00:16:25.386 --> 00:16:27.686 A:middle
Record zones are the
default granularity

371
00:16:27.686 --> 00:16:28.296 A:middle
at which you're going

372
00:16:28.296 --> 00:16:30.426 A:middle
to do atomic commits
and change tracking.

373
00:16:31.016 --> 00:16:32.716 A:middle
If either of those
sounds interesting to you,

374
00:16:32.716 --> 00:16:34.596 A:middle
I invite you back on
Thursday for the events talk.

375
00:16:34.596 --> 00:16:37.406 A:middle
We're going to go over
a whole bunch of that.

376
00:16:37.616 --> 00:16:38.996 A:middle
So those were record zones.

377
00:16:38.996 --> 00:16:40.496 A:middle
Let's talk about
record identifiers.

378
00:16:41.366 --> 00:16:45.846 A:middle
Record identifiers-let's get
the code up there-are a tuple.

379
00:16:45.846 --> 00:16:48.306 A:middle
They represent both a
client-provided record name

380
00:16:48.876 --> 00:16:51.696 A:middle
and also the zone in which
that record name exists.

381
00:16:52.676 --> 00:16:54.046 A:middle
So what are their
characteristics?

382
00:16:54.556 --> 00:16:56.946 A:middle
Number one, they're
created by the client.

383
00:16:57.306 --> 00:17:01.246 A:middle
You get to specify the idea of
the record name of the record.

384
00:17:02.456 --> 00:17:05.746 A:middle
But because we are coupling this
record name-which is scoped per

385
00:17:05.746 --> 00:17:08.596 A:middle
record zone, along
with a reference

386
00:17:08.656 --> 00:17:12.136 A:middle
to the owning record zone-they
become a fully normalized

387
00:17:12.136 --> 00:17:13.236 A:middle
representation of the record.

388
00:17:13.326 --> 00:17:15.256 A:middle
It's the full path to it.

389
00:17:15.256 --> 00:17:19.695 A:middle
We think that it's going to be
fairly common for you to try

390
00:17:19.695 --> 00:17:22.246 A:middle
and bridge an external
dataset into CloudKit.

391
00:17:22.596 --> 00:17:25.746 A:middle
If you're doing so and if your
external dataset has a unique

392
00:17:25.746 --> 00:17:30.716 A:middle
key, using that unique key
as the CKRecordID allows you

393
00:17:30.716 --> 00:17:31.826 A:middle
to have a foreign key back

394
00:17:31.826 --> 00:17:33.756 A:middle
into your external
dataset-totally an

395
00:17:33.756 --> 00:17:34.436 A:middle
approved usage.

396
00:17:35.646 --> 00:17:37.186 A:middle
Let's have a look at some code.

397
00:17:37.616 --> 00:17:39.626 A:middle
Here we are, you know,
creating a record.

398
00:17:39.626 --> 00:17:40.446 A:middle
You've seen that already.

399
00:17:41.076 --> 00:17:42.596 A:middle
And we've got multiple
initializers

400
00:17:42.596 --> 00:17:45.126 A:middle
for CKRecord-you can either
choose to provide us a record ID

401
00:17:45.126 --> 00:17:46.106 A:middle
or you can choose not to.

402
00:17:46.236 --> 00:17:48.216 A:middle
If you choose not to
provide a record ID,

403
00:17:48.466 --> 00:17:51.206 A:middle
we're going to assign a
random UUID to the record.

404
00:17:52.206 --> 00:17:54.976 A:middle
Also, note here that when
I created my record ID,

405
00:17:54.976 --> 00:17:56.726 A:middle
I chose not to give it a zone.

406
00:17:57.186 --> 00:17:59.946 A:middle
Throughout CloudKit's
API, if you choose not

407
00:17:59.946 --> 00:18:01.556 A:middle
to give us a record zone,
we're going to assume

408
00:18:01.556 --> 00:18:02.856 A:middle
that you meant the default zone.

409
00:18:03.156 --> 00:18:07.626 A:middle
So here, I am creating a record
ID with the name WellKnownParty

410
00:18:07.736 --> 00:18:09.216 A:middle
that exists within
the default zone.

411
00:18:10.316 --> 00:18:11.526 A:middle
So those are record IDs.

412
00:18:12.066 --> 00:18:13.406 A:middle
Now let's talk about references.

413
00:18:14.126 --> 00:18:16.386 A:middle
Just as there's a natural
grouping of records that we want

414
00:18:16.386 --> 00:18:18.976 A:middle
to expose via a record
zone, there's also going

415
00:18:18.976 --> 00:18:20.996 A:middle
to be a natural relationship
between objects.

416
00:18:21.746 --> 00:18:24.776 A:middle
For example, let's say that in
addition to being able to write

417
00:18:24.776 --> 00:18:27.156 A:middle
up parties, I can assign
different clowns to parties.

418
00:18:27.186 --> 00:18:28.466 A:middle
Because what is the
point of a party

419
00:18:28.466 --> 00:18:29.806 A:middle
if you don't have a few clowns?

420
00:18:30.206 --> 00:18:31.916 A:middle
So I want some way

421
00:18:32.276 --> 00:18:36.146 A:middle
of representing the object
relationship that I have

422
00:18:36.146 --> 00:18:38.066 A:middle
between parties and
clowns up to the server.

423
00:18:38.186 --> 00:18:39.766 A:middle
And the way we do
that is via something

424
00:18:39.766 --> 00:18:40.946 A:middle
that we call references.

425
00:18:41.756 --> 00:18:44.826 A:middle
Now, you'll note here that
in this contrived example,

426
00:18:45.216 --> 00:18:46.926 A:middle
parties own clowns; that is,

427
00:18:46.926 --> 00:18:49.336 A:middle
we've got a parent-child
relationship with the party

428
00:18:49.336 --> 00:18:50.896 A:middle
as a parent and the
clown as a child,

429
00:18:50.896 --> 00:18:54.276 A:middle
and that the reference
goes from the child object,

430
00:18:54.276 --> 00:18:56.446 A:middle
from the clown, up
to its parent object.

431
00:18:56.816 --> 00:18:58.846 A:middle
We call that a "back reference."

432
00:19:00.316 --> 00:19:03.816 A:middle
References are exposed in our
API as the CKReference class.

433
00:19:03.816 --> 00:19:05.516 A:middle
They are a way of letting
the server understand the

434
00:19:05.516 --> 00:19:06.916 A:middle
relationship between records.

435
00:19:07.516 --> 00:19:09.756 A:middle
When the server understands the
relationship between records,

436
00:19:09.756 --> 00:19:12.736 A:middle
it can do very interesting
things, such as cascade deletes.

437
00:19:13.216 --> 00:19:16.266 A:middle
If the server notices that
you've deleted a record

438
00:19:16.266 --> 00:19:19.676 A:middle
and that record is the parent in
a parent and child relationship,

439
00:19:20.196 --> 00:19:21.896 A:middle
the server will automatically
go ahead

440
00:19:21.896 --> 00:19:24.606 A:middle
and cascade delete all
the children of that item.

441
00:19:25.116 --> 00:19:29.266 A:middle
With any database the scope
and scale of CloudKit,

442
00:19:29.266 --> 00:19:31.396 A:middle
dangling pointers are going
to be become a necessary

443
00:19:31.396 --> 00:19:35.326 A:middle
and inconvenient truth
of your use of CloudKit.

444
00:19:35.916 --> 00:19:38.256 A:middle
By the time you fetch a record
and you read a reference,

445
00:19:38.386 --> 00:19:40.246 A:middle
then you go and fetch the
target of that reference,

446
00:19:40.246 --> 00:19:41.536 A:middle
that target may not exist.

447
00:19:41.976 --> 00:19:44.746 A:middle
So it's important that your
code is resilient to this.

448
00:19:46.156 --> 00:19:49.076 A:middle
Again, as I mentioned, we
prefer back references.

449
00:19:49.076 --> 00:19:52.046 A:middle
It's not a requirement, but it's
more efficient if references go

450
00:19:52.046 --> 00:19:54.126 A:middle
from child objects
to parent objects.

451
00:19:54.256 --> 00:19:55.836 A:middle
This is the tip of the iceberg

452
00:19:55.836 --> 00:19:58.766 A:middle
in a very large topic
called data modeling.

453
00:19:59.066 --> 00:20:00.346 A:middle
And if you come back
on Thursday,

454
00:20:00.346 --> 00:20:01.276 A:middle
we're going to tell
you a whole bunch

455
00:20:01.276 --> 00:20:02.526 A:middle
about data modeling
and CloudKit.

456
00:20:04.786 --> 00:20:05.746 A:middle
Let's have a look at some code.

457
00:20:06.766 --> 00:20:11.006 A:middle
Here we see creating a reference
between two CKRecord instances

458
00:20:11.006 --> 00:20:12.166 A:middle
that I have in memory.

459
00:20:13.366 --> 00:20:15.316 A:middle
But it's not necessary
that I have the target

460
00:20:15.316 --> 00:20:16.516 A:middle
of a reference in memory.

461
00:20:17.146 --> 00:20:19.986 A:middle
I can make a reference
that points at a record ID.

462
00:20:20.656 --> 00:20:23.096 A:middle
This allows me to refer to a
record that I've got, you know,

463
00:20:23.236 --> 00:20:25.326 A:middle
reason to believe
exists up on the server.

464
00:20:26.116 --> 00:20:28.636 A:middle
If I were to save this record
and the target didn't exist,

465
00:20:28.636 --> 00:20:30.566 A:middle
I'd actually be creating
a dangling pointer.

466
00:20:30.656 --> 00:20:33.316 A:middle
And that's okay because the code
you're going to write is going

467
00:20:33.316 --> 00:20:36.106 A:middle
to support and be resilient in
the face of dangling pointers.

468
00:20:37.466 --> 00:20:39.096 A:middle
So those are references.

469
00:20:39.296 --> 00:20:41.346 A:middle
Now let's talk about assets.

470
00:20:42.176 --> 00:20:44.226 A:middle
Here we have our model
again, just a refresher,

471
00:20:44.276 --> 00:20:45.466 A:middle
container database record.

472
00:20:46.366 --> 00:20:50.336 A:middle
And now let's take the idea that
I want to write a record-I want

473
00:20:50.336 --> 00:20:51.846 A:middle
to write a party
record-up to the server.

474
00:20:51.846 --> 00:20:53.616 A:middle
But let's say that I want

475
00:20:53.616 --> 00:20:55.626 A:middle
to associate a large
file with that record.

476
00:20:55.746 --> 00:20:57.036 A:middle
Let's say, for example,
that we're going

477
00:20:57.036 --> 00:20:59.496 A:middle
to have a get-together after
the presentation and I'm going

478
00:20:59.496 --> 00:21:01.316 A:middle
to read you a screenplay
that I've been working on.

479
00:21:02.266 --> 00:21:04.266 A:middle
Now, I know-I understand-that
there's different

480
00:21:04.266 --> 00:21:06.186 A:middle
characteristics between
these different datas.

481
00:21:06.246 --> 00:21:09.156 A:middle
I understand that the record
about the party is structured.

482
00:21:09.306 --> 00:21:10.426 A:middle
You know, it's got a summary,

483
00:21:10.426 --> 00:21:11.836 A:middle
it's got a got a start
date, it's got an end date.

484
00:21:12.376 --> 00:21:15.376 A:middle
And, you know, just innately I
believe that I want the server

485
00:21:15.376 --> 00:21:17.776 A:middle
to understand those
bits about the record.

486
00:21:18.126 --> 00:21:20.826 A:middle
If we contrast that to
the screenplay, well,

487
00:21:20.826 --> 00:21:23.016 A:middle
the screenplay is just
essentially a bag of bits.

488
00:21:23.266 --> 00:21:24.826 A:middle
Right? I don't feel
any real need

489
00:21:24.826 --> 00:21:26.556 A:middle
to tell the server how
my screenplay breaks

490
00:21:26.556 --> 00:21:29.266 A:middle
down into amazing acts and,
you know, dashing scenes.

491
00:21:29.916 --> 00:21:32.876 A:middle
But I do know that
I want to treat them

492
00:21:32.876 --> 00:21:33.836 A:middle
as just an opaque bag.

493
00:21:34.296 --> 00:21:35.646 A:middle
So how do we solve this?

494
00:21:35.646 --> 00:21:38.256 A:middle
Well, we're going to
solve this and we're going

495
00:21:38.256 --> 00:21:40.396 A:middle
to solve the fact that data
has different characteristics

496
00:21:40.396 --> 00:21:42.086 A:middle
like this in two different ways.

497
00:21:42.836 --> 00:21:44.716 A:middle
Up on the server we're
going to introduce a notion

498
00:21:44.716 --> 00:21:46.186 A:middle
that we call "bulk storage."

499
00:21:46.836 --> 00:21:48.716 A:middle
As you might expect,
bulk storage is great

500
00:21:48.716 --> 00:21:49.926 A:middle
for storing bulk data.

501
00:21:51.176 --> 00:21:54.966 A:middle
Similarly, on the client
you're, going to tell CloudKit

502
00:21:54.966 --> 00:21:56.746 A:middle
about the different
characteristics of your data

503
00:21:57.036 --> 00:21:58.946 A:middle
by treating some
of it as a CKRecord

504
00:21:59.296 --> 00:22:01.146 A:middle
and other bits of
it as a CKAsset.

505
00:22:01.436 --> 00:22:04.216 A:middle
A CKAsset is the representation
of this bag of bits.

506
00:22:04.656 --> 00:22:06.766 A:middle
Now when with you ask
CloudKit to save this record,

507
00:22:07.246 --> 00:22:08.136 A:middle
the appropriate bits are going

508
00:22:08.136 --> 00:22:10.126 A:middle
to in the appropriate
database-structured data

509
00:22:10.126 --> 00:22:12.846 A:middle
in the public database,
bulk data in bulk storage.

510
00:22:13.646 --> 00:22:15.136 A:middle
So assets.

511
00:22:15.396 --> 00:22:19.466 A:middle
Assets are exposed in our
framework as the CKAsset class.

512
00:22:19.466 --> 00:22:21.226 A:middle
They represent large,
unstructured data.

513
00:22:22.196 --> 00:22:24.396 A:middle
Because you don't necessarily
want large, unstructured data

514
00:22:24.396 --> 00:22:26.826 A:middle
in memory, the way you
communicate assets to

515
00:22:26.826 --> 00:22:29.056 A:middle
and from CloudKit is
via files on disk.

516
00:22:30.506 --> 00:22:32.266 A:middle
Assets are owned by records.

517
00:22:32.376 --> 00:22:33.746 A:middle
This gives us a nice,
tight coupling

518
00:22:33.746 --> 00:22:34.896 A:middle
between a record and an asset.

519
00:22:36.186 --> 00:22:39.596 A:middle
What this allows the server to
do is garbage-collect assets.

520
00:22:40.006 --> 00:22:42.826 A:middle
Even though that we're storing
this data in two separate areas,

521
00:22:43.216 --> 00:22:45.866 A:middle
when the server detects a delete
for a record, it can go ahead

522
00:22:45.866 --> 00:22:48.676 A:middle
and clean up any assets that
were owned by that record.

523
00:22:49.936 --> 00:22:52.646 A:middle
Lastly, because we expect
CKAsset to be large,

524
00:22:52.646 --> 00:22:56.156 A:middle
opaque data, we go through some
great pains to try and move

525
00:22:56.156 --> 00:22:58.516 A:middle
that data to and from the server
as efficiently as possible.

526
00:22:58.676 --> 00:23:01.316 A:middle
This is all sort of inside
of CloudKit, but we're going

527
00:23:01.316 --> 00:23:02.676 A:middle
to send only the bits that,

528
00:23:03.246 --> 00:23:04.676 A:middle
the minimal amount
of bits that we can.

529
00:23:05.386 --> 00:23:07.496 A:middle
Let's have a look at some code.

530
00:23:08.566 --> 00:23:11.876 A:middle
Here I'm creating a
CKAsset based on a file URL

531
00:23:11.876 --> 00:23:13.106 A:middle
to my screenplay on disk.

532
00:23:13.866 --> 00:23:17.326 A:middle
And just like any other
CKRecord value supporting class,

533
00:23:17.386 --> 00:23:19.296 A:middle
I'm setting it on CKRecord.

534
00:23:19.986 --> 00:23:22.856 A:middle
So these are the fundamental
objects in CloudKit.

535
00:23:23.266 --> 00:23:24.806 A:middle
The first thing you
talk to is a container;

536
00:23:25.176 --> 00:23:27.056 A:middle
within a container are
two different databases;

537
00:23:27.516 --> 00:23:30.666 A:middle
databases contain records;
records are wrapped and grouped

538
00:23:30.666 --> 00:23:31.746 A:middle
within record zones;

539
00:23:32.136 --> 00:23:35.646 A:middle
you identify your record
via a record identifier;

540
00:23:35.646 --> 00:23:39.086 A:middle
records are related to one
another via references;

541
00:23:39.086 --> 00:23:41.016 A:middle
and large bulk data
is transmitted to

542
00:23:41.016 --> 00:23:43.356 A:middle
and from CloudKit via CKAssets.

543
00:23:45.286 --> 00:23:45.646 A:middle
All right.

544
00:23:45.786 --> 00:23:46.906 A:middle
You guys made it
through the nouns.

545
00:23:46.906 --> 00:23:48.086 A:middle
Now let's get into the verbs.

546
00:23:50.486 --> 00:23:54.176 A:middle
CloudKit, we offer two different
APIs for using CloudKit.

547
00:23:54.416 --> 00:23:56.986 A:middle
We call them the "operational
API" and the "convenience API."

548
00:23:57.786 --> 00:24:00.086 A:middle
The operational API
has every single bell

549
00:24:00.086 --> 00:24:01.546 A:middle
and whistle you might
care about.

550
00:24:01.546 --> 00:24:06.836 A:middle
And in some cases,
you're going to want

551
00:24:06.836 --> 00:24:08.446 A:middle
to tweak every single
bell and whistle

552
00:24:08.446 --> 00:24:09.896 A:middle
to fit your application's model.

553
00:24:10.926 --> 00:24:14.246 A:middle
But not every application really
wants to do all this tweaking,

554
00:24:14.406 --> 00:24:16.406 A:middle
and not every application
has enough knowledge

555
00:24:16.406 --> 00:24:17.786 A:middle
to set these bits correctly.

556
00:24:18.186 --> 00:24:20.206 A:middle
Sometimes you want to let
the framework make some

557
00:24:20.206 --> 00:24:22.366 A:middle
of these decisions
on your behalf.

558
00:24:22.516 --> 00:24:25.536 A:middle
And so we offer the
convenience API.

559
00:24:25.876 --> 00:24:26.706 A:middle
It's convenient.

560
00:24:26.706 --> 00:24:28.716 A:middle
It's going to be what you
want to start off playing

561
00:24:28.716 --> 00:24:30.206 A:middle
with when you start
looking at CloudKit.

562
00:24:30.316 --> 00:24:32.306 A:middle
For many uses of CloudKit,

563
00:24:32.306 --> 00:24:35.396 A:middle
it's all that you're
going to need to touch.

564
00:24:35.576 --> 00:24:37.696 A:middle
So quickly, we're going to
go over how you save a record

565
00:24:37.696 --> 00:24:40.036 A:middle
in the convenience API;
how you fetch a record

566
00:24:40.036 --> 00:24:42.726 A:middle
from the server via
the convenience API;

567
00:24:42.726 --> 00:24:45.966 A:middle
and how you can take a
fetched record, modify it,

568
00:24:45.966 --> 00:24:47.386 A:middle
and save it back
up to the server.

569
00:24:48.526 --> 00:24:49.986 A:middle
Let's start off with
saving a record.

570
00:24:52.876 --> 00:24:53.996 A:middle
Here I am, creating a record.

571
00:24:53.996 --> 00:24:55.926 A:middle
You guys are now very
well familiar with this.

572
00:24:57.566 --> 00:24:59.196 A:middle
When I want to save the
record, I have to choose

573
00:24:59.196 --> 00:25:02.176 A:middle
which database I
want to save it into.

574
00:25:02.176 --> 00:25:04.226 A:middle
Here I'm going to save the
data into the public database.

575
00:25:04.266 --> 00:25:05.536 A:middle
And how do I do that?

576
00:25:06.096 --> 00:25:08.896 A:middle
Well, I call the save record
with completion handler method.

577
00:25:08.896 --> 00:25:12.136 A:middle
Now, I want you guys to
note three separate things

578
00:25:12.136 --> 00:25:13.686 A:middle
about this code right here.

579
00:25:14.306 --> 00:25:15.856 A:middle
First of all, it's very simple.

580
00:25:16.296 --> 00:25:17.946 A:middle
Right? You guys aren't
providing a lot of options.

581
00:25:17.946 --> 00:25:20.166 A:middle
You're delegating a lot of
the bells and whistles like

582
00:25:20.426 --> 00:25:21.536 A:middle
"How important is this?

583
00:25:21.596 --> 00:25:23.326 A:middle
What interface should
I send this data over?"

584
00:25:23.736 --> 00:25:25.536 A:middle
You're delegating those
choices off to CloudKit.

585
00:25:26.576 --> 00:25:28.616 A:middle
Second, it's asynchronous.

586
00:25:28.946 --> 00:25:32.536 A:middle
As Olivier mentioned, CloudKit
does not have local persistence.

587
00:25:32.616 --> 00:25:33.996 A:middle
We are a transport technology.

588
00:25:34.116 --> 00:25:36.146 A:middle
We are going to transport
your data up to the server,

589
00:25:36.146 --> 00:25:38.196 A:middle
we'll store it on the server,
and we'll transport it back

590
00:25:38.196 --> 00:25:39.556 A:middle
down to other clients.

591
00:25:40.316 --> 00:25:43.626 A:middle
So when you save a record
via CloudKit, we are going

592
00:25:43.626 --> 00:25:45.716 A:middle
to attempt to save that
record directly to the server.

593
00:25:46.186 --> 00:25:48.916 A:middle
If it fails, we're going to tell
you about that immediately or,

594
00:25:49.016 --> 00:25:50.086 A:middle
you know, as quickly as we can.

595
00:25:51.396 --> 00:25:53.526 A:middle
Now, we don't want
to block threads

596
00:25:53.616 --> 00:25:55.006 A:middle
and we don't want you
to block the user.

597
00:25:55.226 --> 00:25:56.816 A:middle
So we don't want to make
this a synchronous call.

598
00:25:57.256 --> 00:25:59.006 A:middle
So here we've got an
asynchronous call.

599
00:26:00.366 --> 00:26:02.206 A:middle
Now, the third thing
I want you to note is

600
00:26:02.206 --> 00:26:04.066 A:middle
that even though this
is a very simple method,

601
00:26:04.456 --> 00:26:06.696 A:middle
we do provide an error
as part of the callback.

602
00:26:07.136 --> 00:26:09.516 A:middle
Now, if you've been
to WWC in the past

603
00:26:09.516 --> 00:26:11.036 A:middle
or if you've watched
any presentations,

604
00:26:11.036 --> 00:26:12.516 A:middle
you've seen something
that looks like this.

605
00:26:12.516 --> 00:26:14.096 A:middle
We get an Apple developer
up here,

606
00:26:14.096 --> 00:26:16.976 A:middle
and the Apple developer says,
"You need to handle errors

607
00:26:16.976 --> 00:26:18.096 A:middle
that are returned
from our framework."

608
00:26:18.096 --> 00:26:20.426 A:middle
Now, I'm not calling them liars.

609
00:26:20.606 --> 00:26:23.216 A:middle
It's true; you do need to handle
errors returned from frameworks.

610
00:26:23.216 --> 00:26:26.006 A:middle
In many applications it's the
difference between, you know,

611
00:26:26.006 --> 00:26:27.466 A:middle
a good and functioning
application

612
00:26:27.466 --> 00:26:28.506 A:middle
and a great application.

613
00:26:29.616 --> 00:26:30.846 A:middle
CloudKit is a little
bit different.

614
00:26:31.366 --> 00:26:33.026 A:middle
CloudKit, by its very nature,

615
00:26:33.026 --> 00:26:34.506 A:middle
is going to be talking
over the network.

616
00:26:34.756 --> 00:26:36.196 A:middle
Networks are inherently lossy.

617
00:26:36.516 --> 00:26:38.926 A:middle
Phones like to fall off
the network all the time.

618
00:26:38.926 --> 00:26:42.046 A:middle
So in CloudKit the difference
between handling an error

619
00:26:42.046 --> 00:26:44.376 A:middle
versus not handling an error
is really the difference

620
00:26:44.376 --> 00:26:46.606 A:middle
between a functional
and a nonfunctional app.

621
00:26:47.106 --> 00:26:49.026 A:middle
Error handling has got to
be one of the first things

622
00:26:49.026 --> 00:26:50.936 A:middle
that you look at when
you start using CloudKit.

623
00:26:50.936 --> 00:26:53.416 A:middle
I'm going to be a little bit
glib throughout the slides here,

624
00:26:53.416 --> 00:26:54.536 A:middle
but every time you
see a comment,

625
00:26:54.536 --> 00:26:57.146 A:middle
imagine that you're seeing just
some really nice error handling.

626
00:26:57.646 --> 00:27:00.346 A:middle
[Laughter]

627
00:27:00.846 --> 00:27:02.486 A:middle
So let's talk about, now
that we've saved a record

628
00:27:02.486 --> 00:27:04.146 A:middle
up to the server, how do
we fetch a record back

629
00:27:04.146 --> 00:27:04.986 A:middle
down from the server?

630
00:27:05.756 --> 00:27:09.646 A:middle
I'm going to start by
deciding which database I want

631
00:27:09.646 --> 00:27:10.486 A:middle
to fetch a record from.

632
00:27:10.556 --> 00:27:13.666 A:middle
I'm then going to construct
a record ID-the identifier

633
00:27:13.666 --> 00:27:16.526 A:middle
of the record I care
to fetch down.

634
00:27:16.526 --> 00:27:19.456 A:middle
Here I've gotten this name
either via some side channel

635
00:27:19.456 --> 00:27:21.136 A:middle
or something that's built
into my application.

636
00:27:22.586 --> 00:27:25.396 A:middle
I then can ask the database
to fetch a record with ID

637
00:27:25.396 --> 00:27:26.226 A:middle
with completionHandler.

638
00:27:26.826 --> 00:27:30.296 A:middle
Again, asynchronous, simple,
amazing error handling.

639
00:27:32.276 --> 00:27:34.716 A:middle
Once I fetched a
record-let's get that code back

640
00:27:34.716 --> 00:27:37.256 A:middle
up here-I want you to note

641
00:27:37.256 --> 00:27:40.646 A:middle
that the successful return value
is an actual CKRecord instance.

642
00:27:40.646 --> 00:27:43.016 A:middle
And this is a live,
honest-to-God CKRecord.

643
00:27:43.536 --> 00:27:45.726 A:middle
Let's say I'm having so much
fun at this party I pulled

644
00:27:46.126 --> 00:27:47.586 A:middle
that I want it to last
a little bit longer.

645
00:27:47.776 --> 00:27:50.346 A:middle
I can take a record off of it,
I can bump out the end date

646
00:27:50.346 --> 00:27:51.886 A:middle
by half an hour, and I can set

647
00:27:51.886 --> 00:27:53.816 A:middle
that record-that
value-back on the record.

648
00:27:54.656 --> 00:27:57.066 A:middle
Once I've done that, I can
take my CKRecord instance,

649
00:27:57.066 --> 00:27:58.816 A:middle
and just like one that
I've create the locally,

650
00:27:59.176 --> 00:28:02.506 A:middle
I can turn around and save it
back up to the database, again,

651
00:28:02.506 --> 00:28:03.456 A:middle
with amazing error handling.

652
00:28:04.496 --> 00:28:05.666 A:middle
All right.

653
00:28:05.666 --> 00:28:08.826 A:middle
So that's the convenience
API, the initial typical flow

654
00:28:08.826 --> 00:28:10.446 A:middle
that you're going to go through
when talking with CloudKit.

655
00:28:10.446 --> 00:28:12.586 A:middle
You're going to be saving
records; fetching records;

656
00:28:12.996 --> 00:28:16.086 A:middle
and taking those records that
you fetched, modifying them,

657
00:28:16.236 --> 00:28:18.096 A:middle
and putting them back
up to the server.

658
00:28:19.096 --> 00:28:21.926 A:middle
So now let's say my party
application starts becoming

659
00:28:21.926 --> 00:28:24.056 A:middle
really popular, and it's grown.

660
00:28:24.056 --> 00:28:27.036 A:middle
My user base is no longer me and
my friends, but it's all of you.

661
00:28:27.036 --> 00:28:28.566 A:middle
You know, everyone's
really excited

662
00:28:28.566 --> 00:28:29.906 A:middle
about joining into the parties.

663
00:28:30.596 --> 00:28:32.216 A:middle
What are some of the problems
I'm going to run into?

664
00:28:32.986 --> 00:28:35.706 A:middle
Well, let's assume that
when I started out,

665
00:28:35.706 --> 00:28:37.306 A:middle
I was a relatively
naive developer.

666
00:28:37.566 --> 00:28:40.276 A:middle
And because the developer
on stage said CloudKit's all

667
00:28:40.276 --> 00:28:41.856 A:middle
about taking your object
graph and moving it to

668
00:28:41.856 --> 00:28:43.956 A:middle
and from the cloud,
that's exactly what I did.

669
00:28:43.956 --> 00:28:45.586 A:middle
I had one-to-one mapping.

670
00:28:45.806 --> 00:28:47.756 A:middle
My objects went up to the cloud,

671
00:28:48.016 --> 00:28:50.546 A:middle
and on every client I would
fetch the entire cloud state,

672
00:28:50.546 --> 00:28:52.056 A:middle
and that would become
my object graph.

673
00:28:52.486 --> 00:28:53.996 A:middle
What are some problems
we're going to run into?

674
00:28:54.876 --> 00:28:57.776 A:middle
Well, at that point we've got
big data and a very tiny phone.

675
00:28:58.626 --> 00:29:01.596 A:middle
The more popular my app becomes,
the more data on the database,

676
00:29:01.906 --> 00:29:03.876 A:middle
the less reasonable
it is to have a cache

677
00:29:03.876 --> 00:29:06.406 A:middle
of that entire data
locally on my device.

678
00:29:06.816 --> 00:29:08.036 A:middle
So how are we going
to solve this?

679
00:29:08.816 --> 00:29:10.196 A:middle
Well, let's think about
what we want to do.

680
00:29:10.776 --> 00:29:13.456 A:middle
We want to keep the large
data up in the cloud.

681
00:29:13.606 --> 00:29:15.726 A:middle
The cloud is very good at
storing large datasets.

682
00:29:16.366 --> 00:29:18.676 A:middle
My client wants to view
a slice of that data.

683
00:29:19.276 --> 00:29:21.556 A:middle
Because I'm writing an
application for my users

684
00:29:21.556 --> 00:29:24.666 A:middle
and my users have their own
preferences, I want each client

685
00:29:24.666 --> 00:29:26.716 A:middle
to be able to view a
different slice of that data,

686
00:29:26.916 --> 00:29:28.406 A:middle
and each individual
client might want

687
00:29:28.406 --> 00:29:29.926 A:middle
to change its view of that data.

688
00:29:30.776 --> 00:29:32.816 A:middle
The way we solve
this is via something

689
00:29:32.816 --> 00:29:34.246 A:middle
that we call "queries."

690
00:29:35.176 --> 00:29:37.616 A:middle
Clients use queries to
focus their viewpoint

691
00:29:38.076 --> 00:29:40.986 A:middle
so that they can see a small
section of a large dataset

692
00:29:41.076 --> 00:29:42.586 A:middle
that exists up on the cloud.

693
00:29:43.556 --> 00:29:44.456 A:middle
So what is a query?

694
00:29:45.186 --> 00:29:47.136 A:middle
Well, as you might
imagine, it's exposed

695
00:29:47.136 --> 00:29:49.536 A:middle
in our API as the CKQuery class.

696
00:29:50.666 --> 00:29:52.866 A:middle
A query combines three
different things:

697
00:29:52.866 --> 00:29:54.706 A:middle
It combines a RecordType,
a predicate,

698
00:29:55.096 --> 00:29:56.796 A:middle
and optionally a
sort descriptor.

699
00:29:57.986 --> 00:30:00.126 A:middle
If you've used NSPredicate
in the past,

700
00:30:00.126 --> 00:30:02.046 A:middle
you know that NSPredicate
is very expressive.

701
00:30:03.036 --> 00:30:04.986 A:middle
CloudKit supports
most of NSPredicate.

702
00:30:05.226 --> 00:30:06.856 A:middle
We document the parts
that we do.

703
00:30:07.416 --> 00:30:09.516 A:middle
And if you hand us a predicate
that we don't understand,

704
00:30:09.516 --> 00:30:10.576 A:middle
we're going to throw
an exception.

705
00:30:10.716 --> 00:30:12.406 A:middle
So you're going to learn
pretty quickly which ones are

706
00:30:12.406 --> 00:30:13.246 A:middle
and are not supported.

707
00:30:13.726 --> 00:30:15.416 A:middle
Let's have a look at
some that are supported.

708
00:30:17.156 --> 00:30:19.476 A:middle
Here we see a predicate
that would match records

709
00:30:19.706 --> 00:30:21.936 A:middle
where name is equal to a
value that I had in memory.

710
00:30:23.376 --> 00:30:25.636 A:middle
Predicates allow you
to use dynamic keys

711
00:30:25.636 --> 00:30:28.126 A:middle
so that I don't have to know
the key name at compile time.

712
00:30:29.166 --> 00:30:31.386 A:middle
We can do relative
ordering comparisons,

713
00:30:31.386 --> 00:30:32.856 A:middle
as opposed to strict equalities.

714
00:30:33.436 --> 00:30:36.846 A:middle
We mentioned that location
is an interesting aspect

715
00:30:36.846 --> 00:30:37.836 A:middle
in the public database.

716
00:30:37.906 --> 00:30:40.656 A:middle
So you can query with
a location as a filter.

717
00:30:41.136 --> 00:30:43.306 A:middle
This is every location
within a hundred meters

718
00:30:43.306 --> 00:30:44.726 A:middle
of where we're standing
here in Moscone.

719
00:30:46.716 --> 00:30:48.736 A:middle
CloudKit supports a
tokenization search.

720
00:30:49.096 --> 00:30:52.616 A:middle
So what this predicate is going
to do is it's going to tokenize

721
00:30:52.706 --> 00:30:55.376 A:middle
that string after session,
and it's going to come

722
00:30:55.376 --> 00:30:57.906 A:middle
up with two different
tokens: "after" and "session."

723
00:30:58.726 --> 00:31:00.466 A:middle
This predicate will
match any record

724
00:31:00.466 --> 00:31:03.106 A:middle
that has those two
token as values.

725
00:31:03.806 --> 00:31:05.996 A:middle
These two tokens don't
need to exist side by side,

726
00:31:06.076 --> 00:31:08.176 A:middle
they don't even need to exist
in the same key/value pair,

727
00:31:08.736 --> 00:31:10.846 A:middle
but so long as the record
has the token "after"

728
00:31:11.096 --> 00:31:12.746 A:middle
and the record has
the token "session,"

729
00:31:13.136 --> 00:31:14.226 A:middle
the record will be a match.

730
00:31:15.766 --> 00:31:19.656 A:middle
And lastly, CloudKit supports
compound predicates joined using

731
00:31:19.656 --> 00:31:20.676 A:middle
the "and" operator.

732
00:31:21.216 --> 00:31:23.086 A:middle
Here we see a predicate
that does that.

733
00:31:25.406 --> 00:31:26.826 A:middle
Here we see the creation
of a query.

734
00:31:27.086 --> 00:31:28.166 A:middle
And as we mentioned,

735
00:31:28.166 --> 00:31:31.426 A:middle
it's combining both a
record type and a predicate.

736
00:31:32.956 --> 00:31:35.076 A:middle
How do I perform queries
after I've created them?

737
00:31:36.186 --> 00:31:39.176 A:middle
Well, just like saving records,
performing a query is going

738
00:31:39.176 --> 00:31:41.186 A:middle
to be a database-specific
operation.

739
00:31:41.396 --> 00:31:42.866 A:middle
So I'm going to choose
the database

740
00:31:42.866 --> 00:31:45.646 A:middle
on which I want to
perform a query.

741
00:31:45.756 --> 00:31:48.966 A:middle
Even in the simple API-in the
convenience API-we give you the

742
00:31:48.966 --> 00:31:52.096 A:middle
ability to restrict these
queries by record zones.

743
00:31:52.176 --> 00:31:54.166 A:middle
You see here that we're
not choosing to pass

744
00:31:54.166 --> 00:31:55.056 A:middle
on a record zone filter.

745
00:31:55.506 --> 00:31:56.886 A:middle
So this query is going to search

746
00:31:56.886 --> 00:31:58.436 A:middle
across the entire
public database.

747
00:31:58.946 --> 00:32:01.156 A:middle
Let's have a look
at what happens

748
00:32:01.226 --> 00:32:02.796 A:middle
in the completion handler.

749
00:32:03.026 --> 00:32:05.296 A:middle
First, of course,
amazing error handing.

750
00:32:05.736 --> 00:32:08.146 A:middle
Second, if we don't have errors,

751
00:32:08.146 --> 00:32:09.316 A:middle
let's have a look
at the results.

752
00:32:09.386 --> 00:32:11.696 A:middle
And you'll see here that
the results are actually

753
00:32:11.696 --> 00:32:12.736 A:middle
CKRecord instances.

754
00:32:12.736 --> 00:32:13.936 A:middle
These are live objects.

755
00:32:14.426 --> 00:32:16.506 A:middle
If I wanted to, I could
pull data off of them;

756
00:32:16.506 --> 00:32:18.886 A:middle
I could set data on them;
and I could even choose

757
00:32:18.886 --> 00:32:20.286 A:middle
to save them back to the server.

758
00:32:21.986 --> 00:32:26.446 A:middle
So a way to think about queries
is that queries are polls,

759
00:32:26.446 --> 00:32:28.446 A:middle
and polls are great
in some scenarios.

760
00:32:28.826 --> 00:32:31.036 A:middle
They're great for slicing
through large datasets.

761
00:32:31.286 --> 00:32:33.666 A:middle
If your application wants to
start up and, for example,

762
00:32:33.666 --> 00:32:35.906 A:middle
show all the parties-the
top ten parties

763
00:32:35.906 --> 00:32:38.646 A:middle
that are near me-a query is
absolutely the way to go.

764
00:32:39.806 --> 00:32:41.176 A:middle
But there's other things
that you might be tempted

765
00:32:41.176 --> 00:32:43.116 A:middle
to use a query for
that are not perfect.

766
00:32:43.116 --> 00:32:46.806 A:middle
If you find yourself issuing
the same query over and over

767
00:32:46.806 --> 00:32:49.516 A:middle
and over again, and you're
getting back a static,

768
00:32:49.516 --> 00:32:53.966 A:middle
a mostly same data result set,
well, then you've got a large,

769
00:32:53.966 --> 00:32:55.866 A:middle
mostly static dataset.

770
00:32:55.866 --> 00:32:58.606 A:middle
And queries are bad for that
use case for a few reasons.

771
00:32:59.336 --> 00:33:00.506 A:middle
They're bad for battery life.

772
00:33:00.636 --> 00:33:03.106 A:middle
You have to constantly
wake the device up, poll,

773
00:33:03.106 --> 00:33:05.986 A:middle
run the same query, and get back
more or less the same results.

774
00:33:06.886 --> 00:33:08.026 A:middle
They're bad for network traffic.

775
00:33:08.236 --> 00:33:10.676 A:middle
All those questions get to the
server, if they're not pulling

776
00:33:10.676 --> 00:33:13.206 A:middle
down new and interesting
data, why do we bother?

777
00:33:13.826 --> 00:33:17.036 A:middle
And they're also bad
for the user experience.

778
00:33:17.286 --> 00:33:20.506 A:middle
By definition, you're only
going to learn about new results

779
00:33:20.506 --> 00:33:24.056 A:middle
on the period of how
often you're polling.

780
00:33:24.726 --> 00:33:26.796 A:middle
Users nowadays have
come to expect push.

781
00:33:27.816 --> 00:33:30.386 A:middle
So as opposed to using
a client-generated query

782
00:33:30.386 --> 00:33:32.746 A:middle
in this scenario, what you
really want is you want the

783
00:33:32.746 --> 00:33:34.616 A:middle
server to be running the
query on your behalf.

784
00:33:35.466 --> 00:33:37.276 A:middle
You want the server to be
running the query on your behalf

785
00:33:37.366 --> 00:33:39.306 A:middle
in the background, and
you want that to happen

786
00:33:39.306 --> 00:33:41.756 A:middle
after every single record
save, whether it was you

787
00:33:41.756 --> 00:33:43.336 A:middle
or somebody else that
saved the record.

788
00:33:44.026 --> 00:33:46.136 A:middle
And lastly, of course,
you want pushes

789
00:33:46.136 --> 00:33:47.976 A:middle
when the results set changes.

790
00:33:48.816 --> 00:33:51.086 A:middle
Well, we've given you this,
and we call that subscriptions.

791
00:33:59.466 --> 00:34:01.436 A:middle
Yay! [Applause] So subscriptions
are exposed in our API

792
00:34:01.436 --> 00:34:03.516 A:middle
as the CKSubscription class.

793
00:34:03.986 --> 00:34:07.106 A:middle
They combine a record type,
a predicate, and push.

794
00:34:08.186 --> 00:34:10.496 A:middle
Push is delivered via
the Apple Push Service.

795
00:34:10.496 --> 00:34:11.835 A:middle
If you've used APS in the past,

796
00:34:11.835 --> 00:34:13.146 A:middle
you're largely familiar
with this.

797
00:34:13.186 --> 00:34:16.116 A:middle
But note: CloudKit pushes
are slightly augmented.

798
00:34:16.346 --> 00:34:18.476 A:middle
They contain CloudKit-specific
information

799
00:34:18.746 --> 00:34:20.246 A:middle
about what caused
the push to happen.

800
00:34:20.576 --> 00:34:21.985 A:middle
Let's have a look at an example.

801
00:34:23.726 --> 00:34:26.516 A:middle
Here we have a phone, and that
phone is interested in parties

802
00:34:26.516 --> 00:34:27.985 A:middle
that are going to be
happening in the future.

803
00:34:28.936 --> 00:34:31.866 A:middle
This phone, when it sees that
happening, wants to be alerted

804
00:34:31.866 --> 00:34:33.335 A:middle
with a push that
says "Party Time!"

805
00:34:34.446 --> 00:34:36.426 A:middle
The phone's going to go ahead
and save that up to iCloud.

806
00:34:36.516 --> 00:34:39.235 A:middle
And iCloud's going to,
you know, shuffle it away

807
00:34:39.235 --> 00:34:40.505 A:middle
with all the other
subscriptions.

808
00:34:41.436 --> 00:34:42.576 A:middle
Now along comes the Mac.

809
00:34:42.886 --> 00:34:44.275 A:middle
The Mac creates a new record.

810
00:34:44.505 --> 00:34:46.706 A:middle
It's a record-type party,
and it's happening tonight.

811
00:34:47.266 --> 00:34:49.476 A:middle
And because the Mac didn't
choose to give us a record ID,

812
00:34:49.476 --> 00:34:52.306 A:middle
we created that random
UUID you see.

813
00:34:53.766 --> 00:34:55.795 A:middle
The Mac goes ahead and
saves that to iCloud.

814
00:34:55.795 --> 00:34:58.276 A:middle
iCloud is then going to loop

815
00:34:58.336 --> 00:35:00.376 A:middle
through all the subscriptions
that it knows about.

816
00:35:00.756 --> 00:35:02.256 A:middle
Eventually it's going
to come across this one.

817
00:35:02.936 --> 00:35:04.256 A:middle
It's going to check
and say, "Yeah.

818
00:35:04.256 --> 00:35:05.366 A:middle
Okay, this is a new party.

819
00:35:05.926 --> 00:35:07.286 A:middle
And, yeah, it's happening
in the future."

820
00:35:07.946 --> 00:35:09.726 A:middle
So at that point it's
going to create a push.

821
00:35:09.976 --> 00:35:11.776 A:middle
And it's going to
take some information

822
00:35:12.056 --> 00:35:12.796 A:middle
from the subscription.

823
00:35:13.206 --> 00:35:15.476 A:middle
Here it took the alert
string "Party Time!"

824
00:35:16.066 --> 00:35:17.446 A:middle
It's going to take
other information

825
00:35:17.656 --> 00:35:19.066 A:middle
from the record itself.

826
00:35:19.066 --> 00:35:20.556 A:middle
Here we're pulling
in the record ID.

827
00:35:21.186 --> 00:35:23.316 A:middle
Now that I've constructed
this augmented payload,

828
00:35:23.426 --> 00:35:25.946 A:middle
I can send that augmented
payload down to all clients

829
00:35:25.996 --> 00:35:28.126 A:middle
that are registered
and interested in it.

830
00:35:29.316 --> 00:35:30.706 A:middle
So let's look at some code.

831
00:35:31.246 --> 00:35:32.526 A:middle
How do I create a subscription?

832
00:35:33.126 --> 00:35:37.356 A:middle
Well, a subscription combines
a record type and a predicate.

833
00:35:38.826 --> 00:35:41.136 A:middle
Because a subscription
is also in charge

834
00:35:41.136 --> 00:35:43.596 A:middle
of telling the server how
you want to be alerted,

835
00:35:44.106 --> 00:35:46.516 A:middle
we introduce a notion
called CKNotificationInfo.

836
00:35:47.546 --> 00:35:51.826 A:middle
Here we're requesting that
the server badges our icon,

837
00:35:51.826 --> 00:35:54.626 A:middle
that it plays a particular sound
pulled out of my resources,

838
00:35:55.296 --> 00:35:57.916 A:middle
and that it shows an alert
string based on a string

839
00:35:57.916 --> 00:35:59.166 A:middle
in my localized strings file.

840
00:35:59.846 --> 00:36:02.186 A:middle
I can associate that
notification info

841
00:36:02.186 --> 00:36:04.846 A:middle
with the subscription, and now
I've created everything I need

842
00:36:04.846 --> 00:36:05.556 A:middle
in my subscription.

843
00:36:06.266 --> 00:36:07.636 A:middle
Let's go ahead and
save it to the server.

844
00:36:08.826 --> 00:36:11.926 A:middle
As you might imagine via the
convenience API, it's simple,

845
00:36:11.926 --> 00:36:14.176 A:middle
it's asynchronous, and it's
got great error handling.

846
00:36:14.826 --> 00:36:17.376 A:middle
Let's look about
how you're going

847
00:36:17.376 --> 00:36:19.086 A:middle
to be handling subscriptions,
how you're going

848
00:36:19.086 --> 00:36:20.446 A:middle
to handle pushes
as they come in.

849
00:36:20.946 --> 00:36:23.676 A:middle
If you've used APS in the
past, you're probably familiar

850
00:36:23.676 --> 00:36:24.536 A:middle
with this code snippet.

851
00:36:25.116 --> 00:36:27.216 A:middle
This is your application
delegate implementing the

852
00:36:27.216 --> 00:36:29.726 A:middle
application
didReceiveRemoteNotification

853
00:36:29.966 --> 00:36:30.306 A:middle
method.

854
00:36:31.436 --> 00:36:34.406 A:middle
Now, in most scenarios
if you know the format

855
00:36:34.406 --> 00:36:36.206 A:middle
of the push payload
that's coming in,

856
00:36:36.496 --> 00:36:38.406 A:middle
you would just then iterate
through that dictionary,

857
00:36:38.406 --> 00:36:40.236 A:middle
pulling out the key/value
pairs that you care about.

858
00:36:41.076 --> 00:36:42.656 A:middle
However, because
CloudKit was the one

859
00:36:42.656 --> 00:36:43.846 A:middle
that generated this push,

860
00:36:44.376 --> 00:36:46.366 A:middle
we asked that you let
CloudKit do that parsing.

861
00:36:47.026 --> 00:36:50.156 A:middle
So the way you would do
that is via CKNotification,

862
00:36:50.156 --> 00:36:53.186 A:middle
then that really long one
I'm not going to name.

863
00:36:53.396 --> 00:36:56.296 A:middle
Once we've actually parsed
out a CKNotification,

864
00:36:56.426 --> 00:36:59.176 A:middle
you can pull off APS-level
information from it

865
00:36:59.596 --> 00:37:02.126 A:middle
and you can also pull off
CloudKit-level information

866
00:37:02.126 --> 00:37:02.966 A:middle
from it.

867
00:37:03.186 --> 00:37:06.486 A:middle
Here we're taking the record
ID of the saved record

868
00:37:06.876 --> 00:37:08.036 A:middle
that caused the push to happen.

869
00:37:09.476 --> 00:37:12.626 A:middle
So between queries and
subscriptions, we have an answer

870
00:37:12.626 --> 00:37:15.336 A:middle
to the big data, tiny
phone problem: You're going

871
00:37:15.336 --> 00:37:17.706 A:middle
to leave your large data up
in the cloud, and you're going

872
00:37:17.706 --> 00:37:21.646 A:middle
to use these two capabilities
to give your users a quick view

873
00:37:21.646 --> 00:37:24.016 A:middle
into that large dataset.

874
00:37:24.146 --> 00:37:28.846 A:middle
Now I want to talk about
CloudKit user accounts.

875
00:37:30.986 --> 00:37:33.926 A:middle
As Olivier mentioned,
CloudKit is built on top

876
00:37:33.926 --> 00:37:35.526 A:middle
of the iCloud account
infrastructure.

877
00:37:36.026 --> 00:37:37.036 A:middle
So what does that mean?

878
00:37:37.036 --> 00:37:41.466 A:middle
I want to focus a little bit
on how accounts are exposed

879
00:37:41.466 --> 00:37:43.626 A:middle
to you explicitly
throughout the API.

880
00:37:44.546 --> 00:37:46.116 A:middle
When you think about
an account system,

881
00:37:46.426 --> 00:37:48.036 A:middle
the first thing you think
about is authentication.

882
00:37:48.546 --> 00:37:51.056 A:middle
And CloudKit supports
authentication via the logged-in

883
00:37:51.116 --> 00:37:51.716 A:middle
iCloud user.

884
00:37:52.316 --> 00:37:54.256 A:middle
But that's not-you know, that's
sort of behind the scenes.

885
00:37:54.256 --> 00:37:55.256 A:middle
You guys don't care about that.

886
00:37:55.256 --> 00:37:55.866 A:middle
That's implicit.

887
00:37:55.976 --> 00:37:57.626 A:middle
Let's talk about
the explicit things.

888
00:37:58.286 --> 00:38:00.556 A:middle
What do we give you
because we're built

889
00:38:00.556 --> 00:38:01.746 A:middle
on top of iCloud accounts?

890
00:38:02.436 --> 00:38:05.006 A:middle
We give you identity, a way
of identifying the user.

891
00:38:05.716 --> 00:38:08.076 A:middle
We give you metadata,
the ability to save

892
00:38:08.076 --> 00:38:09.816 A:middle
and retrieve information
about users.

893
00:38:10.776 --> 00:38:13.176 A:middle
We do all of this in a
privacy-conscientious manner;

894
00:38:13.336 --> 00:38:14.476 A:middle
we don't want to
disclose anything

895
00:38:14.476 --> 00:38:16.736 A:middle
if the user hasn't agreed to it.

896
00:38:17.126 --> 00:38:19.066 A:middle
And lastly, we give
users the ability

897
00:38:19.066 --> 00:38:21.856 A:middle
to discover their friends that
are using your application.

898
00:38:22.506 --> 00:38:24.336 A:middle
Let's dive into each
one of these.

899
00:38:24.566 --> 00:38:26.346 A:middle
First of all, we're going
to talk about identity.

900
00:38:27.436 --> 00:38:29.076 A:middle
So here's our model.

901
00:38:29.076 --> 00:38:30.836 A:middle
We've got our client,
our application running

902
00:38:30.836 --> 00:38:32.966 A:middle
on the client, and all
of these different users

903
00:38:32.966 --> 00:38:34.786 A:middle
and their private databases
up in the container.

904
00:38:36.376 --> 00:38:39.536 A:middle
Your specific client is
going to be linked to one

905
00:38:39.536 --> 00:38:40.856 A:middle
and only one of those users.

906
00:38:41.036 --> 00:38:45.396 A:middle
This is related to
the user that's logged

907
00:38:45.396 --> 00:38:47.496 A:middle
in via iCloud locally
on your device.

908
00:38:48.546 --> 00:38:49.626 A:middle
Because this is iCloud,

909
00:38:49.976 --> 00:38:52.616 A:middle
we've got a rich backing
store of user information.

910
00:38:53.346 --> 00:38:57.336 A:middle
And because iCloud is the one
that is hosting your container,

911
00:38:57.986 --> 00:38:59.386 A:middle
we can correlate users.

912
00:38:59.636 --> 00:39:01.126 A:middle
For example, here we see

913
00:39:01.126 --> 00:39:04.686 A:middle
that the user whose email
address is c@iCloud.com is

914
00:39:04.686 --> 00:39:06.246 A:middle
linked to your current client.

915
00:39:07.366 --> 00:39:11.166 A:middle
So given this setup, how are we
going to present an identity?

916
00:39:11.166 --> 00:39:13.356 A:middle
How are we going to let
you know, your client,

917
00:39:13.356 --> 00:39:16.436 A:middle
your application, know
what user is logged in?

918
00:39:16.926 --> 00:39:18.256 A:middle
Well, naively you might think,

919
00:39:18.386 --> 00:39:19.916 A:middle
"Let's just give them
the email address."

920
00:39:20.156 --> 00:39:21.876 A:middle
We're not going to
do that, obviously.

921
00:39:22.446 --> 00:39:25.376 A:middle
That's private user-identifiable
information,

922
00:39:25.376 --> 00:39:26.636 A:middle
and we don't want
to give that out.

923
00:39:27.446 --> 00:39:30.716 A:middle
So instead what we do is on a
container-by-container basis,

924
00:39:31.416 --> 00:39:33.036 A:middle
we come up with a random ID.

925
00:39:33.366 --> 00:39:35.586 A:middle
This is an identifier
that is stable.

926
00:39:35.656 --> 00:39:37.456 A:middle
So that is your application,

927
00:39:37.676 --> 00:39:39.346 A:middle
no matter what client
it's running on,

928
00:39:39.756 --> 00:39:42.676 A:middle
talking to this container
will get the same identifier.

929
00:39:43.096 --> 00:39:46.306 A:middle
But it's not identifying
the user via any

930
00:39:46.306 --> 00:39:47.166 A:middle
personal information.

931
00:39:48.056 --> 00:39:51.706 A:middle
So we feel confident
giving you this identifier.

932
00:39:52.066 --> 00:39:54.316 A:middle
You can take this identifier
and do with it what you will.

933
00:39:55.276 --> 00:39:58.796 A:middle
Note that different applications
running on your phone,

934
00:39:58.796 --> 00:40:02.596 A:middle
because they're talking
to different containers,

935
00:40:02.986 --> 00:40:05.486 A:middle
are going to get back different
container-scoped record

936
00:40:05.486 --> 00:40:07.286 A:middle
identifiers for the same user.

937
00:40:08.146 --> 00:40:09.976 A:middle
This goes back to what we
talked about in the beginning,

938
00:40:09.976 --> 00:40:11.576 A:middle
that we've got user
encapsulation.

939
00:40:13.326 --> 00:40:15.236 A:middle
So user identity.

940
00:40:15.676 --> 00:40:19.346 A:middle
We expose user identity via
our API as a user record ID.

941
00:40:20.016 --> 00:40:22.216 A:middle
It is a stable identifier
for this user.

942
00:40:22.606 --> 00:40:24.796 A:middle
It will be the same for
your application no matter

943
00:40:24.796 --> 00:40:26.086 A:middle
where your application
is running.

944
00:40:26.716 --> 00:40:29.296 A:middle
It's scoped to the container,

945
00:40:29.576 --> 00:40:31.446 A:middle
so two different
applications are going to come

946
00:40:31.446 --> 00:40:33.726 A:middle
up with different
identifiers for the same user.

947
00:40:34.086 --> 00:40:34.656 A:middle
This is a feature.

948
00:40:36.126 --> 00:40:37.986 A:middle
And lastly, this is
an independent API.

949
00:40:38.156 --> 00:40:40.006 A:middle
This is a section of
the CloudKit framework.

950
00:40:40.646 --> 00:40:42.076 A:middle
You can use this
in collaboration

951
00:40:42.076 --> 00:40:42.936 A:middle
with the database API,

952
00:40:43.616 --> 00:40:45.496 A:middle
or you can use this
completely separately.

953
00:40:45.756 --> 00:40:48.286 A:middle
We've given you enough
support that if you wanted to,

954
00:40:48.286 --> 00:40:51.076 A:middle
you could implement a
login via iCloud flow

955
00:40:51.336 --> 00:40:53.496 A:middle
in your application using
the CloudKit framework.

956
00:40:54.426 --> 00:40:55.706 A:middle
Let's have a look at the code.

957
00:40:56.646 --> 00:41:01.916 A:middle
[Applause] All right.

958
00:41:01.916 --> 00:41:02.746 A:middle
Let's have a look at the code.

959
00:41:03.396 --> 00:41:06.106 A:middle
Because identity is a
container-scoped notion

960
00:41:06.246 --> 00:41:09.396 A:middle
and not a database-scoped
notion, we go to our container

961
00:41:09.396 --> 00:41:10.356 A:middle
to learn about our user.

962
00:41:11.116 --> 00:41:14.796 A:middle
Here we're asking our container
to fetch the user record ID.

963
00:41:15.276 --> 00:41:18.116 A:middle
Now, because we may have
to talk to the server

964
00:41:18.116 --> 00:41:20.666 A:middle
to figure this out, for example,
the first time you access

965
00:41:20.666 --> 00:41:23.416 A:middle
and try and learn about a record
ID, we have to go to the server

966
00:41:23.416 --> 00:41:25.376 A:middle
to do that translation and come

967
00:41:25.376 --> 00:41:26.626 A:middle
up with the container-scoped
info.

968
00:41:27.086 --> 00:41:29.566 A:middle
So asynchronous, and we
have to do error handling.

969
00:41:31.296 --> 00:41:32.666 A:middle
That's user identity.

970
00:41:32.966 --> 00:41:34.266 A:middle
Let's talk about user metadata.

971
00:41:35.126 --> 00:41:36.546 A:middle
And quickly, to recap
the problem,

972
00:41:36.546 --> 00:41:39.556 A:middle
what we have here is we
have a stable identifier,

973
00:41:39.556 --> 00:41:40.946 A:middle
and we've got a desire

974
00:41:41.006 --> 00:41:44.476 A:middle
to set key/value pairs
based on that identifier.

975
00:41:45.106 --> 00:41:47.776 A:middle
I don't know about you, but
to me that sounds very much

976
00:41:47.776 --> 00:41:49.326 A:middle
like what a record
was built to do.

977
00:41:49.906 --> 00:41:53.086 A:middle
So we expose users
as user records.

978
00:41:55.036 --> 00:41:56.906 A:middle
Looking inside a
container within a database,

979
00:41:56.906 --> 00:41:59.886 A:middle
we see that there is one user
record in the private database;

980
00:42:00.296 --> 00:42:02.656 A:middle
that user record
represents your user.

981
00:42:03.576 --> 00:42:06.376 A:middle
There are many user records
inside the public database,

982
00:42:06.656 --> 00:42:09.136 A:middle
representing each one of the
users of your application.

983
00:42:10.166 --> 00:42:11.886 A:middle
One of them will
have a record ID

984
00:42:12.096 --> 00:42:13.916 A:middle
that matches your
currently logged

985
00:42:13.916 --> 00:42:16.186 A:middle
in iCloud user's record ID.

986
00:42:17.036 --> 00:42:21.166 A:middle
So user metadata exposed via
our framework as a user record.

987
00:42:21.666 --> 00:42:24.976 A:middle
There's one per database that
represents your current user.

988
00:42:26.356 --> 00:42:27.936 A:middle
User records in the
public database,

989
00:42:27.936 --> 00:42:30.836 A:middle
like any other default
record, are world-readable.

990
00:42:32.446 --> 00:42:35.506 A:middle
They're treated mostly
like a ordinary record

991
00:42:35.776 --> 00:42:37.126 A:middle
with a record type
that we expose

992
00:42:37.126 --> 00:42:39.386 A:middle
in the framework
CKRecordTypeUserRecord.

993
00:42:39.906 --> 00:42:41.786 A:middle
But there are a couple
of caveats.

994
00:42:42.666 --> 00:42:46.176 A:middle
First off, these records
are reserved by the system.

995
00:42:46.486 --> 00:42:49.276 A:middle
You do not create a
user record; rather,

996
00:42:49.276 --> 00:42:51.136 A:middle
you fetch an existing
one from the server.

997
00:42:51.896 --> 00:42:53.996 A:middle
What that means is
that you can be assured

998
00:42:53.996 --> 00:42:56.406 A:middle
that when you fetch a
record for your current user

999
00:42:56.556 --> 00:42:57.846 A:middle
that it has not been spoofed.

1000
00:42:58.356 --> 00:42:59.996 A:middle
It was indeed iCloud
that created

1001
00:42:59.996 --> 00:43:01.166 A:middle
that record in the first place.

1002
00:43:02.116 --> 00:43:04.526 A:middle
Secondly, we think that it
doesn't make sense for you

1003
00:43:04.526 --> 00:43:06.916 A:middle
to be able to query the
entire set of user records

1004
00:43:06.916 --> 00:43:07.986 A:middle
in the public database.

1005
00:43:08.106 --> 00:43:10.496 A:middle
It doesn't really make sense to
be able to say, "I want to look

1006
00:43:10.496 --> 00:43:12.936 A:middle
at all users whose first
name begins with A."

1007
00:43:12.936 --> 00:43:15.806 A:middle
It's a little bit too
coarse-grained for something

1008
00:43:15.806 --> 00:43:19.076 A:middle
that we want to protect
privacy around.

1009
00:43:19.636 --> 00:43:22.306 A:middle
So we don't allow you
to query user records.

1010
00:43:22.996 --> 00:43:25.446 A:middle
Don't worry, we're going to
fix that in a couple of slides.

1011
00:43:26.396 --> 00:43:26.726 A:middle
All right.

1012
00:43:27.106 --> 00:43:27.826 A:middle
So what does it look like?

1013
00:43:28.506 --> 00:43:30.566 A:middle
Here we have the same
code that we saw earlier.

1014
00:43:30.766 --> 00:43:32.196 A:middle
We're fetching a user record ID.

1015
00:43:32.716 --> 00:43:36.236 A:middle
Once I have that CKRecordID,
I can go ahead and I can fetch

1016
00:43:36.236 --> 00:43:38.896 A:middle
that record from either
database that I choose.

1017
00:43:39.306 --> 00:43:41.866 A:middle
Here I'm choosing to fetch a
record with that identifier

1018
00:43:42.006 --> 00:43:43.406 A:middle
from the public database.

1019
00:43:44.326 --> 00:43:45.736 A:middle
Assuming that I don't
get an error,

1020
00:43:46.076 --> 00:43:50.006 A:middle
I now have a live CKRecord
that represents this user.

1021
00:43:50.396 --> 00:43:52.936 A:middle
And I can treat it like I
would any other CKRecord.

1022
00:43:53.616 --> 00:43:57.316 A:middle
I can pull records-excuse me-I
can pull key/value pairs off of,

1023
00:43:57.316 --> 00:43:59.206 A:middle
it, I can set key/value
pairs on it.

1024
00:43:59.506 --> 00:44:00.916 A:middle
And if I wanted to,
I could go ahead

1025
00:44:00.916 --> 00:44:02.176 A:middle
and save it back to the server.

1026
00:44:02.176 --> 00:44:05.566 A:middle
Now let's talk about privacy.

1027
00:44:06.246 --> 00:44:08.056 A:middle
We care very much about
our user's privacy.

1028
00:44:09.956 --> 00:44:13.006 A:middle
Therefore, we disclose no
information-no personally

1029
00:44:13.006 --> 00:44:15.516 A:middle
identifying user
information-about the current

1030
00:44:15.516 --> 00:44:16.616 A:middle
user by default.

1031
00:44:17.606 --> 00:44:21.446 A:middle
Now, we recognize that in some
cases your application is going

1032
00:44:21.446 --> 00:44:25.296 A:middle
to want to have limited access
to metadata about the user.

1033
00:44:26.636 --> 00:44:30.766 A:middle
So if you want that data, you
can request that from CloudKit.

1034
00:44:31.546 --> 00:44:33.726 A:middle
When you do, we're going to
go to the user to make sure

1035
00:44:33.726 --> 00:44:34.986 A:middle
that they're okay with that.

1036
00:44:35.476 --> 00:44:36.326 A:middle
Here we see an example

1037
00:44:36.326 --> 00:44:38.856 A:middle
of the party application
requesting the ability

1038
00:44:38.896 --> 00:44:40.936 A:middle
for my user account
to be discoverable

1039
00:44:40.936 --> 00:44:41.776 A:middle
within the application.

1040
00:44:42.006 --> 00:44:45.256 A:middle
The user can either choose
to allow or deny that.

1041
00:44:46.256 --> 00:44:48.796 A:middle
Assuming that the
user has acquiesced

1042
00:44:48.866 --> 00:44:50.426 A:middle
to this privacy request,

1043
00:44:50.876 --> 00:44:53.266 A:middle
we can go onto the next
phase, which is discovery.

1044
00:44:53.536 --> 00:44:55.446 A:middle
So let's talk a little
bit about user discovery.

1045
00:44:57.146 --> 00:44:57.706 A:middle
Here's our image.

1046
00:44:57.706 --> 00:44:59.556 A:middle
We've got our client
talking to a container.

1047
00:44:59.556 --> 00:45:01.436 A:middle
And the container
is backed by iCloud,

1048
00:45:01.496 --> 00:45:03.676 A:middle
and iCloud has all this
rich user information.

1049
00:45:05.156 --> 00:45:07.806 A:middle
If we look a little bit
more on the client side,

1050
00:45:07.956 --> 00:45:10.326 A:middle
we see that there's actually
two different processes involved

1051
00:45:10.326 --> 00:45:12.376 A:middle
here-there's your
client process,

1052
00:45:12.376 --> 00:45:14.426 A:middle
and then there's the
CloudKit process.

1053
00:45:14.426 --> 00:45:16.886 A:middle
And it's the CloudKit process
that's the one that's actually

1054
00:45:16.886 --> 00:45:18.496 A:middle
talking over the wire.

1055
00:45:19.476 --> 00:45:22.066 A:middle
So let's examine what
user discovery would look

1056
00:45:22.066 --> 00:45:24.226 A:middle
like if you want to
discover information

1057
00:45:24.226 --> 00:45:25.856 A:middle
about a user given a record ID.

1058
00:45:26.646 --> 00:45:30.076 A:middle
You take that record ID, and
you can send it off to CloudKit.

1059
00:45:30.696 --> 00:45:33.116 A:middle
CloudKit is going to in turn
send it up to the container.

1060
00:45:34.546 --> 00:45:35.756 A:middle
Once it hits the container,

1061
00:45:35.856 --> 00:45:38.626 A:middle
we're going to ask the iCloud
account info to exchange

1062
00:45:38.626 --> 00:45:40.546 A:middle
that for different
information-for information

1063
00:45:40.546 --> 00:45:41.286 A:middle
about that user.

1064
00:45:42.356 --> 00:45:45.396 A:middle
If that user has opted
in to discoverability,

1065
00:45:45.516 --> 00:45:46.846 A:middle
we're going to get
information back.

1066
00:45:47.616 --> 00:45:49.566 A:middle
That information can
traverse back to CloudKit

1067
00:45:49.666 --> 00:45:52.406 A:middle
and back via the process
boundary over to your client.

1068
00:45:53.686 --> 00:45:55.606 A:middle
But we're not restricted
to just record IDs.

1069
00:45:56.216 --> 00:45:58.336 A:middle
If your user enters
in an email address,

1070
00:45:58.336 --> 00:45:59.786 A:middle
we can do the same
sort of dance.

1071
00:46:00.166 --> 00:46:02.726 A:middle
This email address is sent from
your client over to CloudKit.

1072
00:46:03.486 --> 00:46:05.846 A:middle
CloudKit is then going to hash
it up a whole bunch of times

1073
00:46:05.846 --> 00:46:09.166 A:middle
so that we're not sending
personal info off the client.

1074
00:46:09.296 --> 00:46:10.946 A:middle
And we'll send that
up to the container.

1075
00:46:11.836 --> 00:46:13.816 A:middle
That container exchanges
it with iCloud.

1076
00:46:13.816 --> 00:46:16.166 A:middle
And if the target of
this discovery has opted

1077
00:46:16.166 --> 00:46:19.616 A:middle
in to discoverability, we're
going to get a result sent back.

1078
00:46:20.056 --> 00:46:21.536 A:middle
Those results can
go back to CloudKit

1079
00:46:21.536 --> 00:46:25.276 A:middle
and can traverse back
up to your client.

1080
00:46:25.696 --> 00:46:26.976 A:middle
Now, I'd like to think
that we are pretty good

1081
00:46:26.976 --> 00:46:29.056 A:middle
about naming things in
CloudKit, but this one we sort

1082
00:46:29.056 --> 00:46:30.266 A:middle
of didn't really do well.

1083
00:46:30.686 --> 00:46:33.496 A:middle
So we offer a different
way of doing user discovery

1084
00:46:33.496 --> 00:46:34.866 A:middle
that we call the
whole address book.

1085
00:46:34.866 --> 00:46:38.116 A:middle
And it's a way for you to
discover the whole address book.

1086
00:46:38.116 --> 00:46:41.366 A:middle
And the way this works is that
your client is going to say,

1087
00:46:41.706 --> 00:46:44.216 A:middle
"I would like to discover
the user record IDs

1088
00:46:44.336 --> 00:46:48.386 A:middle
and more information about
every user that is friends

1089
00:46:48.456 --> 00:46:50.466 A:middle
with my currently
logged-in iCloud user."

1090
00:46:51.516 --> 00:46:53.896 A:middle
You send that request over
to the CloudKit process.

1091
00:46:54.426 --> 00:46:56.796 A:middle
The CloudKit process
is then going to pull

1092
00:46:56.796 --> 00:46:57.996 A:middle
in the user's address book.

1093
00:46:57.996 --> 00:47:00.386 A:middle
We're going to take
all the email addresses

1094
00:47:00.386 --> 00:47:02.246 A:middle
in that address book; we're
going to hash them up;

1095
00:47:02.766 --> 00:47:04.096 A:middle
and we're going to
send, you know,

1096
00:47:04.096 --> 00:47:05.986 A:middle
a non-personally
identifying version

1097
00:47:05.986 --> 00:47:08.116 A:middle
of that address book
up to the container.

1098
00:47:09.366 --> 00:47:11.076 A:middle
The container's going to
send it off to iCloud.

1099
00:47:11.606 --> 00:47:14.966 A:middle
And for those members of my
address book that have opted

1100
00:47:14.966 --> 00:47:17.886 A:middle
in to discoverability, I'm going
to learn information about them.

1101
00:47:18.846 --> 00:47:20.576 A:middle
That information's going
to come back to CloudKit.

1102
00:47:20.646 --> 00:47:23.726 A:middle
That's going to be sent over the
process boundary to your client.

1103
00:47:24.776 --> 00:47:27.256 A:middle
Now, if you'll note, at
no point did your client

1104
00:47:27.456 --> 00:47:30.706 A:middle
in this little flow have access
to the user's address book.

1105
00:47:31.506 --> 00:47:34.046 A:middle
What this means is that we
can give you this support

1106
00:47:34.346 --> 00:47:37.766 A:middle
without requiring that your
user allows your application

1107
00:47:37.766 --> 00:47:40.186 A:middle
to the address book, meaning
that you don't have to have

1108
00:47:40.186 --> 00:47:42.676 A:middle
that blue alert-which is now
the white alert-giving your

1109
00:47:42.676 --> 00:47:44.466 A:middle
application access
to the address book.

1110
00:47:45.006 --> 00:47:51.906 A:middle
You can leverage it
without access to it.

1111
00:47:54.396 --> 00:47:55.456 A:middle
[Applause] So user discovery.

1112
00:47:55.886 --> 00:47:57.326 A:middle
These are the three
different kinds of inputs

1113
00:47:57.326 --> 00:47:58.656 A:middle
that we can have
for user discovery.

1114
00:47:58.656 --> 00:48:01.506 A:middle
You can start off with a user
RecordID, an email address,

1115
00:48:01.586 --> 00:48:04.076 A:middle
or a request to view
the entire address book.

1116
00:48:04.936 --> 00:48:06.376 A:middle
What do you get back
from user discovery?

1117
00:48:06.866 --> 00:48:08.366 A:middle
Well, you'll get
back a user RecordID;

1118
00:48:08.366 --> 00:48:10.956 A:middle
in the latter two cases,
that's new information.

1119
00:48:11.816 --> 00:48:14.376 A:middle
You also get back the first
and last name of this user.

1120
00:48:15.346 --> 00:48:18.046 A:middle
Now, of course, it
bears repeating,

1121
00:48:18.046 --> 00:48:19.566 A:middle
first and last name
is personally

1122
00:48:19.566 --> 00:48:20.766 A:middle
identifying information.

1123
00:48:21.116 --> 00:48:23.936 A:middle
So you're only going to get
discovery results for users

1124
00:48:23.936 --> 00:48:25.856 A:middle
that have opted in
to discoverability.

1125
00:48:26.386 --> 00:48:30.086 A:middle
Let's have a look
at some code here.

1126
00:48:31.906 --> 00:48:35.976 A:middle
Here we are asking our default
container to discover all

1127
00:48:35.976 --> 00:48:39.606 A:middle
of my users that are a
part of my address book.

1128
00:48:41.486 --> 00:48:42.496 A:middle
In the response-again,

1129
00:48:42.496 --> 00:48:46.596 A:middle
asynchronous error handling-in
the successful response case,

1130
00:48:46.596 --> 00:48:50.776 A:middle
what we see is that we get back
a CKDiscoveredUserInfo object.

1131
00:48:51.086 --> 00:48:54.316 A:middle
And that user info, from that,
I can pull a user record ID

1132
00:48:54.446 --> 00:48:55.546 A:middle
and a first and last name.

1133
00:48:56.946 --> 00:48:59.046 A:middle
So these are really
the four tent poles

1134
00:48:59.046 --> 00:49:02.786 A:middle
of how we do user accounts: We
give you a stable identifier;

1135
00:49:03.306 --> 00:49:06.436 A:middle
we give you the ability to
store and retrieve metadata

1136
00:49:06.436 --> 00:49:09.946 A:middle
about users; we protect
users' privacy;

1137
00:49:10.506 --> 00:49:12.176 A:middle
and we give your
users the ability

1138
00:49:12.176 --> 00:49:13.856 A:middle
to discover their friends
in your application.

1139
00:49:14.856 --> 00:49:17.396 A:middle
Now to tell you when it's
appropriate to use CloudKit

1140
00:49:17.396 --> 00:49:19.166 A:middle
versus some of the other
iCloud technologies

1141
00:49:19.166 --> 00:49:20.406 A:middle
that we already have exposed,

1142
00:49:20.746 --> 00:49:21.976 A:middle
I'd like to invite
back up Olivier Bonnet.

1143
00:49:22.516 --> 00:49:29.776 A:middle
[ Applause ]

1144
00:49:30.276 --> 00:49:30.806 A:middle
&gt;&gt; Olivier Bonnet:
Thank you, Paul.

1145
00:49:32.216 --> 00:49:36.066 A:middle
So CloudKit is the
new framework,

1146
00:49:36.066 --> 00:49:38.846 A:middle
but it doesn't obsolete
or deprecate any

1147
00:49:38.846 --> 00:49:40.406 A:middle
of the existing tools;

1148
00:49:40.546 --> 00:49:43.736 A:middle
it's really just a new
tool in your toolbox.

1149
00:49:44.256 --> 00:49:49.276 A:middle
Let's look at all the four
tools you now have and look

1150
00:49:49.276 --> 00:49:52.416 A:middle
at four different use cases
where we think they make sense

1151
00:49:52.416 --> 00:49:54.696 A:middle
and they're appropriate to use.

1152
00:49:54.916 --> 00:49:57.036 A:middle
So first, iCloud
Key Value Store.

1153
00:49:57.036 --> 00:50:02.086 A:middle
iCloud Key Value Store
keeps small payloads of data

1154
00:50:02.086 --> 00:50:05.666 A:middle
up to date between your
app and the iCloud servers.

1155
00:50:06.106 --> 00:50:07.876 A:middle
This is done asynchronously.

1156
00:50:08.036 --> 00:50:09.736 A:middle
Your app doesn't
really need to care

1157
00:50:09.736 --> 00:50:11.966 A:middle
about when and how this is done.

1158
00:50:12.376 --> 00:50:14.936 A:middle
We think this is great
for small amounts of data

1159
00:50:14.936 --> 00:50:18.526 A:middle
like application
preferences, game states.

1160
00:50:19.056 --> 00:50:22.996 A:middle
Conflict resolution is pretty
simple, last writer wins.

1161
00:50:23.136 --> 00:50:26.276 A:middle
So that's iCloud
Key Value Store.

1162
00:50:27.836 --> 00:50:30.026 A:middle
iCloud Drive builds on top

1163
00:50:30.026 --> 00:50:34.396 A:middle
of the existing iCloud
documents APIs.

1164
00:50:35.576 --> 00:50:38.446 A:middle
Doing so, it provides a
full offline cache on OS X.

1165
00:50:38.826 --> 00:50:40.926 A:middle
All the files on
the iCloud Drive

1166
00:50:40.926 --> 00:50:43.506 A:middle
of the user are downloaded
on OS X.

1167
00:50:43.506 --> 00:50:46.746 A:middle
It's completely unstructured and
totally tied to the filesystem.

1168
00:50:46.746 --> 00:50:51.246 A:middle
You use the file coordination
APIs to read and write data

1169
00:50:51.756 --> 00:50:55.066 A:middle
in your application iCloud
container in the filesystem.

1170
00:50:55.376 --> 00:50:58.636 A:middle
The iCloud Drive daemon
takes care of uploading

1171
00:50:58.636 --> 00:51:05.176 A:middle
and downloading those changes
up and from the iCloud servers.

1172
00:51:06.156 --> 00:51:09.306 A:middle
We think it's great for
document-centric apps or apps

1173
00:51:09.306 --> 00:51:11.606 A:middle
that need to deal with
an extinct file format.

1174
00:51:13.236 --> 00:51:17.976 A:middle
iCloud Core Data, built
on top of iCloud Drive,

1175
00:51:18.086 --> 00:51:21.056 A:middle
replicates off specific
user data

1176
00:51:22.016 --> 00:51:23.886 A:middle
between all the user's devices.

1177
00:51:24.416 --> 00:51:27.176 A:middle
It's great for keeping private
structured data in sync.

1178
00:51:27.486 --> 00:51:31.716 A:middle
But because it downloads
all the data to all devices,

1179
00:51:31.716 --> 00:51:34.356 A:middle
you're also constrained
to the size

1180
00:51:34.356 --> 00:51:36.426 A:middle
of the smallest device
in that case.

1181
00:51:37.656 --> 00:51:40.276 A:middle
Enters CloudKit, the
new kid on the block.

1182
00:51:40.276 --> 00:51:43.536 A:middle
And we think there are a
number of interesting use cases

1183
00:51:43.536 --> 00:51:45.716 A:middle
where CloudKit makes sense

1184
00:51:45.716 --> 00:51:50.846 A:middle
and complements pretty well
the existing technologies.

1185
00:51:50.956 --> 00:51:52.816 A:middle
So first, any public data.

1186
00:51:53.786 --> 00:51:57.476 A:middle
If your app-if you need to
give access to all the users

1187
00:51:57.476 --> 00:52:00.046 A:middle
of your app to large datasets,

